<!DOCTYPE html>
<html dir="ltr" lang="ja">
    <head>
        <title>Linux カーネル - from Assy</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="keywords" content="Assy,アッシー,詩,小説,物語,歴史,政治,経済,コンピュータ,パソコン,Linux,エッセイ,散文,哲学">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="../../css/style.css">


<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">

    </head>
    <body>
<div class="page">
<script type="text/javascript" src="../../js/jquery.min.js"></script>
<script type="text/javascript" src="../../js/script_smartmenus.js"></script>
<script type="text/javascript" src="../../js/links2.js"></script>

<p><a href="index.html">Linuxの世界観に戻る</a></p>
<div class="sidebar">
<iframe src="../../menus/linux_menu.html" class="sideiframe"></iframe>
</div>
<h1>Linux カーネル</h1>
<p>Linuxのカーネルに関する世界観です。</p>
<div id="toc"></div>
<div class="page_links">

<h1>OS</h1>
<h2>Linuxカーネルは常に動く</h2>
<p>パソコンはOSが無ければただの箱と言うが、言ってしまえば、Linuxをインストールしたパソコンでは、常にLinuxカーネルが動いている。</p>
<p>常に動きながら、たくさんのプログラムを「自身の上で実行する」、それがLinuxカーネルだ。</p>
<p>GNOMEはX11を使い、X11はカーネルを使い、カーネルはハードウェアを使う。そして、最終的にはCPUとメモリが動いている。</p>
<p>それを階層構造で示した時に、メインとなるのは、Linuxカーネルだ。</p>
<p>Androidのスマホを実行する場合でも、Linuxのサーバーを利用する場合でも、その環境で常に動いているのは、Linuxカーネルだ。</p>
<p>そう考えると、このLinuxと言うカーネルがオープンソースで技術的に公開されていて、自由に参加出来て、改良やコピー・再配布も自由である、と言うことは、この上なく良いことのように感じられる。それをやりたかったのが、GNU Projectのストールマンだと思う。</p>

<h2>カーネルとは何か</h2>
<p>カーネルとは、ハードウェアとソフトウェアの橋渡しをするものであり、システムの中で常に実行されながら、特定のプログラムを適切に実行し、それぞれのプログラムにリソース（利用出来るコンピュータ資源）を割り当てると同時に、ソフトウェアからの要求に応じてハードウェアへのアクセス手段を与え、サーバーやアプリケーションのようなプログラムがプログラムとして実行が可能になるための環境を与えるものだ。</p>
<p>OSの中で、カーネルとはある意味下層部分と上層部分を繋げるノリのようなものであると同時に、ソフトウェアの仕掛け全体の中核に位置しながら、全てをきちんと成り立たせる、オーケストラで言えばコンダクター（指揮者）のようなものである。だが、主役は基本的にアプリケーションであり、それらが楽器である。</p>
<p>OSの中でカーネルは一部分にすぎず、コマンドを入力するシェルや、それぞれの仕事を、UNIXにおいてはそれぞれが単機能に行う、各種のコマンドプログラム、システムに常駐するデーモン、X11のようなハードウェアをグラフィカルな操作インターフェースに変える特殊なアプリケーション、そしてコンパイラやパッケージ管理システムがなければならない。GNU/LinuxにおいてはカーネルはLinuxだが、OSとしてはGNUのさまざまなツールを使うため、GNU/Linuxと言う呼び名が適切であると（少なくともFSFからは）言われている。</p>
<p>だが、技術的に見ると、デバイスドライバやメモリマネージメントやCPUの並列処理といったハードウェアの操作と、C言語ライブラリとの関係性、そしてプロセスの作成とリソースの割り当てやタイムスケジューリング、OSの下層システムとして必要なファイルシステムの実現やネットワーク接続（パケットやソケットなどの実現）が多い。ハードウェアをソフトウェアから適切に使うことが主目的であり、ネットワークやグラフィックスで専門的な用途を行うためには、カーネルを用いてハードウェアに接続する「ユーザーランド」が必要となる。これは、Apache HTTPDやX11 Serverのようなシステムに必須の専門プログラムから、専門的アプリケーションに至る広汎なソフトウェア集団となる。</p>
<p>カーネルの特殊な用途はネットワークであり、カーネル以外での特殊の用途はグラフィックスであると言える。両者はカーネルとユーザーランドのどちらにも区分されにくい領域であり、WindowsのようなOSではグラフィックスはOSに統合されている。特に、X11はとても巨大であり、X11からKDE/GNOMEに至るGUIデスクトップ環境の領域は、「GUI時代の第二のカーネル（サブカーネル）」と呼んでも良いかもしれない。（サブカーネルは、僕の作った造語にすぎません。）</p>
<p><a href="linux_kernel.html">Linuxカーネル</a>も参照のこと。</p>

<h2>低水準レイヤーと高水準レイヤー</h2>
<p>Linuxの大きな特徴として、低水準レイヤーと高水準レイヤーがある。</p>
<p>UNIXでは、カーネルの上でユーザーランドのプログラムが動く、という比較的単純なレイヤー分けがなされているが、それが大きく様々なプログラムが発達したLinuxでは、もっと複雑になる。</p>
<p>たとえば、X11では、X Window Systemがまず最下部にあり、その上でGTKやQtなどのツールキットがあって、その上にGNOMEやKDEのデスクトップ環境がある。</p>
<p>また、プログラミング言語では、Javaの仮想マシンやPerlやPythonやRubyのインタープリタがあって、その上にDjangoやRailsなどのフレームワークがある。</p>
<p>ほかにも、ApacheなどのWebサーバや、TomcatやJBossなどのミドルウェア、MySQLやPostgreSQLなどのデータベース管理システムが、低水準レイヤーとして存在する。</p>
<p>こうした「高水準・低水準」という考え方がLinuxには多く見られる。自分でプログラムを開発する場合には、自分のプログラムよりも低水準のレイヤーがどういう技術仕様で実装されているかやAPIなどに習熟しておく必要がある。</p>
<p><a href="../prog_lang/system_layer.html">システムレイヤー</a>も参照のこと。</p>

<h2>OSの二つの側面</h2>
<p>OSには二つの側面、すなわち「ハードウェアシステムの利用の簡素化」と「リソースの管理」があります。</p>
<p>OSがもしなかったら、ハードウェアデバイスを自分で管理して操作しなければならない。多くのデバイスはとても詳細で難しい仕様をしており、プログラマが扱うのは困難を極める。OSは、このようなデバイスに対して抽象化を行い、「抽象化レイヤー」を提供する。</p>
<p>また、OSがもしなかったら、ハードウェアリソースを自分で管理しなければならない。これはすなわち、プリンタやストレージを扱うのであっても、きちんと正しい順番でプリンタやストレージに情報を書き込むことができなくなる、ということを意味する。OSは、こうしたリソースを裏側で管理し、「リソースマネージャ」として機能する。</p>
<p>詳しくは以下の書籍を参照のこと。</p>
<ul>
<li><a href="https://www.amazon.co.jp/%E3%82%AA%E3%83%9A%E3%83%AC%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E2%80%95%E8%A8%AD%E8%A8%88%E3%81%A8%E7%90%86%E8%AB%96%E3%81%8A%E3%82%88%E3%81%B3MINIX%E3%81%AB%E3%82%88%E3%82%8B%E5%AE%9F%E8%A3%85-S-%E3%82%BF%E3%83%8D%E3%83%B3%E3%83%90%E3%82%A6%E3%83%A0/dp/4894710471">オペレーティングシステム―設計と理論およびMINIXによる実装</a></li>
</ul>
<p><a href="../os/os.html">OS</a>も参照のこと。</p>

<h2>イベント通知としてのシステムコール</h2>
<p>Linuxカーネルは、システムコールによる、関数呼び出しとよく似たモデルで、サービスをプロセスやユーザーに提供する。</p>
<p>Linuxカーネルは、自分から何かをすることは一切なく、全てがサービスの要求であるシステムコールを通じて行われる。</p>
<p>このことを「イベント駆動」と呼ぶこともある。</p>
<p>しかしながら、僕はここに、コンピュータの原理や仕組みそのものの制限と可能性が見えてくると思う。</p>
<p>すなわち、Linuxはイベントによって「通知」し、普段何もしないで「待機」している中で「これをしろ」と言われた時だけそれをするようにできている。</p>
<p>実際のハードウェアと違って、「待機と通知」をコンピュータ上で実現するのは、意外と難しい。待機している状態にも、常にイベントが発生してこないかを「監視」し、もしイベントが通知されたら「対応」しなければならないからである。</p>
<p>Windows APIやX11では、これをイベントループ（メッセージループ）によって実現する。すなわち、常にイベントを監視するループ処理を行い、次のイベントが通知されたらそれに対して対処し、イベントハンドラに結びつけられたコールバック関数を実行する。</p>
<p>このように、LinuxであってもWindowsであってもX11であっても、意外と「待機しておけ」というだけの状態を作り出すのがパソコンでは難しい。逆に、自分から「印刷してほしい」とか、「このWebサイトの情報をダウンロードしてほしい」とお願いをするのは簡単である。そのため、待機をするだけであってもイベント駆動でプロセスからの要求に応答するように作る。</p>
<p>このような時に、イベント駆動だけではなく、「ポーリング」という仕組みを取ることもある。これは「一定時間ごとに問い合わせて確認する」というもので、イベント通知とは異なる仕組みである。また、キューとして発生したメッセージをひとつひとつ順番に処理する仕組みもある。これらはメールの確認やプリンターのジョブキューなどに使われている。</p>
<p><a href="linux_api.html">システムコール・API</a>も参照のこと。</p>

<h1>関連ページ</h1>
<h2>OS</h2>
<p><a href="../os/os.html">OS</a>を参照のこと。</p>

<h2>UNIX</h2>
<p><a href="../unix/unix.html">UNIX</a>を参照のこと。</p>

<h2>Linuxカーネル</h2>
<p><a href="linux_kernel.html">Linuxカーネル</a>を参照のこと。</p>

</div></div> <!--page-->










<script type="text/javascript" src="../../js/jquery.toc.js"></script>
<script type="text/javascript" src="../../js/script.js"></script>
<script type="text/javascript" src="../../js/scriptfortoc.js"></script>
</body>
</html>