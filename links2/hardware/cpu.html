<!DOCTYPE html>
<html dir="ltr" lang="ja">
    <head>
        <title>CPUの世界観 - from Assy</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="keywords" content="Assy,アッシー,詩,小説,物語,歴史,政治,経済,コンピュータ,パソコン,Linux,エッセイ,散文,哲学">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="../../css/style.css">


<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">

    </head>
    <body>
<div class="page">
<script type="text/javascript" src="../../js/jquery.min.js"></script>
<script type="text/javascript" src="../../js/script_smartmenus.js"></script>
<script type="text/javascript" src="../../js/links2.js"></script>

<p><a href="index.html">ハードウェアの世界観に戻る</a></p>
<div class="sidebar">
<iframe src="../../menus/hardware_menu.html" class="sideiframe"></iframe>
</div><h1>CPUの世界観</h1>
<p>CPUの世界観です。<a href="hardware.html">ハードウェア１（半導体）</a>や<a href="../prog_lang/assembly.html">アセンブリ言語</a>も参照のこと。</p>
<div id="toc"></div>
<div class="page_links">

<h1>CPUとは</h1>

<h2>CPUとは</h2>
<p>CPUは、コンピュータの中枢であり、全ての計算と実行を行うハードウェア装置。</p>
<p>加減乗除やシフト演算などの基本的な演算・計算ができる。</p>
<p>また、レジスタと呼ばれる高速の記憶領域を何個か持っていて、計算の時に使う。レジスタにはAX, BX, CX, DXのように名前がついている。</p>
<p>記憶を保管するためのメモリや、バスなどを通じて周辺機器ともつながっていて、メモリの中の記憶にアクセスしたり、メモリの中に記憶を保存したり、周辺機器に対するI/O操作を行うことができる。</p>
<p>また、実行中のプログラムに関しては、現在の命令の位置を任意の位置にジャンプする「ジャンプ命令」を使うことができる。</p>
<p>命令は機械が解釈できる機械語の命令で行うが、このそれぞれの命令を人間が理解しやすいように言葉（ニーモニック）に置き換えたアセンブリ言語というものがあり、機械語のプログラムを作る時はこうしたアセンブリ言語を用いる。<a href="../prog_lang/assembly.html">アセンブリ言語</a>を参照のこと。</p>
<p>後日注記：CPUの基本は、シフト演算、加減乗除、ジャンプ、メモリへのアクセスと操作。これらの命令を、メモリ上から読みだして実行し、メモリを変更することができる。</p>

<h2>現在のコンピュータではCPUを意識しない</h2>
<p>現在のコンピュータでは、CPUやメモリのような低レベルなハードウェアを直接触ることは少ない。OSが仮想CPUや仮想メモリの機構を用意しているため、プログラムを動かす時は原則プログラムはOSの管理下に置かれる。プログラムはマルチタスクを実現するコンテキストスイッチ（プログラムを並列で動かすためのOSの機構）やスケジューリング、あるいはプログラムが利用する変数などの記憶が物理アドレスの中のどの場所に保管されるのか、などといったことを意識することなく、独自の論理アドレス空間を用いて、並列でプログラムを動かすことができる。</p>
<p>だが、そうしたOSの低レベルなカーネル処理は、全て現実のCPUとメモリの上に実現されている。OSのコードを実行する場合でも、実際に動いているのはCPUであり、プログラムを動かす時も、実際に計算しているのはCPUである。CPUによっては「カーネルモード」と「ユーザーモード」が分かれていることがあり、カーネルはそうしたCPUの機能を用いて作られている。</p>
<p>また、機械語やアセンブリ言語でプログラムを書くこと自体、現在のコンピュータでは稀であり、多くの場合C言語のようなプログラミング言語を用いて、それを機械語に翻訳するコンパイラを用いて機械語を生成する。手動でハンドアセンブルするよりは遅く非効率的になるかもしれないが、機械語やアセンブリ言語で書くよりもはるかに人間に分かりやすく、書きやすく、読みやすく、また移植性も高い。多くのコンパイラで「最適化」が行われており、ハンドアセンブル並みに高速かつ効率的な機械語をコンパイラが生成することも少なくない。</p>
<p>もっとも高速なのはFORTRANやC/C++だが、遅くても生産性が高い他の言語を使うことで、さらに書きやすく、読みやすく、作りやすく、また移植性が高くなる。また、オブジェクト指向言語のような高水準の機能のある言語を用いて、より大規模かつ簡単な開発が可能となる。</p>
<p>ただし、現在のコンピュータではCPUを意識しないからといって、CPUが無関係になるわけではない。実際のところコンピュータの中枢として動いているのはCPUであり、そのため、CPUのクロックやコア数が上がるとコンピュータのスピードが速くなる。</p>
<p>また、OS開発者にとっては、CPUの処理は知っておかなければならない。近代のOSでは、CPUを有効に使うために、特にマルチプロセッサ環境やクラスタシステムなどにおいて、複数のプロセッサ（マルチプロセッサ）をいかに効率よく利用するか、などといった課題がある。</p>
<p>後日注記：本当のことを言うと、機械語やアセンブラでの開発をしていると、CPUの命令体系にじかに触れる機会は結構多い。特に、x86アセンブラをやろうとすると、Intel CPUの演算命令（ニーモニック）を覚える必要があるし、セグメント、レジスタ、アドレスなどの概念を知っておかなければならない。C/C++言語を用いて開発をする上でも、メモリアドレスを格納する変数であるポインタに触る機会はわりと多い。また、2進数や16進数の考え方は、デジタル処理を行う上で多用される。CPUの仕組みを知っておいて、損になることはなく、ためになる知識がそのままスキルアップになる。詳しくは<a href="../prog_lang/assembly.html">アセンブリ言語</a>を参照のこと。</p>

<h2>CPUと人間の頭脳の比較</h2>
<p>CPUはコンピュータの「頭脳」だが、人間の頭脳との違いは、プログラムを書かなければ動かない、ということ。機械語の命令に変換（コンパイル）することのできるプログラム言語を用いて、プログラムを書かなければ動かない。自らプログラムを考える、ということをCPUはしない。</p>
<p>その代わり、いったんプログラムが与えられてしまえば、それを計算するのは高速であり、人間よりはるかに速く、人間のするのと同じ計算をすることができる。また、CPUは柔軟で、どんなプログラムであっても、休まず、何度でも、ひたすらその通り計算することができる。</p>
<p>その代わり、プログラムに書いたことしか理解できないため、プログラムに書くことのできない曖昧で厳密性を欠いたことについては理解することができない。必ず、厳密な命令が必要であり、そしてどんなに細かすぎるようであっても、機械が理解することができるように、極めて細かく、厳密に、間違いなく丁寧に書かなければならない。</p>
<p>プログラムという方式の利点としては、「抽象性」が挙げられる。どんなに関数やサブルーチンを繰り返しても、その通りきちんと実行する。変数を用いることで、同じ言葉を繰り返さなくても、ひとつのサブルーチンでどんな場合にでも対応できる。人間であれば学習してひとつひとつ覚えなければならないことを、その計算式に基づいて簡単に計算できる。そのため、人間が頭で考えるには不可能な膨大な情報を瞬時かつ自動的に計算してくれる。そのため、形式的・手続き的な処理を行うのであれば、マウスやキーボードで行うより、プログラムを書いて行った方が楽である。OSのソースコードなどはとても膨大であるが、CPUは文句を言わずOSのコードを簡単に計算する。</p>

<h2>CPUの基本原理</h2>
<p>CPUは、基本的に二進数の0と1の組み合わせと桁上がりで足し算と引き算を行います。</p>
<p>技術の進歩とともに、計算出来る量が増えてきました。ですが、これは計算する人数が増えたのであって、決して計算する頭が賢くなったわけではありません。だから、基本的に昔のプロセッサと原理は変わらないのです。<!--僕も、良く分かっていないので、間違っているかもしれません。ごめんなさい。--></p>
<p>計算を行うための論理回路については<a href="computer_architecture.html">コンピュータの計算原理</a>を参照のこと。</p>
<p>Wikipedia</p>
<ul>
<li><a href="https://ja.wikipedia.org/wiki/CPU">CPU - Wikipedia</a></li>
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%83%97%E3%83%AD%E3%82%BB%E3%83%83%E3%82%B5">マイクロプロセッサ - Wikipedia</a></li>
</ul>

<h1>CPU</h1>
<p>（「<a href="https://www.amazon.co.jp/%E4%BB%A4%E5%92%8C05%E5%B9%B4-%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8%EF%BC%86%E3%82%AF%E3%83%AC%E3%83%90%E3%83%BC%E6%96%B9%E5%BC%8F%E3%81%A7%E3%82%88%E3%81%8F%E3%82%8F%E3%81%8B%E3%82%8B-%E6%A0%A2%E6%9C%A8%E5%85%88%E7%94%9F%E3%81%AE%E5%9F%BA%E6%9C%AC%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93%E8%80%85%E6%95%99%E5%AE%A4-%E6%83%85%E5%A0%B1%E5%87%A6%E7%90%86%E6%8A%80%E8%A1%93%E8%80%85%E8%A9%A6%E9%A8%93-%E6%A0%A2%E6%9C%A8/dp/4297131307">平成18年度 イメージ&クレバー方式でよくわかる栢木先生の基本情報技術者教室 (情報処理技術者試験)</a>」を参考に執筆しました。）</p>

<h2>レジスタ</h2>
<p>CPUの中には、「レジスタ」と呼ばれるパソコンの中でもっとも高速な記憶装置が存在する。（詳しくは<a href="../prog_lang/assembly.html">アセンブリ言語</a>を参照のこと。）</p>
<p>後日注記：たとえば、4bitのレジスタは桁ごとに値を分割し、4つのデータをそれぞれの記憶素子に対応させて入出力する。CPUにはこのようなレジスタが数種類から数十種類用意されており、CPUの演算対象・演算結果を参照・格納する直接の場所となる。</p>
<p>（放送大学「コンピュータの動作と管理 ('17)」を参考に執筆しました。）</p>
<div class="edit_date">
<p>2023.04.21編集</p>
</div>

<h2>命令実行サイクル</h2>
<p>機械語命令は、命令部（命令が機械語で指定される）とアドレス部（オペランドデータのアドレスが指定される）から成り立つ。</p>
<p>以下の１～６までの段階（ステージ）を順次、繰り返してプログラムは実行される。</p>
<table class="some_tables">
<tr><th class="min60">サイクル</th><th>説明</th></tr>
<tr><td>１．機械語命令の取り出し</td><td>命令アドレスから命令をひとつ取り出す。命令アドレスは次の命令を指すようになる。</td></tr>
<tr><td>２．デコーダによる機械語命令の解読</td><td>デコーダによって命令を解読する。</td></tr>
<tr><td>３．データの実効アドレスを計算</td><td>オペランド（データのこと）の実効アドレスを計算し、取り出しを指示する。</td></tr>
<tr><td>４．データの取り出し</td><td>データを取り出す。</td></tr>
<tr><td>５．機械語命令の実行</td><td>計算を実行処理する。</td></tr>
<tr><td>６．演算した結果の格納</td><td>計算結果をメモリに格納する。</td></tr>
</table>
<p>（「<a href="https://www.amazon.co.jp/%E4%BB%A4%E5%92%8C05%E5%B9%B4-%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8%EF%BC%86%E3%82%AF%E3%83%AC%E3%83%90%E3%83%BC%E6%96%B9%E5%BC%8F%E3%81%A7%E3%82%88%E3%81%8F%E3%82%8F%E3%81%8B%E3%82%8B-%E6%A0%A2%E6%9C%A8%E5%85%88%E7%94%9F%E3%81%AE%E5%9F%BA%E6%9C%AC%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93%E8%80%85%E6%95%99%E5%AE%A4-%E6%83%85%E5%A0%B1%E5%87%A6%E7%90%86%E6%8A%80%E8%A1%93%E8%80%85%E8%A9%A6%E9%A8%93-%E6%A0%A2%E6%9C%A8/dp/4297131307">平成18年度 イメージ&クレバー方式でよくわかる栢木先生の基本情報技術者教室 (情報処理技術者試験)</a>」を参考に執筆しました。）</p>

<h2>オペコードとオペランド</h2>
<p>オペコードとは命令のこと、オペランドとはデータ（たとえばレジスタや値、変数）のことです。</p>
<p>後日注記：CPUでは、文字列や数字をビットで表現する。CPUが一回の演算で処理できるビットを「ワード」、ワードの長さを「ワード長」という。また、データのビット長は「データ長」という。たとえば、32bitのワード長では、64bitのデータを二回に分けて演算するが、64bitのワード長では、64bitのデータを一回で演算できる。このため、CPUのビット数が上がるとデータの計算が高速になる。</p>
<p>（放送大学「コンピュータの動作と管理 ('17)」を参考に執筆しました。）</p>
<div class="edit_date">
<p>2023.04.21編集</p>
</div>

<h2>パイプライン</h2>
<p>（<a href="https://www.amazon.co.jp/%E8%A8%88%E7%AE%97%E6%A9%9F%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3-%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6%E5%85%A5%E9%96%80%E9%81%B8%E6%9B%B8-%E6%A9%8B%E6%9C%AC-%E6%98%AD%E6%B4%8B/dp/4785620277">計算機アーキテクチャ (情報工学入門選書)</a>を参考に執筆しました。）</p>
<p>CPUには、IF（命令の取り出し） - ID（命令のデコーダによる解読） - AC（実効アドレスの計算） - OF（オペランドデータの取り出し） - EX（演算処理の実行） - MW（メモリへの演算結果の書き込み）のように、命令ひとつであってもそれぞれのステージがある。</p>
<p>このそれぞれのステージを独立させ、複数の命令が実行される場合、ひとつの命令のすべてが終わるのを待ってから次の命令を実行させるのではなく、命令を構成するステージごとにステージが終わった段階で次の命令のステージを次々と実行させる方法をパイプライン処理という。</p>
<p>パイプラインがない状態では、CPUの命令は以下のように実行される。</p>
<table class="some_tables">
<tr><th class="min60">時間</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th></tr>
<tr><td>命令A</td><td>IF</td><td>ID</td><td>AC</td><td>OF</td><td>EX</td><td>MW</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>命令B</td><td></td><td></td><td></td><td></td><td></td><td></td><td>IF</td><td>ID</td><td>AC</td><td>OF</td><td>EX</td><td>MW</td></tr>
</table>
<p>パイプラインがある状態では、CPUの命令は以下のように実行される。</p>
<table class="some_tables">
<tr><th class="min60">時間</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th></tr>
<tr><td>命令A</td><td>IF</td><td>ID</td><td>AC</td><td>OF</td><td>EX</td><td>MW</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>命令B</td><td></td><td>IF</td><td>ID</td><td>AC</td><td>OF</td><td>EX</td><td>MW</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>命令C</td><td></td><td></td><td>IF</td><td>ID</td><td>AC</td><td>OF</td><td>EX</td><td>MW</td><td></td><td></td><td></td><td></td></tr>
<tr><td>命令D</td><td></td><td></td><td></td><td>IF</td><td>ID</td><td>AC</td><td>OF</td><td>EX</td><td>MW</td><td></td><td></td><td></td></tr>
<tr><td>命令E</td><td></td><td></td><td></td><td></td><td>IF</td><td>ID</td><td>AC</td><td>OF</td><td>EX</td><td>MW</td><td></td><td></td></tr>
<tr><td>命令F</td><td></td><td></td><td></td><td></td><td></td><td>IF</td><td>ID</td><td>AC</td><td>OF</td><td>EX</td><td>MW</td><td></td></tr>
<tr><td>命令G</td><td></td><td></td><td></td><td></td><td></td><td></td><td>IF</td><td>ID</td><td>AC</td><td>OF</td><td>EX</td><td>MW</td></tr>
</table>
<p>パイプライン制御については以下を参照のこと。</p>
<ul>
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3%E5%87%A6%E7%90%86">パイプライン処理 - Wikipedia</a></li>
</ul>

<h2>CISCとRISC</h2>
<p>CISCは、複雑な命令セットを持つCPUプロセッサで、RISCは、単純な命令セットを持つCPUプロセッサ。</p>
<p>RISCのように単純な命令セットだけを持つことで、それぞれの命令の処理速度が等速度になり、パイプラインによる処理効率が劇的に向上する。</p>
<p>詳しくは<a href="cpu_arch.html">CPUアーキテクチャ</a>を参照のこと。</p>

<h2>プログラムカウンタ</h2>
<p>CPUの命令について考える上で重要となる技術が、プログラムカウンタと呼ばれるデータ。</p>
<p>プログラムカウンタは、CPUの命令ごとに与えられる、命令の順番を表したデータである。</p>
<p>一行ごとに1ずつ増えることもあれば、命令の数や長さによっては2や3のように1以上増えることもある。</p>
<p>プログラムカウンタによって、CPUは今どの命令を実行しているのかということが分かる。</p>
<p>プログラムカウンタの使い道として、たとえばジャンプ命令を行った時、プログラムカウンタの値を編集して、別のプログラムカウンタの命令にジャンプすることがある。</p>
<p>ほかにも、ハードウェアやソフトウェアの割り込みが行われた時に、割り込みのためのプログラムカウンタを代入して、割り込み処理が終わった段階で元あったプログラムカウンタへの値に戻すことが考えられる。</p>
<p>また、マルチタスクのOSを実行していた時、現在のプログラムカウンタの値をメモリ上に退避して、プログラムを停止し、別のプログラムのプログラムカウンタを代入してタスクを切り替え、停止しておいた元のタスクを再実行する際に元のプログラムカウンタを再代入することなどが考えられる。</p>
<p>機械語やアセンブラ、あるいはFORTRANやBASICのプログラムを実行する上で行の最初に記述する行番号も、プログラムカウンタと同様の考え方であると言える。</p>
<p>（放送大学「コンピュータの動作と管理 ('17)」を参考に執筆しました。）</p>
<div class="edit_date">
<p>2023.04.21</p>
</div>

<h1>LSIの製造</h1>
<h2>LSIの製造工程</h2>
<p>LSIを作るためには、シリコンウエーハという材料を使う。</p>
<p>LSIの製造は、まず、シリコンウエーハの表面に化学的な膜を作る。そして、この膜の中に、論理回路のパターンを書きこむ。これをフォトリソグラフィという手法で行う。</p>
<p>LSIの製造には、前工程と後工程がある。</p>
<p>前工程はさらに「フロントエンド」と「バックエンド」に分かれる。フロントエンドでは、トランジスタ素子を作る。バックエンドでは、素子と素子を配線で繋ぐ。</p>
<p>後工程では、ウエーハを検品し、チップの良品と不良品を分ける。そして、リードフレームにチップをマウントし、電極をボンディング（金線で接続）する。</p>
<p>以下の書籍が参考になります。</p>
<ul>
<li><a href="https://www.amazon.co.jp/%E3%80%88%E5%85%A5%E9%96%80%E3%83%93%E3%82%B8%E3%83%A5%E3%82%A2%E3%83%AB%E3%83%86%E3%82%AF%E3%83%8E%E3%83%AD%E3%82%B8%E3%83%BC%E3%80%89%E6%9C%80%E6%96%B0-%E5%8D%8A%E5%B0%8E%E4%BD%93%E3%81%AE%E3%81%99%E3%81%B9%E3%81%A6-%E8%8F%8A%E5%9C%B0-%E6%AD%A3%E5%85%B8/dp/4534041098">入門ビジュアルテクノロジー　半導体のすべて</a></li>
</ul>
<div class="edit_date">
<p>2023.01.22-23編集</p>
</div>

<h2>ワイヤードロジック</h2>
<p>ワイヤードロジックは、物理的に形作られた論理回路のこと。RISC系のCPUで高速化を行うために使われる。</p>
<p>（放送大学「コンピュータの動作と管理 ('17)」を参考に執筆しました。）</p>
<div class="edit_date">
<p>2023.04.21</p>
</div>

<h1>余談</h1>
<h2>ソフトウェアやOSで仮想化しても動いているのはCPU</h2>
<p>CPUについて言えることとして、「ソフトウェアやOSでいくら仮想化しても、動いているのはCPUである」ということ。</p>
<p>マルチタスクや並列性のような技術は確かにソフトウェアでCPUを仮想化して実現しますが、それでも、パソコンで中央処理をしているのは、現実にあるCPU自身に他なりません。</p>
<p>Intel 4004以降のマイクロプロセッサでは、CPUやハードウェアに機械的回路を作って計算するのではなく、ソフトウェアで「プログラミング」を行って計算を実現します。（ちなみに、Intel 4004をインテルとともに開発したのは、嶋正利という日本人エンジニアです。）</p>
<p>そのため、プログラミングは必ず必要ですが、それでも、動いているのはCPUであり、それは機械語の命令を読み出し、解読し、データを取得し、計算し、実行結果を保管する、一連のステージを実行できるCPUプロセッサなのです。</p>

<h1>関連ページ</h1>
<h2>コンピュータ・アーキテクチャ</h2>
<p>コンピュータの計算原理については、<a href="computer_architecture.html">コンピュータの計算原理</a>を参照のこと。</p>
<p>情報科学については、<a href="../prog_lang/computer_science.html">コンピュータ科学</a>を参照のこと。</p>
<p>デジタル情報については、<a href="../prog_lang/digital.html">デジタル情報</a>を参照のこと。</p>

<h2>半導体・メモリ・IO</h2>
<p>半導体装置については、<a href="hardware.html">ハードウェア（１．半導体）</a>を参照のこと。</p>
<p>メモリやIOデバイスについては、<a href="memory.html">メモリ</a>や<a href="hardware2.html">ハードウェア（２．周辺機器）</a>を参照のこと。</p>
<p>GPUについては、<a href="gpu.html">GPU</a>を参照のこと。</p>

<h2>CPUアーキテクチャ</h2>
<p>CPUアーキテクチャについては、<a href="cpu_arch.html">CPUアーキテクチャ</a>を参照のこと。</p>
<p>具体的なCPUアーキテクチャについては、<a href="intel.html">Intel</a>、<a href="arm.html">ARM</a>、<a href="riscv.html">RISC-V</a>などを参照のこと。</p>

<h2>コンピュータの歴史</h2>
<p>コンピュータの歴史については、<a href="old_computer.html">古いコンピュータ（１．メインフレーム・ミニコン）</a>を参照のこと。</p>
<p>パソコンの歴史については、<a href="old_computer2.html">古いコンピュータ（２．パソコン）</a>、<a href="hobby_pc.html">ホビーパソコン</a>を参照のこと。</p>

<h2>アセンブラ</h2>
<p>x86アセンブラについては、<a href="../prog_lang/assembly.html">アセンブリ言語</a>を参照のこと。</p>
<p>C言語のインラインアセンブラについては、<a href="../prog_lang/c_preprocessor.html">C言語（６．プリプロセッサとインラインアセンブラ）</a>を参照のこと。</p>
<p>C言語のポインタについては、<a href="../prog_lang/c_pointer.html">C言語（４．配列とポインタ）</a>を参照のこと。</p>

<h2>コンパイラ</h2>
<p>コンパイラ技術については、<a href="../prog_lang/compiler_develop.html">コンパイラ</a>、<a href="../prog_lang/c_cpp_tools.html">C/C++開発ツール</a>、<a href="../linux/linux_unix_compiler.html">UNIXシステム管理（２．コンパイラ）</a>、<a href="../linux/gnu_toolchain.html">GNUツールチェイン</a>、<a href="../linux/llvm.html">LLVM/Clang</a>、<a href="../linux/make.html">Make</a>などを参照のこと。</p>
<p>C言語については<a href="../prog_lang/c.html">C言語（１．基本）</a>を、libcについては<a href="../linux/libc.html">libc</a>を参照のこと。</p>
<p>昔の言語については<a href="../prog_lang/oldpl.html">昔の言語</a>を、FORTRANについては<a href="../prog_lang/fortran.html">FORTRAN</a>を参照のこと。</p>

<h2>OSとカーネル</h2>
<p>OSについては<a href="../os/os.html">OS</a>を参照のこと。</p>
<p>Linuxカーネルについては<a href="../linux/linux_kernel.html">Linux カーネル開発</a>（<a href="../linux/linux_kernel_develop.html">開発</a>、<a href="../linux/linux_kernel_proc.html">プロセス</a>、<a href="../linux/linux_kernel_mm.html">メモリ管理</a>、<a href="../linux/linux_kernel_device.html">デバイス</a>、<a href="../linux/linux_kernel_src.html">ソースコード・カーネルモジュール</a>など）を参照のこと。</p>

<h2>電子機器</h2>
<p>電子機器については<a href="../tech/electronic_device.html">電子機器</a>を参照のこと。</p>

<h1>リンク集</h1>
<h2>書籍</h2>
<p>CPUについての基本は、以下のような書籍が参考になります。</p>
<ul>
<li><a href="https://www.amazon.co.jp/%E3%81%B5%E3%81%A4%E3%81%86%E3%81%AELinux%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-Linux%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B9%E3%82%8Bgcc%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E7%8E%8B%E9%81%93-%E9%9D%92%E6%9C%A8-%E5%B3%B0%E9%83%8E/dp/4797328355">ふつうのLinuxプログラミング Linuxの仕組みから学べるgccプログラミングの王道</a></li>
<li><a href="https://www.amazon.co.jp/%E4%BB%A4%E5%92%8C05%E5%B9%B4-%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8%EF%BC%86%E3%82%AF%E3%83%AC%E3%83%90%E3%83%BC%E6%96%B9%E5%BC%8F%E3%81%A7%E3%82%88%E3%81%8F%E3%82%8F%E3%81%8B%E3%82%8B-%E6%A0%A2%E6%9C%A8%E5%85%88%E7%94%9F%E3%81%AE%E5%9F%BA%E6%9C%AC%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93%E8%80%85%E6%95%99%E5%AE%A4-%E6%83%85%E5%A0%B1%E5%87%A6%E7%90%86%E6%8A%80%E8%A1%93%E8%80%85%E8%A9%A6%E9%A8%93-%E6%A0%A2%E6%9C%A8/dp/4297131307">平成18年度 イメージ&クレバー方式でよくわかる栢木先生の基本情報技術者教室 (情報処理技術者試験)</a></li>
<li><a href="https://www.amazon.co.jp/dp/4295002666/">徹底攻略 応用情報技術者教科書 平成30年度</a></li>
<li><a href="https://www.amazon.co.jp/%E8%A8%88%E7%AE%97%E6%A9%9F%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3-%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6%E5%85%A5%E9%96%80%E9%81%B8%E6%9B%B8-%E6%A9%8B%E6%9C%AC-%E6%98%AD%E6%B4%8B/dp/4785620277">計算機アーキテクチャ (情報工学入門選書)</a></li>
</ul>

<!--
<h1></h1>
<h2></h2>
<ul>
<li><a href=""></a></li>
</ul>
-->





</div></div> <!--page-->










<script type="text/javascript" src="../../js/jquery.toc.js"></script>
<script type="text/javascript" src="../../js/script.js"></script>
<script type="text/javascript" src="../../js/scriptfortoc.js"></script>
</body>
</html>