<!DOCTYPE html>
<html dir="ltr" lang="ja">
    <head>
        <title>コンピュータの計算原理の世界観 - from Assy</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="keywords" content="Assy,アッシー,詩,小説,物語,歴史,政治,経済,コンピュータ,パソコン,Linux,エッセイ,散文,哲学">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="../../css/style.css">

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML">
</script>

<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">

    </head>
    <body>
<div class="page">
<script type="text/javascript" src="../../js/jquery.min.js"></script>
<script type="text/javascript" src="../../js/script_smartmenus.js"></script>
<script type="text/javascript" src="../../js/links2.js"></script>

<p><a href="index.html">ハードウェアの世界観に戻る</a></p>
<div class="sidebar">
<iframe src="../../menus/hardware_menu.html" class="sideiframe"></iframe>
</div>
<h1>コンピュータの計算原理の世界観</h1>
<p>コンピュータの計算原理の世界観です。<a href="hardware.html">ハードウェア１（半導体）</a>も参照のこと。</p>

<div id="toc"></div>
<div class="page_links">

<h1>計算の仕組み</h1>
<h2>コンピュータの原理</h2>
<p>自分の書いたブログ「神々とともに生きる詩人」<a href="../../diary/blog_frey/2021.01.27.html">2021/01/27</a>より。</p>
<p>また、コンピュータの原理においては、二進数の計算は、00+00=00, 01+00=01, 00+01=01, 01+01=10の4通りしかない。</p>
<p>これは、論理回路におけるANDとEXORで機械的に計算できる。</p>
<p>実際は、これは下桁からの繰上りを考慮していないため、半加算器と呼ばれる。</p>
<p>下桁からの繰上りを考慮した全加算器は、二つの半加算器とOR回路によって実現できる。</p>
<p>また、減算については2の補数を加算することで実現できる。</p>
<p>2の補数とは、ビットの0と1を反転させて1を加算した表現のことで、正の数に負の数を加算すれば必ず桁あふれが起きて結果が0になる。</p>
<p>乗算と除算については、小学校で習う筆算と同様に、桁ごとに演算を行えば実現できる。</p>
<p>後日注記：正の数に負の数を加算するという説明は誤解を招く表現だった。同じ数の正負の符号を反転させた数を足すと、必ず桁あふれが起きて0になる。たとえば5は二進数で00000101だが、この2の補数はビットを反転させた11111010に1を加えて11111011となり、これが-5となる。00000101に11111011を加えると、必ず上に桁あふれをして00000000になる。注意点として、符号付き整数を扱う際、一番上のビットは正負の符号を示すために使うため、1ビットだけ情報量が少なくなる。</p>
<p>（放送大学「情報学へのとびら ('16)」を参考にして執筆しました。）</p>

<h2>スイッチングの基本</h2>
<p>論理回路はスイッチングによって実現できる。図にすると、要するにこういうことである。</p>
<p><img class="images_figure" src="switch2.png" alt="スイッチング"></p>

<h2>ブール代数</h2>
<p>ブール代数は、以下のようになる。</p>
<table class="some_tables">
<tr><th class="min60">ブール代数</th><th>例</th></tr>
<tr><td>論理和<br>OR</td><td>0 + 0 = 0<br>0 + 1 = 1<br>1 + 0 = 1<br>1 + 1 = 1</td></tr>
<tr><td>論理積<br>AND</td><td>0 ・ 0 = 0<br>0 ・ 1 = 0<br>1 ・ 0 = 0<br>1 ・ 1 = 1</td></tr>
<tr><td>論理否定<br>NOT</td><td>\(\overline{1}\) = 0<br>\(\overline{0}\) = 1</td></tr>
</table>
<p>このブール代数がなければ、コンピュータは生まれませんでした。</p>
<p>（詳しくは<a href="https://engineer-education.com/boolean-algebra/">【早わかり電子回路】ブール代数の基本をわかりやすく整理 [デジタル回路の前提知識] | アイアール技術者教育研究所</a>や<a href="https://www.amazon.co.jp/%E7%97%9B%E5%BF%AB-%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E5%AD%A6-%E9%9B%86%E8%8B%B1%E7%A4%BE%E6%96%87%E5%BA%AB-%E5%9D%82%E6%9D%91-%E5%81%A5/dp/4087474283">痛快! コンピュータ学</a>を参照のこと。）</p>
<div class="edit_date">
<p>2023.02.18編集</p>
</div>

<h2>論理回路</h2>
<p>（放送大学「情報学へのとびら ('16)」を参考にして執筆しました。）</p>

<h3>否定（NOT）</h3>
<p>否定は0と1を反転させたもの。</p>
<table class="some_tables">
<tr><th>P</th><th>NOT P</th></tr>
<tr><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td></tr>
</table>
<p>NOTの回路記号：</p>
<p><img class="images_figure" src="kairokigou_not2.png" alt="NOT回路記号"></p>

<h3>論理積（AND）</h3>
<p>論理積は2つの値の（算術）積となっている。</p>
<table class="some_tables">
<tr><th>P</th><th>Q</th><th>P AND Q</th></tr>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>1</td></tr>
</table>
<p>ANDの回路記号：</p>
<p><img class="images_figure" src="kairokigou_and.png" alt="AND回路記号"></p>

<h3>論理和（OR）</h3>
<p>論理和も2つの値の（算術）和にだいたいなっているが、1と1の論理和は1となっている。</p>
<table class="some_tables">
<tr><th>P</th><th>Q</th><th>P OR Q</th></tr>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td></tr>
</table>
<p>ORの回路記号：</p>
<p><img class="images_figure" src="kairokigou_or.png" alt="OR回路記号"></p>

<h3>排他的論理和（XOR）</h3>
<p>排他的論理和（XORあるいはEXOR）は2つの値のどちらか一方が1であれば答えが1になるが、両方とも1の場合は答えが0になる。</p>
<table class="some_tables">
<tr><th>P</th><th>Q</th><th>P XOR Q</th></tr>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td></tr>
</table>
<p>XORの回路記号：</p>
<p><img class="images_figure" src="kairokigou_xor.png" alt="XOR回路記号"></p>
<p>XORは暗号技術で使われている。<a href="../network/encrypt.html">暗号</a>を参照のこと。</p>
<div class="edit_date">
<p>2025.03.13</p>
</div>

<h3>スイッチング素子</h3>
<p>このような論理回路は、スイッチング素子を用いて実現できる。スイッチング素子とは、オンとオフの2つを切り替えられるような機能を持った素子。</p>
<p>ただし、いちいち人間が切り替えるのではなく、他の素子と関連して自動的に切り替わるようになっている。</p>
<p>コンピュータでよく使われるのは、MOS FETという半導体だが、歴史的にはバイポーラトランジスタ、真空管、リレーなどが用いられた。</p>
<p>新しいものほど、小型で、高速で、電力の消費量が少ない。現在は数cm<sup>2</sup>の半導体チップに100万以上の素子を乗せた集積回路が使われている。</p>

<h2>リレー</h2>
<p>（放送大学「情報学へのとびら ('16)」を参考にして執筆しました。）</p>
<p>リレーを用いた計算機では、1つの接点に蝶番で鉄片が取り付けられていて、その鉄片は電磁石の極の先に付けられている。</p>
<p>鉄片は、何もしない場合は、バネによって電磁石から遠いOut1という接点に接しているため、Out1がOnで、Out2はOffである。</p>
<p>だが、InのスイッチがOnになると、電流が電磁石に流れて鉄片を引き寄せ、Out2がOnになり、Out1がOffになる。</p>
<p><img class="images_figure" src="relay.png" alt="リレー図"></p>
<p>これを表にすると以下のようになる。Onを1、Offを0とすると、Out1はInの否定になっている。</p>
<table class="some_tables">
<tr><th>In</th><th>Out1</th><th>Out2</th></tr>
<tr><td>Off</td><td>On</td><td>Off</td></tr>
<tr><td>On</td><td>Off</td><td>On</td></tr>
</table>

<h3>リレー回路</h3>
<p>以下はリレーを用いたAND、OR、EXORのリレー回路である。</p>
<p>ANDは、二つのInどちらもOnになった時に、OutがOnになる。</p>
<p><img class="images_figure" src="relay_and.png" alt="ANDリレー図"></p>
<table class="some_tables">
<tr><th>In</th><th>In2</th><th>Out</th></tr>
<tr><td>Off</td><td>Off</td><td>Off</td></tr>
<tr><td>Off</td><td>On</td><td>Off</td></tr>
<tr><td>On</td><td>Off</td><td>Off</td></tr>
<tr><td>On</td><td>On</td><td>On</td></tr>
</table>
<p>ORは、二つのInどちらかがOnになった時に、OutがOnになる。</p>
<p><img class="images_figure" src="relay_or.png" alt="ORリレー図"></p>
<table class="some_tables">
<tr><th>In</th><th>In2</th><th>Out</th></tr>
<tr><td>Off</td><td>Off</td><td>Off</td></tr>
<tr><td>Off</td><td>On</td><td>On</td></tr>
<tr><td>On</td><td>Off</td><td>On</td></tr>
<tr><td>On</td><td>On</td><td>On</td></tr>
</table>
<p>EXORは、二つのInのどちらかがOnであればOutがOnになるが、二つのInどちらもOnであればOutがOffになる。</p>
<p><img class="images_figure" src="relay_exor.png" alt="EXORリレー図"></p>
<table class="some_tables">
<tr><th>In</th><th>In2</th><th>Out</th></tr>
<tr><td>Off</td><td>Off</td><td>Off</td></tr>
<tr><td>Off</td><td>On</td><td>On</td></tr>
<tr><td>On</td><td>Off</td><td>On</td></tr>
<tr><td>On</td><td>On</td><td>Off</td></tr>
</table>

<h3>加算器</h3>
<p>二進数での1桁+1桁の加算は、0+0, 0+1, 1+0, 1+1の4通りしかない。1+1の場合は上の桁への繰り上がりが起きるため、繰り上がりがあるかどうかを表す出力が必要となる。</p>
<p>Out1を繰り上がりがあるかどうか、Out2を加算結果（の1桁目）とすると、次のような真理値表が得られる。</p>
<table class="some_tables">
  <tr>
    <th>In1</th>
    <th>In2</th>
    <th>Out1</th>
    <th>Out2</th>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
  </tr>
</table>
<p>これを見ると、In1とIn2に対して、Out1はANDであり、Out2はEXORとなっている。</p>
<p>よって、AND回路とEXOR回路を組み合わせることで、以下のような加算器を構成できる。</p>
<p>半分のうち上がAND回路、下がEXOR回路で、In1とIn2を2つに分け、1つのスイッチで2つのリレーが動くようにしている。</p>
<p><img class="images_figure" src="han_kasanki2.png" alt="半加算器"></p>
<p>ただし、これは1桁+1桁の加算であれば問題ないが、多桁の加算の場合、下の桁からの繰り上がりを考慮していない。そのため、半加算器と呼ばれる。下からの繰り上がりを考慮に入れた場合（全加算器）の真理値表は以下のようになる。Cが下の桁からの繰り上がりがあるかどうかを示す。</p>
<table class="some_tables">
  <tr>
    <th>In1</th>
    <th>In2</th>
    <th>C</th>
    <th>Out1</th>
    <th>Out2</th>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
  </tr>
</table>
<p>これは、このように実現出来る。</p>
<p><img class="images_figure" src="zen_kasanki.png" alt="全加算器"></p>
<p>この全加算器により、多桁の加算器が構成できる。多桁の加算器は、それぞれの桁に加算器を用意することで実現できる。一番下の桁は半加算器で良い。あとはその半加算器に結合する形でそれぞれの桁の全加算器を構築すれば良い。</p>

<h3>減算</h3>
<p>減算は、2の補数を加えることで実現できる。</p>
<p>2の補数とは、たとえば0001111であれば1110001であるかのように、全ての数を反転させて、その値に1を加えた数のこと。</p>
<p>この時、一番上のビットは必ずプラス値の場合0、マイナス値の場合1となる。</p>
<p>よって、00001111の補数は11110001となる。</p>
<!--
<p>これを桁あふれを考慮せず、無視して加えることで、減算が可能となる。</p>
-->
<p>-1は0001に対して1111、-2は0010に対して1110、-3は0011に対して1101、-4は0100に対して1100となる。</p>
<p>減算の例として、000111に111001を加える場合、全ての数を反転した数に1を加える前に、その反転させた数をまず足すことを考えてみる。</p>
<p>当然、必ず全ビットが1になる（111111）。</p>
<p>これに1を加えれば、桁あふれが起きると同時に必ず全ビットが0になる（000000）。</p>
<p>この桁あふれさえ無視してしまえば、必ず結果は0となる。</p>
<p>-1よりも-2の方が符号なしの数値の上では1小さいため、差が存在する時は適切に差が残る。</p>
<p>-1よりも-2の方が小さいため、足した時に1小さな数値になる。</p>

<h3>乗算と除算</h3>
<p>乗算については、確かに3を3回繰り返して足しても実現できるのだが、人間が小学生で習う「筆算」を使って、それぞれの桁について、0をかけるときは何も加えず、1をかけるときは元の数をシフトした数を加えることで実現できる。よって、桁をシフトする機能と加算ができれば実現できる。</p>
<p>同様に除算についても、筆算を使って、減算と桁をシフトする機能があれば実現できる。割られる数から割る数を、右にシフトさせながら、引ける場合にだけ引く（実際は2の補数を加えて桁あふれが起きるかどうかで引けたかどうかを判断する）ことで実現できる。</p>

<h1>その他のリンク集</h1>
<h2>坂村健さんによる解説</h2>
<p>僕は上記のコンピュータの加算器の演算回路について、放送大学「情報学へのとびら ('16)」を参考に執筆しましたが、TRONの坂村健さんが著書の中で同じような解説をされているので、参考になさってください。</p>
<ul>
<li><a href="https://www.amazon.co.jp/%E7%97%9B%E5%BF%AB-%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E5%AD%A6-%E9%9B%86%E8%8B%B1%E7%A4%BE%E6%96%87%E5%BA%AB-%E5%9D%82%E6%9D%91-%E5%81%A5/dp/4087474283">痛快! コンピュータ学 (集英社文庫)</a></li>
</ul>

<h2>コンピュータがどのように計算しているか</h2>
<p>基本的に、論理積（AND）・論理和（OR）・論理否定（NOT）の論理回路を組み合わせることで、2進数の足し算を実現している。</p>
<p>以下のサイトがとても参考になる。</p>
<ul>
<li><a href="http://d.hatena.ne.jp/zariganitosh/20110818/how_do_cpu_calculate">コンピュータはどのように計算しているのか？ - ザリガニが見ていた...。</a></li>
</ul>

<h1>アーキテクチャ</h1>
<h2>CPU・メモリというコア装置が計算をしていて、そこに情報が入出力される</h2>
<p>コンピュータの仕組みが良く分からない人は、CPUとメモリという「コア装置」があって、そのコア装置にハードディスクなどから「情報」が入出力として送受信され、その上でマウス、キーボード、ディスプレイが「イベント」を与えると理解すると良いでしょう。</p>
<p>ここで重要なのは、コア装置よりも入出力として与えられる「情報」です。この情報の中に、全てのプログラム、全てのデータ、全ての設定内容、そして全ての読み書きされる内容が保管されているからです。</p>
<p>コア装置と情報がやりとりしながらイベントを送り合う、そんな機械がパソコンです。情報の中にプログラムがあり、そのプログラム情報の中の中核部分（カーネル）によって情報の「形態」や「形式」が決められ、それらが個別のプログラムとなって「カーネルとプログラムが協調して動作する」と理解すると良いでしょう。</p>

<h2>コンピュータは計算とメモリ</h2>
<p>コンピュータの基本は、計算とメモリです。それも、CPU自体は足し算（あるいは四則演算）しかできません。三角関数のような基本的な数学の関数でさえ、プログラミングを用いて行います。</p>
<p>また、メモリといっても、処理速度の速さから言って、CPUのレジスタ、メモリ（キャッシュメモリと主メモリ）、ハードディスクなどの大容量記録装置があります。</p>
<p>このようなパソコンですが、プログラミングでやっていることはまさに、計算とメモリです。</p>
<p>「aに3を入れろ」「bに10を入れろ」「a+bを計算してそれをcに入れろ」という、まさに電卓をやっているだけなのが、ハードウェアとしてのコンピュータです。あとは、そのaやbやcがどこにあって、どこから読み出し、どこへと転送するか、ということをやっているだけが、ストレージやネットワーク、あるいはデータベースです。</p>
<p>プログラミングとは、計算を行うための手段であると同時に、計算を何のために行うかという目的です。繰り返したり条件分岐したり、といったことは、ハードウェアを上手く活用して、抽象化されたプログラムをいかに作るのか、ということの「応用の極め」にすぎません。</p>
<p>ですが、一度作ったプログラムは何度でも使えます。変更する必要なく再利用できることが理想であるため、バージョンアップという発想は、正しいプログラムでは必要のない考え方です。ですが、プログラムを作るのもプログラマという人間の行いであり、プログラムは間違えなくても人間が間違えてしまいます。人間の間違いを後になって修正する、それがバージョンアップです。</p>

<h2>どこまでをプログラムの内部に書き、どこからを外部に出す（実行時に決める）か</h2>
<p>また、プログラムとは永遠のデータ処理のようなもので、プログラムの内部で保持される定数や変数があると同時に、外部からそうしたデータを読み込むプログラムを書くこともできます。</p>
<p>このため、「どこまでをプログラムの内部に書き、どこまでを外部に出すか」ということが重要になってきます。</p>
<p>プログラムの作成時に想定できる範囲が全てなら、それで良いでしょう。ですが、プログラムが使われるうちにデータや設定を変更し、外部に書き出して実行時に読み込むことで、あらかじめ決められているファイル形式で保存したデータを、読み込んだり書き出したりすることができます。</p>
<p>また、プログラムの外部として動的に処理するのはデータや設定ファイルだけではなく、ユーザーのフォームの入力や、どんな行動をしたかというログや、あるいは、プログラムの通信対象（たとえばサーバーに存在するWebサイトのデータなど）なども、プログラムの外部に出すべきデータとなります。</p>
<p>よって、単純に人工知能を学習するだけではなく、Webサイトの更新をチェックする「アンテナ」の更新日時や、ツイッターに自動的に文章を投稿する「ボット」などの定型文章（テンプレート）なども、プログラムのある意味でのデータと言えます。こうしたデータは、大規模で再利用可能なプログラムでは必ず必要になります。プログラムが必要とすることで、プログラムの中に書かれるものは、少ししかありません。ほとんどが、外部データを操作して読み書きするだけです。</p>

<h2>コンパイラを上手く使うこと</h2>
<p>そういうわけで、プログラム自身である「情報」をどのように組み立てるか、ということが、コンピュータを使う上で重要になってきます。</p>
<p>この時、機械語で直接プログラムを書くと、そのコンピュータのCPUでしか、プログラムが動かなくなります。この際にC言語などの「高級言語」を使うことで、UNIXがそうだったように、さまざまなアーキテクチャにプログラム（OS）を移植することができます。</p>
<p>高級言語は、そのままではCPUでは動きません。高級言語（C）をCPUの機械語（Intel x86）に翻訳するプログラム、すなわち「コンパイラ」が必要となります。</p>
<p>昔は、コンパイラは「限りあるコンピュータ資源の無駄」であると言われましたが、今ではほとんどのOSがコンパイラを使って作られています。また、OSの上でJavaのようなミドルウェアを実行することで、さらに高水準の高級言語を使うことも増えています。今では、CのプログラマよりもJavaのプログラマの方がはるかに多いです。</p>

<h2>OSとカーネル</h2>
<p>また、コンピュータのハードウェアを支配しているのは、OSと呼ばれるプログラムです。OSの中で、中核に当たる部分をカーネルと言います。</p>
<p>カーネルのやっていることは<a href="../os/os.html">OS</a>を参照していただくとして、ハードウェアから見れば、常にカーネルがマルチタスクでプログラムを実行し、そのカーネルの内部で「さまざまな内部情報」を構築して、その中にデバイスの情報やそれを処理するデバイスドライバ、あるいはFATやNTFSのハードディスクを操作するために必要なファイルシステムモジュールを読み込み、その中で「上手くハードウェアのイベントに応じてやり取りすること」で、カーネルは成り立っています。</p>
<p>プログラムの実行が要求されると、カーネルはプログラムのインスタンスである「プロセス」を生成します。プロセスの論理アドレス空間は物理アドレス空間に変換され、それぞれのプログラムが別々のアドレス空間を持つようにします。また、別のプロセスの実行が要求されると、カーネルはレジスタの内容をレジスタ外に退避して、そのプロセスを停止させ、別のプロセスを同時に実行し、スケジューラのクォンタム（プロセスを切り替える時間）と優先順位に基づいて次々にプログラムを実行させます。また、ユーザーモードとカーネルモードはカーネルの中で明確に区別され、ユーザーランドのプログラムがカーネルのメモリ空間にアクセスすることはできません。</p>



<h1>デジタルと符号</h1>
<h2>コンピュータは二進数の計算以外、何も出来ない</h2>
<p>コンピュータは、内部の数値データを全て二進数で保持している。言ってしまえば、人間がどのような計算をさせても、コンピュータの方はただ二進数を論理回路で計算しているだけである。</p>
<p>コンピュータは、二進数を計算して、CPUで用意されたレジスタやメモリへ入出力を行う以外、何も出来ない。それ以上のことは、人間が「プログラミング」しなければならない。これがコンピュータの肝である。コンピュータは、そもそもプログラミングしなければ何も出来ない。最初から、二進数以外のことはプログラミングすることを意図して、コンピュータという機械は作られているのである。</p>
<p>CPUは順に命令を実行するほか、実行の順番を制御する「ジャンプ命令」がある。これはC言語のgotoに相当する。現代的なOS（カーネル）やコンパイラは、こうした順番の制御と二進数の計算とハードウェア的なやりとりによって作られている。モニターに映る内容はウィンドウシステムが描画している。</p>
<p>オープンソースの真価とは、こうしたプログラマブルな環境をユーザーに自由に解放することにある、と言っても良いだろう。確かにWindowsの方が会社が作っていて信頼できるかもしれないが、Windowsのソースコードは非公開である。Linuxは今のところWindowsほどに優れたGUIは提供していないが、ソースコード全てがオープンなライセンスで公開されている。それは、「自分で研究し、改造し、コピーし、再配布する自由」があることを意味する。フリーソフトウェアと呼ばれるこれらの自由は、「CPUの上にある、全てのプログラム可能な環境を与える」という意味で、コンピュータ本来の自由を取り戻すということを意味しているのである。</p>
<p>Windowsのようなクローズドなソフトウェアを独占的（プロプライエタリー）なソフトウェアというのは、著作権を利用してみんなのものを独占しているからである。言ってしまえば、「ドラえもんの絵しか描けない絵の具」に近い。それしか使ったことのない人間は、自分でもっと高度なOSをハッキングする楽しみを知らないのである。金儲けを取るか、自由を取るか、それがGNUの正義なのである。</p>
<p>ただ、そんなにGNUがかっこいいかというと、そうでもない。GNUは、自分の所有するコンピュータの自由という概念を持ち出して、「Microsoftが全てのコンピュータを勝手に独占している」と言うが、私有権をもっとも否定するのはGNUである。そういうところがおかしいから、Red Hatのようにみんなを騙して儲ける企業が出てくる。そもそもが革命は悪である。それは、言っておかなければならないだろう。</p>

<h1>別ページ</h1>
<h2>量子コンピュータ</h2>
<p><a href="quantum_computer.html">量子コンピュータ</a>を参照のこと。</p>

<h2>AI技術</h2>
<p>パーセプトロンによる論理ゲートの仕組みについては、<a href="../programs/ai_python.html">PythonでAI入門</a>も参照のこと。</p>

<h1>リンク集</h1>
<h2>コンピュータ・アーキテクチャ</h2>
<p>コンピュータ・アーキテクチャについて。</p>
<p>Wikipedia</p>
<ul>
<li><a href="https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%BB%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3">コンピュータ・アーキテクチャ - Wikipedia</a></li>
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%91%E3%83%BC%E3%82%BD%E3%83%8A%E3%83%AB%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF">パーソナルコンピュータ - Wikipedia</a></li>
</ul>

<h1>簡単な説明</h1>
<h2>ハードウェア</h2>
<ul class="defaultlist list7">
<li>ハードウェア
<ul>
<li>コンピュータの計算原理（リレーとスイッチ）
<ul>
<li>論理回路（AND、OR、NAND、NOR、XOR）</li>
<li>二進数の演算（加算器）は下桁からの桁上がりを考慮した論理回路（AND, OR, NOT, XOR）によって実現できる
<ul>
<li>2進数の1ビットの計算は、0+0=0, 0+1=1, 1+0=1, 1+1=10（桁上がりを考慮しなければ0）しかない。これらは人間と同じ頭脳がなくても、機械的な論理回路（XORとAND）だけで計算できる。</li>
<li>2進数の1ビットだけの計算を行う加算器を半加算器と呼ぶ</li>
<li>実際は計算は1ビットだけではなく、「下の桁から桁上がりする数」も考慮しなければならない</li>
<li>桁上がりを考慮した加算器は2個の半加算器とORで実現でき、これを全加算器と呼ぶ</li>
</ul></li>
<li>負の数は2の補数表現によって実現できる
<ul>
<li>2の補数とは、2進数で0と1を反転させた数に1を足したもの</li>
<li>同じ数を負数にして足した時に、桁あふれを考慮しなければ、必ず0になる</li>
</ul></li>
</ul></li>
<li>真空管、トランジスタ、集積回路（IC）</li>
<li>CPUとメモリ
<ul>
<li>CISCとRISC</li>
<li>命令サイクル
<ul>
<li>オペコード、オペランド</li>
<li>アドレス計算</li>
</ul></li>
<li>レジスタ</li>
<li>パイプライン
<ul>
<li>複数の命令実行サイクルを行う際に、CPUの命令実行サイクルを1つずつずらして同時に行うことで、処理が高速化する</li>
<li>特に命令の単純なRISCで効果的</li>
</ul></li>
<li>キャッシュメモリ
<ul>
<li>遅い主メモリの代わりに、よく使うデータをキャッシュメモリに入れることで、処理を高速化できる</li>
<li>キャッシュには、ライトスルー方式（データをキャッシュメモリに書き込む際に主メモリあるいはハードディスクにも同時に書き込む・書かれ終わるまで待つ）と、ライトバック方式（キャッシュに書かれた時点で書き込み完了として次の処理にバックする）がある</li>
</ul></li>
<li>メモリ管理方式</li>
<li>LSIの製造プロセス</li>
<li>CPUアーキテクチャ
<ul>
<li>Intel x86</li>
<li>AMD x86-64</li>
<li>Intel IA-64</li>
<li>IBM POWER</li>
<li>Sun SPARC</li>
<li>DEC Alpha</li>
<li>ARM</li>
</ul></li>
<li>量子コンピュータ</li>
</ul></li>
<li>磁気テープ、磁気ディスク
<ul>
<li>磁気ヘッドと磁気テープによってデータを記録する</li>
<li>磁気ヘッドから電磁気が流れ、磁気テープに記録される</li>
<li>ハードディスクはヘッドがディスクに接していない（空中を移動する）ため高速</li>
<li>ヘッド、シリンダ、トラック、セクタ</li>
<li>FAT（ファイルアロケーションテーブル）</li>
<li>SSD</li>
</ul></li>
<li>CRTモニター</li>
<li>プリンター</li>
</ul></li>
</ul>

<!--
<h1></h1>
<h2></h2>
<ul>
<li><a href=""></a></li>
</ul>
-->





</div></div> <!--page-->










<script type="text/javascript" src="../../js/jquery.toc.js"></script>
<script type="text/javascript" src="../../js/script.js"></script>
<script type="text/javascript" src="../../js/scriptfortoc.js"></script>
</body>
</html>