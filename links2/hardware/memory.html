<!DOCTYPE html>
<html dir="ltr" lang="ja">
    <head>
        <title>メモリの世界観 - from Assy</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="keywords" content="Assy,アッシー,詩,小説,物語,歴史,政治,経済,コンピュータ,パソコン,Linux,エッセイ,散文,哲学">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="../../css/style.css">


<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">

    </head>
    <body>
<div class="page">
<script type="text/javascript" src="../../js/jquery.min.js"></script>
<script type="text/javascript" src="../../js/script_smartmenus.js"></script>
<script type="text/javascript" src="../../js/links2.js"></script>

<p><a href="index.html">ハードウェアの世界観に戻る</a></p>
<div class="sidebar">
<iframe src="../../menus/hardware_menu.html" class="sideiframe"></iframe>
</div><h1>メモリの世界観</h1>
<p>メモリの世界観です。<a href="hardware.html">ハードウェア１（半導体）</a>も参照のこと。</p>
<div id="toc"></div>
<div class="page_links">



<h1>半導体メモリ（主記憶装置）</h1>
<h2>メモリの特徴</h2>
<p>メモリは、コンピュータの中でデータを記憶するための素子のこと。</p>
<p>メモリの特徴は、</p>
<p>・メモリの中の記憶情報の格納場所（番地・住所）を指すメモリアドレスを指定して読み書きする。x86のアセンブリ言語ではmov XX [XX]を使う。</p>
<p>・CPUの計算に使われるレジスタより低速。</p>
<p>・電源を消しても内容を保持できるハードディスクなどの磁気ディスクより高速。</p>
<p>CPUとメモリは密接な関係にある。CPUのレジスタで計算した内容をメモリに記憶させ、メモリで記憶した内容をCPUのレジスタに読み込むことで、すべてのコンピュータのプログラムは動いている。</p>
<div class="edit_date">
<p>2023.05.18編集</p>
</div>

<h2>メモリとは</h2>
<p>メモリは基本的に、0と1を記録しておくデバイス。0と1の情報のことを「ビット」と言う。また、ビット1つ分の情報を「1ビット」と呼ぶ。</p>
<p>メモリは8ビットずつまとめて扱う場合が多く、8ビットのことを「1バイト」と呼ぶ。</p>
<p>メモリ操作では、このバイトごとにアドレス（値の存在する番地）がふられ、アドレスから値を見ることができる。</p>
<p>（<a href="https://www.amazon.co.jp/%E3%81%B5%E3%81%A4%E3%81%86%E3%81%AELinux%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-Linux%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B9%E3%82%8Bgcc%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E7%8E%8B%E9%81%93-%E9%9D%92%E6%9C%A8-%E5%B3%B0%E9%83%8E/dp/4797328355">ふつうのLinuxプログラミング Linuxの仕組みから学べるgccプログラミングの王道</a>を参考に執筆しました。）</p>

<h2>Intelの16ビットCPU</h2>
<p>Intelの16ビットCPUでは、レジスタを16ビットで管理する。レジスタの値は上位8ビットと下位8ビットに分けられる。AXレジスタならAHとALに分割される。</p>
<p>また、アドレスの番地を示すために「セグメント」の考え方を用いる。セグメントアドレスは具体的な値（たとえば32CEなど）に固定され、これにオフセットアドレス（たとえば0100）を加えた値になる。</p>
<p>マシン語でプログラミングを行う際、オフセットアドレスは昔のプログラミング言語でいう行番号のように使うことができ、ジャンプ命令などではオフセットアドレスを指定してジャンプできる。</p>
<p>MOV命令でオフセットアドレス[0201]にALレジスタの値を格納するにはMOV [0201], ALとすればよい。</p>
<p>この時、物理アドレスは、「セグメントアドレス + オフセットアドレス = 物理アドレス」のようになる。</p>
<p>（<a href="https://www.amazon.co.jp/%E3%81%AF%E3%81%98%E3%82%81%E3%81%A6%E8%AA%AD%E3%82%808086%E2%80%9516%E3%83%93%E3%83%83%E3%83%88%E3%83%BB%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%82%92%E3%82%84%E3%81%95%E3%81%97%E3%81%8F%E8%AA%9E%E3%82%8B-%E3%82%A2%E3%82%B9%E3%82%AD%E3%83%BC%E3%83%96%E3%83%83%E3%82%AF%E3%82%B9-%E8%92%B2%E5%9C%B0-%E8%BC%9D%E5%B0%9A/dp/4871482456">はじめて読む8086―16ビット・コンピュータをやさしく語る (アスキーブックス)</a>を参考に執筆しました。）</p>

<h2>実効アドレス計算</h2>
<p>CPUのステージのひとつである実効アドレス計算では、アドレスの指定方式（アドレッシングモード）に応じて（たとえば直接あるいは間接的にアドレスを指定したり、アドレスにレジスタの値を加えた相対位置から指定したりする）、実際のメモリアドレスを計算する。</p>
<p>アドレス修飾には、即値アドレス指定、直接アドレス指定、間接アドレス指定、相対アドレス指定、インデックスアドレス指定、ベースアドレス指定がある。</p>
<table class="some_tables">
<tr><th class="min60">指定方法</th><th>説明</th></tr>
<tr><td>即値アドレス指定</td><td>アドレス部にデータを直接指定する。</td></tr>
<tr><td>直接アドレス指定</td><td>アドレス部にデータの格納されているアドレスを指定する。</td></tr>
<tr><td>間接アドレス指定</td><td>アドレス部にアドレスを指定し、その参照した先にさらにアドレスが格納されている。<br>さらに何重にも行う場合がある。</td></tr>
<tr><td>相対アドレス指定</td><td>アドレスに命令アドレスレジスタ・プログラムカウンタの値を加える。</td></tr>
<tr><td>インデックスアドレス指定</td><td>アドレスにインデックスレジスタの値を加える。</td></tr>
<tr><td>ベースアドレス指定</td><td>アドレスにベースレジスタの値を加える。</td></tr>
</table>
<p>インデックスレジスタは、たとえば配列などの順次処理でインデックスを表すのに使用する。ベースレジスタはデータの基準となる場所を表し、ベースレジスタの値を変えることでプログラムがどこにあっても参照できる。</p>
<p>以下は参考文献。</p>
<ul>
<li><a href="https://teratail.com/questions/91456">CPU命令実行サイクルについて｜teratail</a></li>
<li><a href="https://www.amazon.co.jp/%E4%BB%A4%E5%92%8C05%E5%B9%B4-%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8%EF%BC%86%E3%82%AF%E3%83%AC%E3%83%90%E3%83%BC%E6%96%B9%E5%BC%8F%E3%81%A7%E3%82%88%E3%81%8F%E3%82%8F%E3%81%8B%E3%82%8B-%E6%A0%A2%E6%9C%A8%E5%85%88%E7%94%9F%E3%81%AE%E5%9F%BA%E6%9C%AC%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93%E8%80%85%E6%95%99%E5%AE%A4-%E6%83%85%E5%A0%B1%E5%87%A6%E7%90%86%E6%8A%80%E8%A1%93%E8%80%85%E8%A9%A6%E9%A8%93-%E6%A0%A2%E6%9C%A8/dp/4297131307">平成18年度 イメージ&クレバー方式でよくわかる栢木先生の基本情報技術者教室 (情報処理技術者試験)</a></li>
</ul>

<h2>仮想記憶</h2>
<p>（<a href="https://www.amazon.co.jp/%E8%A8%88%E7%AE%97%E6%A9%9F%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3-%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6%E5%85%A5%E9%96%80%E9%81%B8%E6%9B%B8-%E6%A9%8B%E6%9C%AC-%E6%98%AD%E6%B4%8B/dp/4785620277">計算機アーキテクチャ (情報工学入門選書)</a>を参考に執筆しました。）</p>
<p>仮想記憶とは、メモリを物理アドレスと論理アドレスに分け、論理アドレスを物理アドレスに翻訳することで、実際よりも多くのメモリ領域を利用可能とし、またほかのプログラムの使用するメモリ領域を気にすることなくプログラムを記述することができるようにする機能。</p>
<p>仮想記憶の管理はオペレーティングシステムが行う。</p>
<p>すべての仮想記憶を主メモリに置くのではなく、一部を主メモリ上に、一部をストレージディスク上に置く。</p>
<p>主メモリとディスクの入れ替えの際の単位として、ページ方式とセグメント方式がある。ページ方式では、一定のサイズ（たとえば4KB）ごとに分割する。これに対してセグメント方式は、意味のある論理的なまとまり（セグメント）に分割する。</p>

<h1>メモリの種類</h1>
<h2>RAMとROM</h2>
<p>RAMはデータの読み書きが出来るメモリ。反対に読み込みしかできないメモリをROMという。</p>
<p>後日注記：ランダムアクセスとは、「必要な時に必要な場所にアクセスできる」という意味で、初期のメインフレームなどに多かったシーケンシャルアクセス（一件目から順番にしかアクセスできない、たとえばテープなど）の対義語だが、電源を落としてもデータが消えないROM（あらかじめ記録された情報を読み出しするだけが可能）に対して、RAMは電源を落とせばデータが消えてしまうという意味で使われることも多い。</p>
<p>後日注記：昔のBASICマシンなどでは、小型のBASICインタプリタをROMで搭載し、最初から変わらずに読み込まれるようにしていた。それによってBASICプログラムを記述して実行することができた。ROMはこのように、変わらずに同じものを読み込むような、最初から搭載されているプログラムのために使われることが多い。</p>
<p>Wikipedia</p>
<ul>
<li><a href="https://ja.wikipedia.org/wiki/%E4%B8%BB%E8%A8%98%E6%86%B6%E8%A3%85%E7%BD%AE">主記憶装置 - Wikipedia</a></li>
<li><a href="https://ja.wikipedia.org/wiki/Random_Access_Memory">Random Access Memory - Wikipedia</a></li>
</ul>
<h2>DRAM（主メモリ）</h2>
<p>主記憶装置に用いられる。安価で容量が大きい一方、SRAMと比較すると低速。</p>
<p>後日注記：DRAMは記憶素子の回路が単純であるため集積することが容易である。なので大容量にすることができる。</p>
<p>（放送大学「コンピュータの動作と管理 ('17)」を参考に執筆しました。）</p>
<p>Wikipedia</p>
<ul>
<li><a href="https://ja.wikipedia.org/wiki/Dynamic_Random_Access_Memory">Dynamic Random Access Memory - Wikipedia</a></li>
</ul>
<div class="edit_date">
<p>2023.05.18編集</p>
</div>

<h2>SRAM（キャッシュメモリ）</h2>
<p>キャッシュメモリに用いられる。主メモリよりもさらに高速。</p>
<p>キャッシュメモリは低容量で高価格だがスピードが高速なため、一度アクセスしたデータに何度も繰り返し頻繁にアクセスするための「キャッシュ」として用いられる。</p>
<p>後日注記：SRAMはレジスタと同じくD型フリップフロップで構成されており、高速だが、1ビットに4つのトランジスタが必要なため集積が難しいという特徴がある。</p>
<p>（放送大学「コンピュータの動作と管理 ('17)」を参考に執筆しました。）</p>
<p>Wikipedia</p>
<ul>
<li><a href="https://ja.wikipedia.org/wiki/Static_Random_Access_Memory">Static Random Access Memory - Wikipedia</a></li>
</ul>
<div class="edit_date">
<p>2023.05.18編集</p>
</div>

<h2>EEPROMとフラッシュメモリ</h2>
<p>EEPROMは、ROMでありながら高い電圧をかけることで内容を削除し、再び書き込みが可能なメモリ。</p>
<p>EEPROMの一種として構造を簡素化することで高速に書き込みできるフラッシュメモリ（NOR型・NAND型の二種類）があり、USBメモリーやSSDなどに使われている。</p>
<p>（放送大学「コンピュータの動作と管理 ('17)」を参考に執筆しました。）</p>
<div class="edit_date">
<p>2023.05.18</p>
</div>

<h2>揮発性と不揮発性</h2>
<p>メモリの注意点として、電気を消すと記憶した内容が消えてしまう。これを揮発性メモリと呼ぶ。</p>
<p>そのため、電源を消しても保持したいデータは不揮発性のハードディスクなどに保存しなければならない。</p>
<p>（放送大学「コンピュータとソフトウェア ('18)」を参考に執筆しました。）</p>
<div class="edit_date">
<p>2023.03.31</p>
</div>

<h1>キャッシュメモリ</h1>
<p>（<a href="https://www.amazon.co.jp/dp/4295002666/">徹底攻略 応用情報技術者教科書 平成30年度</a>を参考に執筆しました。）</p>

<h2>キャッシュメモリ</h2>
<p>頻繁に読み書きされるデータをキャッシュして効率的にアクセスするために、キャッシュ専用の高速なメモリをCPUと主メモリとの間に配置する方式のことを、キャッシュメモリと呼ぶ。</p>
<ul>
<li><a href="https://ja.wikipedia.org/wiki/%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E3%83%A1%E3%83%A2%E3%83%AA">キャッシュメモリ - Wikipedia</a></li>
<li><a href="https://www.amazon.co.jp/%E8%A8%88%E7%AE%97%E6%A9%9F%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3-%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6%E5%85%A5%E9%96%80%E9%81%B8%E6%9B%B8-%E6%A9%8B%E6%9C%AC-%E6%98%AD%E6%B4%8B/dp/4785620277">計算機アーキテクチャ (情報工学入門選書)</a></li>
</ul>

<h2>キャッシュメモリの方式</h2>
<p>キャッシュメモリのデータ更新方式には、ライトスルー方式とライトバック方式がある。ライトスルーでは、キャッシュメモリにデータを書き込んだ時点で、同じデータを主メモリにも書き込む。これに対してライトバックでは、すぐに主メモリに書き込まず、後々になって条件が満たされた場合にのみ書き込む。ライトバックのほうがスループレット（処理速度）は向上するが、必ずしもコヒーレンシ（一貫性）は保たれない。</p>
<p>キャッシュメモリの割り当てには、最初に発見した空き領域に配置するファーストヒット方式と、見つかったもののうちベストフィット（そのサイズを満たす最小サイズの領域、すなわち、ちょうどいい大きさの領域）のものを選ぶベストフィット方式がある。</p>
<p>（<a href="https://www.amazon.co.jp/dp/4295002666/">徹底攻略 応用情報技術者教科書 平成30年度</a>を参考に執筆しました。）</p>

<h2>メモリインタリーブ</h2>
<p>メモリインタリーブは、メモリをメモリバンクと呼ばれる複数のメモリ領域に分割し、それぞれの別のメモリバンクに同時にアクセスできるようにする（ことで効率的にアクセスができる）方式。</p>
<p>（<a href="https://www.amazon.co.jp/dp/4295002666/">徹底攻略 応用情報技術者教科書 平成30年度</a>を参考に執筆しました。）</p>

<h2>キャッシュ</h2>
<p>キャッシュとは、頻繁にアクセスされるデータを高速な記憶装置に複製することで、高速にアクセスできるようにする機構のこと。</p>
<p>よく使うデータをキャッシュに置き、素早く利用するために使う。</p>
<p>データがハードディスク上にあるよりも、メモリ上にあった方が圧倒的に速いため、よく使うデータをメモリ上に置き、そこからアクセスし、必要になった段階でハードディスクに読み書きするようなキャッシュの実装が考えられる。</p>
<p>（やねうらお氏の「<a href="https://www.amazon.co.jp/Windows%E3%83%97%E3%83%AD%E3%83%95%E3%82%A7%E3%83%83%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%82%B2%E3%83%BC%E3%83%A0%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-%E3%82%84%E3%81%AD-%E3%81%86%E3%82%89%E3%81%8A/dp/479800314X">Windowsプロフェッショナルゲームプログラミング</a>」を参考に執筆しました。）</p>

<h2>さまざまなキャッシュ</h2>
<p>キャッシュは記憶装置だけではなく、ネットワーク通信においても使われる。</p>
<p>Webブラウザが、一度表示したことのある、更新されていないページを再度表示する際に、URLからページをダウンロードせずローカルにあるキャッシュを表示することで、ネットワーク通信をしなくても即座にページが表示される。</p>
<p>もし更新されていた場合は、更新ボタンを押せばURLから再度ダウンロードされる。</p>
<p>このように、メモリやハードディスクあるいはWebブラウザだけではなく、さまざまなところでキャッシュ技術は使われている。</p>
<div class="edit_date">
<p>2023.04.03</p>
</div>

<h1>余談</h1>
<h2>逐次的な処理の中で、データをメモリに保持するということ</h2>
<p>僕は、プログラミングには二つの大きな点があると思います。それは、「逐次的な処理」と、その中で「データをメモリに保持する」ということです。</p>
<p>プログラムというのは、演算子や入出力関数やサブルーチンやジャンプを行う中で逐次的な処理を行いながら、その中でデータを保持し、さまざまなデータをその逐次的な処理と処理の間でやり取りする、ということです。</p>
<p>基本的に、「流れるフロー」がもしあったとしたら、それはフローだけではなく、その中でやり取りされるデータと一緒に成り立ちます。どこかにデータを記憶することができなければ、フローの中で逐次的な処理と処理が、結果をやり取りすることができません。</p>
<p>なので、CPUとメモリは切り離すことができない不可分の存在です。CPUで逐次的な処理を行い、メモリでデータをやり取りするのです。</p>

<h2>バッファと省メモリ化の実現</h2>
<p>使用するメモリ領域の大きさの削減をするために、小さなバッファを使った省メモリの技術が考えられる。</p>
<p>たくさんのデータを扱うプログラムで、すべてのデータを一度にメモリ領域に確保するのではなく、特別なバッファ領域を小さく確保し、データが必要になった時点でそのバッファの中のデータを書き換えることで、全体の使用するメモリ領域を削減できる。</p>
<p>たとえば、全部で1000のデータがあった時、この1000のデータを一度に確保すると、メモリ領域は1000必要になってしまう。</p>
<p>そうではなく、50の小さく特別なデータ領域をバッファとして確保し、必要になったタイミングで、1000のデータの中の必要な部分だけを、50のバッファの中に格納し、別の領域が必要になれば、50のバッファの領域を書き換えることで、全部で50のメモリ領域だけであっても1000の全部のデータを処理することができる。</p>
<p>たとえば、ファイルを読み出す場合、すべてのファイルを一気にメモリに読み込むのではなく、4096バイトの固定長のバッファ領域を使って、4096バイトごとに読み出して処理することが考えられる。どんなにファイルのサイズが大きくても、使用するメモリ領域は4096バイトだけで済む。</p>
<p>応用例としては、Apacheのようなプロセス・スレッドベースのWebサーバに対して、イベント駆動で必要な接続に必要な時にアクセスするNginxのようなWebサーバが挙げられる。一度に全部のスレッドの分だけメモリを確保するのではなく、必要な接続に対して必要なだけのメモリをその都度確保するため、Nginxはメモリの効率がよく、軽量かつ高速であることが知られている。</p>
<p><a href="../linux/linux_api_stdio.html">Linux API（stdio）</a>や<a href="../network/nginx.html">Nginx</a>も参照のこと。</p>
<div class="edit_date">
<p>2023.08.19</p>
</div>

<h1>関連ページ</h1>
<h2>Linuxカーネルのメモリ管理</h2>
<p>Linuxカーネルのメモリ管理（仮想記憶）については、<a href="../linux/linux_kernel_mm.html">Linuxカーネル（メモリ管理）</a>を参照のこと。</p>

<h2>x86アセンブラ</h2>
<p>x86アセンブラについては、<a href="../prog_lang/assembly.html">アセンブリ言語</a>を参照のこと。</p>

<h2>Intel CPU</h2>
<p>Intel CPUについては、<a href="intel.html">Intel</a>を参照のこと。</p>

<h1>リンク集</h1>
<h2>書籍</h2>
<p>メモリについての基本は、以下のような書籍が参考になります。</p>
<ul>
<li><a href="https://www.amazon.co.jp/%E3%81%B5%E3%81%A4%E3%81%86%E3%81%AELinux%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-Linux%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B9%E3%82%8Bgcc%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E7%8E%8B%E9%81%93-%E9%9D%92%E6%9C%A8-%E5%B3%B0%E9%83%8E/dp/4797328355">ふつうのLinuxプログラミング Linuxの仕組みから学べるgccプログラミングの王道</a></li>
<li><a href="https://www.amazon.co.jp/dp/4295002666/">徹底攻略 応用情報技術者教科書 平成30年度</a></li>
</ul>





<!--
<h1></h1>
<h2></h2>
<ul>
<li><a href=""></a></li>
</ul>
-->





</div></div> <!--page-->










<script type="text/javascript" src="../../js/jquery.toc.js"></script>
<script type="text/javascript" src="../../js/script.js"></script>
<script type="text/javascript" src="../../js/scriptfortoc.js"></script>
</body>
</html>