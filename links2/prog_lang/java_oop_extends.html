<!DOCTYPE html>
<html dir="ltr" lang="ja">
    <head>
        <title>Java関連の世界観２A（継承） - from Assy</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="keywords" content="Assy,アッシー,詩,小説,物語,歴史,政治,経済,コンピュータ,パソコン,Linux,エッセイ,散文,哲学">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="../../css/style.css">
        <link rel="stylesheet" href="../../css/prettify.css" type="text/css">


<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">

    </head>
    <body>
<div class="page">
<script type="text/javascript" src="../../js/jquery.min.js"></script>
<script type="text/javascript" src="../../js/script_smartmenus.js"></script>
<script type="text/javascript" src="../../js/links2.js"></script>

<p><a href="index.html">プログラミング言語の世界観に戻る</a></p>
<div class="sidebar">
<iframe src="../../menus/prog_lang_java_menu.html" class="sideiframe"></iframe>
</div>
<h1>Javaの世界観２A（継承）</h1>
<p>Javaによるプログラミングに関する世界観２A（継承）です。<a href="oop.html">オブジェクト指向</a>も参照のこと。</p>

<h2>関連ページ</h2>
<ul class="defaultlist list6 menu_list">
<li><a href="java.html">Java（１．文法）</a></li>
<li><a href="java_oop.html">２．オブジェクト指向</a></li>
<ul>
<li><b>２A．継承</b></li>
<li><a href="java_oop_interface.html">２B．インターフェース</a></li>
<li><a href="java_gc.html">２C．ガーベッジコレクションと例外</a></li>
</ul>
<li><a href="java_lib.html">３．クラスライブラリ</a></li>
<ul>
<li><a href="java_lib_io.html">３A．入出力</a></li>
<li><a href="java_lib_list.html">３B．コレクションと配列</a></li>
<li><a href="java_lib_string.html">３C．文字列</a></li>
<li><a href="java_lib_thread.html">３D．マルチスレッド</a></li>
<li><a href="java_lib_xml.html">３E．XML</a></li>
<li><a href="java_lib_image.html">３F．画像処理</a></li>
<li><a href="java_lib_net.html">３G．ネットワーク・データベース</a></li>
</ul>
</ul>
<p><a href="design_pattern.html">デザインパターン</a>も参照のこと。</p>

<div id="toc"></div>
<div class="page_links">

<h1>継承</h1>
<h2>犬と猫は違うけど、どちらも動物としての機能を持っている</h2>
<p>継承がなぜ必要なのかを理解するためには、動物のたとえ話をするのがいいでしょう。</p>
<p>たとえば、黒猫と白猫は、同じ猫です。同じ猫のいくらか属性を変えただけで成り立ちます。</p>
<p>黒猫がキャットフードを食べるように、白猫もキャットフードを食べます。</p>
<p>ですが、犬はどうでしょうか。猫と犬はいくらか違います。たとえば、猫はあまり吠えませんが、犬はよく吠えるでしょう。</p>
<p>このような時に、猫に与える適切な機能と犬に与える適切な機能は違います。</p>
<p>このような時、犬と猫は「クラスが違う」と言います。そして、犬を表すDogクラスと、猫を表すCatクラスを作ります。</p>
<p>ですが、犬と猫には共通点もあります。たとえば、ドッグフードかキャットフードかは違うでしょうが、どちらも似たようなものを食べます。</p>
<p>このような時、CatクラスとDogクラスに、共通の「基底クラス」を作ります。たとえば、Animalクラスとなります。</p>
<p>そして、食べる機能はAnimalクラスで実装し、Catクラス、Dogクラス、あるいはPigクラスやBirdクラスであったにせよ、このAnimalクラスを継承した「派生クラス」とします。</p>
<p>こうすることで、Animalクラスで定義した機能は、すべての派生クラスで共通の機能となります。</p>
<p>ですが、待ってください。Animalクラスで「食べる」という機能を作りましたが、それぞれの派生クラスでは食べるものが違います。たとえば、猫はキャットフードや魚を好みますが、犬はドッグフードやビーフジャーキーを好みます。</p>
<p>ですが、すべてのAnimal派生クラスにおいて、この機能の基本は変えたくありません。どの派生クラスでも、「食べる」という共通の名前のインターフェースから、猫や犬に「食べさせることができる」ようにしたいのです。</p>
<p>このような時に、オーバーライドと仮想関数の機能を使います。すなわち、Animalクラスでは、「食べる」という機能の基本的な枠組みと基本ロジックだけを記述しておいて、派生クラスでその具体的な詳細を決められるようにします。</p>
<p>オブジェクト指向において、パラメータは「属性」、機能は「メソッド」と呼ばれます。ここで、属性には「猫の種類」あるいは「犬の種類」といった、どんな値であってもクラス全体の機能には影響を大きく及ぼさないものを設定し、メソッドには「食べる」という機能をつけます。そして、基底クラスの食べるという機能を派生クラスで「上書き」します。機能の上書きのことを「オーバーライド」と呼びます。そして、上書きされたそれぞれの派生クラスの機能を、統一したインターフェースで実行できるようにします。これを「仮想関数」あるいは「ポリモーフィズム」と言います。</p>
<p>このようにすることで、たとえば、ユーロであっても円であってもドルであっても人民元であっても、どんな貨幣であっても成り立つ「貨幣計算ロジック」を記述し、それぞれの貨幣ごとに別々の処理が必要なら、「一般貨幣クラス」を継承した派生クラスを、ユーロや円やドルや人民元ごとに定義し、そのそれぞれの機能を共通のインターフェース（たとえば「買う」あるいは「売る」など）で扱うことができるのです。</p>

<h2>もうひとつ、機能の追加という大きな目的がある</h2>
<p>ここで記述した動物のたとえ話は、抽象性と具体性の話です。どのようなクラスを抽象的な機能を持つ基底クラスとし、どのような派生クラスでその機能を実装するかという「実装の話」です。</p>
<p>ですが、継承にはもうひとつ大きな機能があります。これは「機能」の追加の話です。</p>
<p>たとえば、ファイルを扱っている時に、そのファイルがローカルではなくネットワーク上にあるものも扱いたいとしたらどうでしょうか。</p>
<p>このような場合、基本の「ファイルクラス」があったとしたら、そのファイルクラスにネットワーク通信のコードを付け足して、「ネットワークファイルクラス」にすることで機能を追加することができます。</p>
<p>あるいは、クイズのプログラムがあったとして、このプログラムは時間待ち機能を持っていないため、どれだけ待っても問題が回答できるとします。このクラスに、時間待ち機能を追加するような場合も、「クイズクラス」に対して「時間制限ありクイズクラス」にすることで実現できます。</p>
<p>このように、継承には「階層的な抽象関数と実装」だけではなく、「新しい機能の追加をする」という意味もあることを忘れないようにしてください。</p>

<h2>グローバル変数を使う時の問題点である、機能を再利用した上での追加や書き換えがしづらいという性質が、継承によって解決できる</h2>
<p>そもそも、オブジェクト指向において継承を行う意味とはなんでしょうか。</p>
<p>オブジェクト指向を使わず、グローバル変数を使ってプログラムを書く際に、問題となるのは「名前空間の汚染」だけではなく、「プログラムを再利用した上での機能の追加」です。</p>
<p>たとえば、グローバル変数を用いて、スタックやキューのプログラムを書く場合、そのスタックやキューのプログラムは、データの保持のためにグローバル変数を使います。</p>
<p>この場合、たとえばスタックであれば、プッシュやポップのような関数をインターフェースとして提供するでしょう。</p>
<p>ですが、この既に存在するスタックプログラムに、さらにキューの機能を付け足すためにはどうすればいいでしょうか。</p>
<p>単純に、エンキューやデキューの機能を付け足したいならば、既にあるスタックプログラムのソースコードを書き換えれば、確かにそれは可能です。</p>
<p>ですが、このような場合、既に存在するスタックの処理を壊すことがないように、とても慎重にプログラムを書き換えなければいけません。</p>
<p>また、プログラムは元のプログラムが書き換えられるたびに更新しなければなりません。スタックのプログラムが変わってしまえば、インターフェースがもし維持されたとしても、再度キューのプログラムを慎重に追加しなければなりません。</p>
<p>グローバル変数を用いてその変数専用の関数を書くプログラムは、名前空間を汚染するだけではなく、機能を再利用して追加するとかいったことが難しいのです。</p>
<p>Javaのオブジェクト指向を用いた継承を使うことで、この問題は解決します。publicで定義されたスタッククラスをextendsでスタック＆キュークラスとして継承することで、スタックだけを実装したクラスに、キューの機能を付け足すことができます。</p>
<p>もちろん、スタックにキューの機能を追加したとして、効率性の問題をどうするのかという問題はありますが、ここでは効率性は考えません。スタックのデータを継承することで、キューの機能を追加することができます。</p>
<p>グローバル変数を用いたプログラムは、「既に存在するプログラムに対する機能の追加」が難しく、また必ずしも安全であるとは限りません。オブジェクト指向の継承の機能を使うことで、機能を容易かつ安全に追加できます。</p>

<h1>Javaにおける継承</h1>
<h2>拡張クラス</h2>
<p>クラスを継承した新しいクラスを作ることができる。オブジェクト指向の真骨頂。</p>
<table class="some_tables">
<tr><th class="min60">キーワード</th><th>説明</th></tr>
<tr><td>extends</td><td>拡張クラスの宣言をする。</td></tr>
</table>
<!--
<pre class="prettyprint">
public class MyThread extends Thread {
  ...
}
</pre>
-->

<p>継承の例：</p>
<pre class="prettyprint">
public class Cat {
    public void mew() {
        System.out.println("にゃーご");
    }
}

public class ExCat extends Cat {
    @Override
    public void mew() {
        System.out.println("ごろごろにゃーん");
    }
    
    public void printloop(int c) {
        for (int i = 0; i &lt; c; i++) {
            mew();
        }
    }
}
</pre>
<p>継承は、既にある財産であるクラスを引き継ぐために行う。</p>

<h2>綺麗な設計をしたコードは、極力既存のコードを変更する必要性がない</h2>
<p>継承について言えることとして、「綺麗な設計をしたコードは、極力元のコードを変更する必要がない」ということが言えます。</p>
<p>たとえば、関数やメソッドを編集する必要がある時、その関数だけではなく別の関数を巻き込んで変更したり、関数の呼び出し元が変更しなければならなくなったり、ということが極力ないべきです。</p>
<p>クラス設計も同じで、極力元のクラスや呼び出し元を変更することなく、必要な部分の最低限の変更で済むようにすべきです。</p>
<p>これはデザインパターンとしても言え、綺麗なデザインパターンを採用することで、極力最低限の変更で済むようにできます。マルチスレッドなどの場合でも、デザインパターンを参考に設計できます。Ruby on Railsでも「くり返しは極力なくする」といった考え方が提唱されています。</p>
<p>後日注記：また、何度も繰り返し同じものを作るよりも、既にある「きちんと動くもの」をベースに作った方が、コードも動きやすく、プログラムの信頼性も高くなる。関数をただ呼び出すだけではなく、「プログラムコードの抜本的な継承」という考え方を、継承によって行うことができる。</p>

<h2>スーパークラスとサブクラス</h2>
<p>継承によって新しい機能をクラスに追加することができる。インスタンス作成時に、オブジェクトのクラスを継承後のものに選ぶことが可能。</p>
<p>継承を使うと、スーパークラスにあるメソッドを新しい名前で上書きあるいは追加することが出来る。</p>
<p>ある意味、クラスの継承はファイルシステムにおけるパスとファイルの関係と良く似ている。</p>
<p>Javaは、ある意味、こうしたエレガントな継承をしたいがために作られた言語だと言っても過言ではない。</p>
<p>スーパークラスを指定せずにクラスを宣言すると、自動的にObjectクラスのサブクラスとして宣言される。</p>
<p>フィールドとメソッドは継承されるが、コンストラクタは継承されないため、注意が必要。</p>
<p>以下は継承の例：</p>
<ul>
<li><a href="https://www.javadrive.jp/start/extends/index2.html">JavaDrive - クラスの継承 - スーパークラスのメンバへのアクセス</a></li>
</ul>

<h2>オーバーライドと制限（finalとprivate）</h2>
<p>オーバーライドすることで、メソッドを「上書き」することができる。同じメソッド名でオーバーライドしたメソッドを実行することを、「ポリモーフィズム」と呼ぶ。</p>
<ul>
<li><a href="https://www.javadrive.jp/start/extends/index5.html">JavaDrive - メソッドのオーバーライド</a></li>
</ul>
<p>finalが付いているメソッド（finalメソッド）はオーバーライドできない。</p>
<p>また、スーパークラスにprivateが付いているメソッドやフィールドは、サブクラスからはアクセスできない（継承されない）。</p>
<p>実装を隠蔽したい場合に、フィールドを（publicから）privateにすることがある。</p>

<h2>アノテーションと@Overrideキーワード</h2>
<p>Javaでは、クラスやメソッド定義の上にアノテーションと呼ばれる注釈をつけることで、さまざまな機能を利用できる。これらは「@」を行頭につける。</p>
<p>最近のJavaでは、@Overrideキーワードを使って、オーバーライドするメソッドを明確に記述することができる。@Overrideを書くことで、間違ってメソッド名を書き間違えた場合など、正しくオーバーライドされていない時にエラーを出してくれる。間違いが発覚せずにそのままコンパイルが通って動いてしまうのを水際で防ぐことができる。</p>
<ul>
<li><a href="http://www.javaroad.jp/java_class8.htm">Javaの道：クラス（９．オーバーライドとオーバーロード）</a></li>
</ul>
<p>アノテーションはもともとJavaでコメントとして注釈をつけるために使われていたもの。自分のアノテーションを自分で作りたいなら以下の記事が参考になる。</p>
<ul>
<li><a href="https://www.sejuku.net/blog/22694">【Java入門】アノテーションの使い方と作成する方法 | 侍エンジニアブログ</a></li>
<li><a href="https://works.forward-soft.co.jp/blog/detail/10179">【Java】独自アノテーションの定義・カスタマイズの方法 - ワークス（Works）</a></li>
<li><a href="https://qiita.com/tkj06/items/a9fe1881dc965893a5f4">いまさらJavaのアノテーションを復習する - Qiita</a></li>
</ul>

<h2>super</h2>
<p>クラスを継承した時、派生クラスのコンストラクタから、スーパークラスのコンストラクタを呼び出したい時がある。</p>
<p>また、オーバーライドしたメソッドから、スーパークラスのオーバーライドしていないメソッドを実行したり、同名のメンバ変数を参照したりしたいこともある。</p>
<p>このような時に、super()を使うことで、スーパークラスのコンストラクタ・メソッド・変数にアクセスできる。</p>
<p>特に、クラスを継承した場合、必要な場所にsuper()を記述することを忘れないようにしよう。</p>
<p>また、自分のクラスのコンストラクタを呼び出したい時はthis()を使えばよい。</p>
<ul>
<li><a href="https://www.sejuku.net/blog/20081">【Java】superとは？意味や使い方について詳しく解説 | 侍エンジニアブログ</a></li>
</ul>

<h2>コンストラクタの継承</h2>
<p>Javaでは、クラスを継承しても、コンストラクタは継承されません。</p>
<p>クラスを継承した場合、サブクラスのコンストラクタにはスーパークラスのコンストラクタ（ただし引数なし）が自動的に最初に挿入されます。</p>
<p>ですが、引数付きのコンストラクタを呼び出したい時は、super(x, y)などを明示的に記述する必要があります。</p>
<p>（詳細は<a href="https://www.amazon.co.jp/Java%E8%A8%80%E8%AA%9E%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%AC%E3%83%83%E3%82%B9%E3%83%B3-%E7%AC%AC3%E7%89%88-%E4%B8%8B-%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%82%92%E5%A7%8B%E3%82%81%E3%82%88%E3%81%86-%E7%B5%90%E5%9F%8E/dp/4797371269">Java言語プログラミングレッスン 第3版(下) オブジェクト指向を始めよう</a>を参照してください。）</p>
<div class="edit_date">
<p>2023.01.06編集</p>
</div>

<h2>ポリモーフィズム</h2>
<p>ある親クラスを継承した派生クラスがあった時、派生クラスのインスタンスを親クラスの変数に格納することができる。</p>
<p>この時、オーバーライドされたメソッドを実行すると、派生クラスのメソッドが呼び出される。</p>
<p>たとえば、Catを継承したExCatクラスがあった時、</p>
<pre class="prettyprint">
Cat kuro = new ExCat();
</pre>
<p>とできる。ここで</p>
<pre class="prettyprint">
kuro.mew();
</pre>
<p>とした時、mew()メソッドがExCatでオーバーライドされていたら、ExCatのmew()メソッドが実行される。これを「ポリモーフィズム」と言い、継承やインターフェースの実装をこのように操作することができる。</p>
<p>このように、Javaでは「インターフェースはそのままで、機能だけを変更する」といったことができる。たとえば、ゲームのキャラクタークラスを作っておいて、勇者と魔法使いを別々の派生クラスにする、といった応用ができる。</p>
<p>（詳しくは<a href="https://www.amazon.co.jp/Java%E8%A8%80%E8%AA%9E%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%AC%E3%83%83%E3%82%B9%E3%83%B3-%E7%AC%AC3%E7%89%88-%E4%B8%8B-%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%82%92%E5%A7%8B%E3%82%81%E3%82%88%E3%81%86-%E7%B5%90%E5%9F%8E/dp/4797371269">Java言語プログラミングレッスン 第3版(下) オブジェクト指向を始めよう</a>が参考になります。）</p>

<h2>抽象クラス</h2>
<p>メソッドの内容が定義されておらず、インターフェースとなるAPIの呼び出し規約だけが定義されたメソッドのことを抽象メソッドと呼ぶ。</p>
<p>抽象メソッドを含んだクラスを抽象クラスと呼ぶ。</p>
<pre class="prettyprint">
public abstract class TwoHundred {
    public abstract void func(int index);
    public void loop() {
        for (int i = 0; i &lt; 200; i++) {
            func(i);
        }
    }
}
</pre>
<p>この例では、メソッドを使う側を先に作っておいて、あとでメソッドの側を継承を使って作る、といったやり方が出来るかもしれない。</p>
<p>後日注記：抽象クラスは、ある意味仮想関数やポリモーフィズムのある種の異なる形態のようなもので、親クラスでメソッドを呼び出すコードを書いておいて、派生クラスでそのメソッド本体を実装する。C言語で言えば関数ポインタのようなものに近い。同じJavaの機能であるインターフェース（APIだけを定義して、インターフェースを実装したクラスを共通のAPIを持った型として利用する）と役割的には重なるところがある。</p>
<p>（以上は<a href="https://www.amazon.co.jp/Java%E8%A8%80%E8%AA%9E%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%AC%E3%83%83%E3%82%B9%E3%83%B3-%E7%AC%AC3%E7%89%88-%E4%B8%8B-%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%82%92%E5%A7%8B%E3%82%81%E3%82%88%E3%81%86-%E7%B5%90%E5%9F%8E/dp/4797371269">Java言語プログラミングレッスン 第3版(下) オブジェクト指向を始めよう</a>を参考に執筆しました。）</p>

<h2>is-a関係とhas-a関係</h2>
<p>自分の書いたブログ「神々とともに生きる詩人」<a href="../../diary/blog_frey/2021.01.21.html">2021/01/21</a>より。</p>
<p>継承の用語について。</p>
<p>スーパークラスに対するサブクラスのように、継承して派生クラスを作る関係を、is-a関係と呼ぶ。</p>
<p>is-a関係では、親クラスのメソッドを派生クラスが呼び出せる。</p>
<p>これに対して、クラスのメンバ変数として、インスタンスをクラス内に包有する関係を、合成あるいはhas-a関係と呼ぶ。</p>
<p>has-a関係では、メンバ変数のインスタンスを通じて、そのオブジェクトのメソッドや機能を呼び出せる。</p>
<p>（詳しくは<a href="https://www.amazon.co.jp/Java%E8%A8%80%E8%AA%9E%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%AC%E3%83%83%E3%82%B9%E3%83%B3-%E7%AC%AC3%E7%89%88-%E4%B8%8B-%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%82%92%E5%A7%8B%E3%82%81%E3%82%88%E3%81%86-%E7%B5%90%E5%9F%8E/dp/4797371269">Java言語プログラミングレッスン 第3版(下) オブジェクト指向を始めよう</a>が参考になります。）</p>

<h2>継承と包有のどちらを使うべきか</h2>
<p>ネットでは、クラスの継承よりも包有あるいはインターフェースを用いた方が良いという意見もあるようです。理由は、「柔軟性が低く変更が難しいから」であるとのこと。</p>
<ul>
<li><a href="https://qiita.com/alt_yamamoto/items/25eda376e6b947208996">良いコードの書き方 - Qiita</a></li>
</ul>
<p>ただし、あえて僕の意見を言えば、同じことができるならどちらでも良いと思います。継承には、仮想関数やポリモーフィズムの仕組みが使えるというメリットもあります。</p>
<p>後日注記：包有は「合成」と呼ばれることもあります。合成とはクラスから別のクラスへの参照を持つことです。一般的に、合成が使える際には、合成を使ったほうが再利用性から言って望ましいです。</p>
<ul>
<li><a href="https://www.amazon.co.jp/Scala%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%A9%E3%83%96%E3%83%AB%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E7%AC%AC3%E7%89%88-Martin-Odersky/dp/4844381490/">Scalaスケーラブルプログラミング第3版</a></li>
</ul>
<div class="edit_date">
<p>2025.06.10編集</p>
</div>

<h2>Object型</h2>
<p>Javaのクラスライブラリでは、すべてのクラスがObjectクラスを継承して実現されている。そのため、すべての型をObject型として扱うことができる。</p>
<p>後日注記：スーパークラスを指定せずにクラスを宣言すると、自動的にObjectクラスをスーパークラスとして継承したサブクラスとしてそのクラスが宣言される。</p>
<p>また、toString()などのObjectクラスで定義されているメソッドはすべてのクラスで使用できる。toString()は文字列型としてそのオブジェクトを扱う時に呼び出されるメソッド。</p>
<p>toString()を自分でオーバーライドして、オブジェクトを文字列型に変換する際の処理を自分で書くこともできる。</p>
<p>たとえばSystem.out.println()などに自分のクラスのオブジェクトを渡すような場合、そのオブジェクトは自動的に文字列型として扱われるため、自動的にtoString()メソッドが実行されるので、具体的な処理はtoString()メソッドをオーバーライドして記述すればよい。</p>
<p>（詳細は<a href="https://www.amazon.co.jp/Java%E8%A8%80%E8%AA%9E%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%AC%E3%83%83%E3%82%B9%E3%83%B3-%E7%AC%AC3%E7%89%88-%E4%B8%8B-%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%82%92%E5%A7%8B%E3%82%81%E3%82%88%E3%81%86-%E7%B5%90%E5%9F%8E/dp/4797371269">Java言語プログラミングレッスン 第3版(下) オブジェクト指向を始めよう</a>を参照してください。）</p>

<h2>参考文献</h2>
<p>詳しくは以下の書籍が参考になります。</p>
<ul>
<li><a href="https://www.amazon.co.jp/Java%E8%A8%80%E8%AA%9E%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%AC%E3%83%83%E3%82%B9%E3%83%B3-%E7%AC%AC3%E7%89%88-%E4%B8%8A-Java%E8%A8%80%E8%AA%9E%E3%82%92%E5%A7%8B%E3%82%81%E3%82%88%E3%81%86-%E7%B5%90%E5%9F%8E/dp/4797371250">Java言語プログラミングレッスン 第3版(上) Java言語を始めよう</a></li>
<li><a href="https://www.amazon.co.jp/Java%E8%A8%80%E8%AA%9E%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%AC%E3%83%83%E3%82%B9%E3%83%B3-%E7%AC%AC3%E7%89%88-%E4%B8%8B-%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%82%92%E5%A7%8B%E3%82%81%E3%82%88%E3%81%86-%E7%B5%90%E5%9F%8E/dp/4797371269">Java言語プログラミングレッスン 第3版(下) オブジェクト指向を始めよう</a></li>
</ul>

<h1>余談</h1>
<h2>大規模なソフトウェア開発の際に便利</h2>
<p>Javaの継承は、大規模なソフトウェア開発を行う際に便利です。</p>
<p>大規模なソフトウェア開発では、自分がすべてのソフトウェア部品をひとりで開発するわけにはいきません。</p>
<p>誰かが作ったソフトウェア部品をほかの誰かが使い、それぞれが作ったソフトウェア部品を組み合わせることで、大規模なソフトウェア開発は行われます。</p>
<p>このような際に必要なのは、ほかの機械製品を作る場合と同じで、「規格外の仕様を使わず、みんなで共通の方法で操作できるような外部とのインターフェースを使い、カプセル化を行うこと」です。</p>
<p>そして、Javaでは、そのような「ソフトウェア部品同士を組み合わせる」ということを、オブジェクト指向という方法でエレガントに行えます。</p>
<p>オブジェクト指向とは、すなわち「自分の実装の範囲内で、自分のすべき仕事をすべて行う」ということです。</p>
<p>ほかの誰かに迷惑をかけることなく、ほかの誰かの仕事を自分が勝手に書き換えることなく、自らの担当する仕事内容の中で、自らの仕事をすべて行うことができ、その仕事を外部のほかの誰かが詳細に知らなくても、必要最低限の使い方の仕様だけを知っていれば、自分の作った機能を他人が使えるようにすること、これを「カプセル化」や「隠蔽」と呼びます。</p>
<p>ですが、時に、ほかの誰かが作ったプログラムに対して、自分が独自の機能を付け足したくなることがあります。</p>
<p>そのような時に、Javaでは、「継承」という機能を使って、簡単に、他人に迷惑をかけずに機能を自分で追加することができます。</p>
<p>機能を追加するために必要なのは、親クラスとextendsを宣言して新しいクラスを作り、そこで付け足したい機能を追加するだけです。誰か他人の書いたプログラムをわざわざ書き換える必要はありません。また、そのような機能の追加をした際に、親クラスと派生クラスは同じやり方で操作できるため、メインのプログラムや制御を行うプログラムの変更も必要最低限で済みます。最初から継承されることを前提として親クラスを書くこともできますし、派生クラスの集団をすべて同じやり方で操作するようなメインプログラムも書くことができます。</p>
<p>そう、Javaのオブジェクト指向と継承の機能により、大規模なソフトウェア開発が非常にやりやすくなります。かつてFORTRANやCOBOLが使われていたメインフレームなどの大規模なソフトウェア開発で、最近急速にJavaが使われているのは、大規模なソフトウェア開発でJavaのオブジェクト指向がとても便利だからです。オブジェクト指向がなければ、複数のプログラマが作ったソフトウェア部品を組み合わせることは極めて難しくなります。さまざまなところにコードが混在し、機能を追加するだけで何日間もかかるような従来の開発を、Javaは非常に高い生産性で短期間に行えるようにするのです。</p>
<div class="edit_date">
<p>2023.05.06</p>
</div>

<h2>特定の場合にしか有効でない処理をスマートに記述できる</h2>
<p>継承は、特定の場合にしか有効でない処理をスマートに記述できます。</p>
<p>たとえば、攻撃を受けて防御する場合に、普通のキャラクターであれば通常のダメージを受けるところで、特定の特性を持ったキャラクターは特殊防御の力でダメージを受けない場合などが挙げられます。</p>
<p>すべてのキャラクターの防御の処理で、特殊防御能力を持っているかどうかをif文で比較することもできますが、さまざまな特殊能力を持ったキャラクターが多くなると記述が膨大になってしまいます。</p>
<p>このような際に、継承、オーバーライド、ポリモーフィズムなどを使い、特定のキャラクタークラスの防御のメソッドを上書きすることで、エレガントに処理を記述できます。</p>
<p>また、カードゲームを作る場合などで、ターンが始まった時やターンが終わる時に何かの処理を追加したい場合があります。このような時も、ターンの最初と最後の処理を「フック」のように上書きすることで、処理を実行できます（実際は単に継承を行うことは難しいので、メソッドチェーン的な何かを作り、処理の最後に特定の処理を追加するようなクラスにします）。</p>
<p>注意すべきこととして、すべてがオブジェクト指向の継承で書けるわけではありません。if文を使わなければ処理が書けないこともあります。たとえば、特殊防御ではなく特殊攻撃のような場合、自分とは異なるクラスのメソッドに対する処理になるため、if文を使わずに書くことは難しい場合があります。また、仮想関数の乱用は、逆にコードの保守性を悪化させることがあります。何事もバランスが肝心です。優れた機能にはメリットだけではなくデメリットもあるということを知っておきましょう。</p>
<p><a href="../videogame/games_devel.html">ゲーム開発</a>も参照のこと。</p>
<div class="edit_date">
<p>2023.05.14</p>
</div>



</div></div> <!--page-->










<script type="text/javascript" src="../../js/jquery.toc.js"></script>
<script type="text/javascript" src="../../js/script.js"></script>
<script type="text/javascript" src="../../js/scriptfortoc.js"></script>
<script type="text/javascript" src="../../js/prettify.js"></script>
<script>prettyPrint();</script>
</body>
</html>