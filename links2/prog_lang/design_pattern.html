<!DOCTYPE html>
<html dir="ltr" lang="ja">
    <head>
        <title>デザインパターンの世界観 - from Assy</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="keywords" content="Assy,アッシー,詩,小説,物語,歴史,政治,経済,コンピュータ,パソコン,Linux,エッセイ,散文,哲学">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="../../css/style.css">
        <link rel="stylesheet" href="../../css/prettify.css" type="text/css">


<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">

    </head>
    <body>
<div class="page">
<script type="text/javascript" src="../../js/jquery.min.js"></script>
<script type="text/javascript" src="../../js/script_smartmenus.js"></script>
<script type="text/javascript" src="../../js/links2.js"></script>

<p><a href="index.html">プログラミング言語の世界観に戻る</a></p>
<div class="sidebar">
<iframe src="../../menus/prog_lang_skill_menu.html" class="sideiframe"></iframe>
</div>
<h1>デザインパターンの世界観</h1>
<p>デザインパターンの世界観です。</p>
<div id="toc"></div>
<div class="page_links">

<h1>デザインパターン</h1>
<h2>デザインパターンの概要</h2>
<p>自分の書いたブログ「神々とともに生きる詩人」<a href="../../diary/blog_frey/2021.02.02.html">2021/02/02</a>より。編集済み。</p>
<p>デザインパターンの概要について言えるのは、クラスをどのように設計するか、ということです。</p>
<p>ある機能を実装する上での、内部のクラス設計、たとえば、抽象的なテンプレートやAPIから実装したり（Template Method, Factory Method）、段階的に基礎から構築したり（Builder, Abstract Factory）、受付や代理人にやらせたり（Facade, Mediator, Proxy）、通知を行ったり（Observer）します。</p>
<p>同時に、ある機能を実現する上での、スマートなクラス設計を行います。</p>
<p>要素と入れ物を同一視したり（Composite）、要素に飾りをたくさんつけたり（Decorator）、あるいは状態（Memento, State）やミニ言語（Command, Interpreter）でクラス設計を表現します。</p>
<p>ほかにも、インスタンスがひとつであることを保証したり（Singleton）、訪問者を作ったり（Visitor）、責任をたらい回しにしたり（Chain of Responsibility）、あるいは、機能のクラスと実装のクラスを分けたり（Bridge）します。</p>
<p>マルチスレッドにおいては、スレッドの待機や排他制御を表現します。</p>
<p>後日注記：このほか、次の要素の数え上げをする（Iterator）、一枚上にラッパーをかぶせる（Adopter）、インスタンスをnewするのではなく複製して作る（Prototype）、アルゴリズムだけを変える（Strategy）、インスタンスを可能な限り共有して軽くする（Flyweight）などといったパターンがあります。</p>
<p>（詳しくは<a href="https://www.amazon.co.jp/Java%E8%A8%80%E8%AA%9E%E3%81%A7%E5%AD%A6%E3%81%B6%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E5%85%A5%E9%96%80-%E7%B5%90%E5%9F%8E-%E6%B5%A9/dp/4797316462">Java言語で学ぶデザインパターン入門</a>が参考になります。）</p>

<h2>パターン個別のメモ</h2>
<p>（<a href="https://www.amazon.co.jp/Java%E8%A8%80%E8%AA%9E%E3%81%A7%E5%AD%A6%E3%81%B6%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E5%85%A5%E9%96%80-%E7%B5%90%E5%9F%8E-%E6%B5%A9/dp/4797316462">Java言語で学ぶデザインパターン入門</a>を参考に執筆しました。）</p>
<p>Iteratorパターンは、反復子とも呼ばれ、単に連続したデータをひとつひとつ順番に操作するためのパターン。すべてのシーケンス型のデータが配列のように連続した領域に固定長で確保されるとは限らないので、ひとつひとつ順番にアクセスするための専用のAPIを用意することがある。C++, Java, Pythonなど、多くの高水準言語では、クラスライブラリや言語仕様としてイテレータを持っている。</p>
<p>Adopterパターンは、一枚上にラッパーをかぶせる。たとえば言語やAPIが違うなどの理由で、そのままでは別のプログラムから使うことのできないプログラムに対して、ラッパーをかぶせることでコンポーネントとして利用することができる。OSや言語、ネットワークの垣根を越えて分散オブジェクトを実装する、CORBAなどが具体例。</p>
<p>Template Methodパターンは、親クラスの集団をまず大まかに設計し、派生クラスのほうで具体的な詳細を設計するパターン。こうすることで、大まかなフレームワークを作っておいた上で、それぞれの場面や状況に必要な具体的な実装を簡単に開発することができる。Ruby on Railsのような多くのMVCフレームワークはこの方式をとっている。</p>
<p>Factory Methodパターンは、Template Methodを用いて、インスタンスを自動的かつ大量に生成するような工場を用意する。</p>
<p>Singletonパターンは、どんな場合においても、必ずインスタンスがひとつしかないことを保証する。残念ながら、メリットよりも多くの弊害があるため、現代ではアンチパターンとして知られている。</p>
<p>Prototypeパターンは、クラスベースのオブジェクト指向のように、すべてのインスタンスを設計図（クラス）からnewして作るのではなく、既にある部品（プロトタイプ）を複製することで新しいインスタンスを作る。JavaScriptなどではこれを「プロトタイプベース」のオブジェクト指向と呼ぶ。たい焼きのたとえ話であれば、たい焼き器からたい焼きを作るのではなく、たい焼き複製魔法を使って既にあるたい焼きからたい焼きを作るイメージ。</p>
<p>Builderパターンは、部品ひとつひとつを構成する基礎と土台を築き、部品からインスタンスを作る。メニューやバー、ボタン、ラベルなどを用いてGUIアプリケーションを作るようなイメージ。それぞれが知る範囲が限られているため、将来的に別のものに取り替えたり、改良したりすることが容易となる。</p>
<p>Abstract Factoryパターンは、それぞれの抽象的なインターフェースだけに注目して、インターフェースを組み合わせて抽象的な製品にまとめる。APIだけに注目し、抽象的な工場、抽象的な部品、抽象的な製品を作っていく。たとえば、OSや言語のシステムコールやクラスライブラリのようなイメージ。</p>
<p>Bridgeパターンは、Template Methodパターンのような抽象クラスの役割を考えた場合、ここには二つの「継承」あるいは「実装」の意味がある。まず、「機能を追加する」というクラス階層で、親クラスには存在しない機能を派生クラスで新しく追加する。もうひとつは、「抽象的なAPIを実装する」というクラス階層で、親クラスで抽象的に表現されたインターフェースを派生クラスで実装する。このように二つのクラス階層が存在するため、Bridgeパターンでは、機能のクラス階層と実装のクラス階層を、二つの独立したクラス階層に分離する。</p>
<p>Strategyパターンは、たとえばソートや探索のアルゴリズムのように、アルゴリズムだけを取り換え可能にし、場合場合によって別のアルゴリズムを使う。OSの低レベルレイヤやデータベースのインデックス方法などもこの例。あるいは、UNIXのシステムコール（POSIX）が定義されていれば、どんなCPUアーキテクチャであっても同じPOSIX APIのカーネルが動くのと同じイメージ。</p>
<p>Compositeパターンは、たとえばディレクトリとファイルのように、入れ物と内容を同じものであると見なす。こうすることで、「入れ物の中にある入れ物の中にある内容」のようなものを単純に表現できる。</p>
<p>Decoratorパターンは、たとえばHTMLのタグやTeXのマークアップのように、飾りと内容を同じものであると見なす。たとえばワープロソフトを開発する際などに、装飾や図などをテキストと同じものであると扱うことができる。</p>
<p>Visitorパターンは、複数のデータ構造に対する訪問者を作る。たとえば、データ構造が一つであった場合、そのデータ構造を表すクラスの中に処理を書けばいい。だが、スタックでもキューでも連結リストでも成り立つ処理を書きたい場合、これをどこに書けばいいか。このような時、データ構造から処理を分離し、データを訪れる「訪問者」を作る。</p>
<p>Chain of Responsibilityパターンは、責任のたらいまわし。鎖のように複数のオブジェクトを繋いだうえで、その鎖の中を渡り歩くことでオブジェクトを決定する。たとえばJavaScriptのプロトタイプ継承は、そのクラスに存在しないメソッドをprototypeがあればそこから探し、なければprototype.prototypeから探す。あるいは、ルータは自分の隣接ネットワークに目的のホストがあるかを探し、なければどのルータに送ればそのホストに近づけるかを知っているため、そのルータにパケットを転送する。そしてルータからルータ、その次のルータへとパケットは転送され、目的地へと辿り着く。</p>
<p>Facadeパターンは、プログラムに「窓口」を作る。すべての目的の場所やその役を知らなくても、そうした場所や役を知っている専用の窓口に問い合わせ、窓口が案内し、目的地へと辿り着く。ひとつのルータ（ゲートウェイ）に遅られたパケットは、その宛先IPアドレスを見てネットワークの内部にある適切なホストへと中継・転送される。このようにすることで、ルータのファイアウォールがしっかりしていれば、不正なパケットをそこで排除できる。</p>
<p>Mediatorパターンは、プログラムに「相談役」を用意し、その相談役との間でプログラムの中での連絡を行う。ひとりひとりにひとりひとりが個別に指示を出すのではなく、ひとりのマスターが存在し、そのマスターへとすべてのスレーブは報告し、そのマスターがすべてのスレーブに指示を伝える。</p>
<p>Observerパターンは、変化に対して観察し、「通知」を行う。たとえば、GTKやQtのようなツールキットは、ボタンがクリックされるかどうかなど、起きるイベントを常に監視する。そして、イベントが起きた時点で、それを必要なプログラムに通知する。変更されたファイルだけをスキャンするアンチウイルスソフトウェアや、設定の変更を監視するレジストリ的なシステムもこの具体例。</p>
<p>Mementoパターンは、状態を保存し、いつでも元の状態に復元できるようにする。viやEmacsのようなテキストエディタでは、その状態を常に記録しており、必要ならアンドゥしていつでも元の状態に戻せるようになっている。データベースなどの差分バックアップもこれであると言える。</p>
<p>Stateパターンは、状態をクラスとして保存する。その時の「状態」と呼ばる範囲はとても多く、プログラムを表すプロセスや、スケジューリングを行う際のそれぞれのコンテキスト、ワープロを使っている時のその時の文書の状態など、多くのことが「状態」として表せる。このような状態をクラスとして保管する。クラスとして表現することで、ある状態から派生した別の状態を表現したり、無限にデータから条件分岐しなくても、クラスを用いて状態を管理できる。</p>
<p>Flyweightパターンは、使用するインスタンスをできるだけ作りすぎずに共有して「軽量さ」を保つ。たとえば、Linuxのコマンドはそれぞれ分かれているが、このコマンドはフィルターやファイル処理だけを見れば、共通の機能が多い。このような機能を共有することで、全体の軽量さを保つ。現に、多くのコマンドの機能をひとつのコマンドで実装し、軽量さを保つ、組み込み向けのBusyboxと呼ばれるソフトウェアがある。</p>
<p>Proxyパターンは、本人の代わりに「代理人」を立て、代理人でもできることは代理人にやらせ、必要な場合にのみ本人を要求する。たとえば、最新の情報が必要ないのであれば、Webページはローカルにキャッシュされた内容でいい。Webページが更新された場合のみ、インターネット接続を用いて最新のページ内容をダウンロードすればいい。この場合、ローカルにキャッシュされた内容を「本当のページの代理人」とすることができる。</p>
<p>Commandパターンは、「命令」を表すクラスを作る。たとえば、ひとつの命令をクラスとして表現することで、命令をオブジェクトとして管理することができる。このようにすれば、命令を複数使った別の命令にすることも容易に可能となる。HTMLやTeXのマークアップなどが実例である。また、命令はイベントともいわれ、ユーザーのマウスやキーボードの操作もイベントに相当する。</p>
<p>Interpreterパターンは、プログラムの行う処理や問題を「ミニ言語」で表現する。たとえば、データベースを操作する場合、柔軟にテーブルを自動作成するためには、SQLというミニ言語があると効果的である。ほかにも、HTMLの装飾をする場合、CSSというミニ言語があると、ひとつひとつのHTMLを編集しなくても、ミニ言語の文法を用いて必要なデザインをいっぺんに変えることができる。その代わり、SQLやCSSを解釈する言語処理系が必要となる。これはまさに「ミニ言語」である。</p>
<div class="edit_date">
<p>2023.07.05編集</p>
</div>

<h2>デザインパターンとは</h2>
<p>ソフトウェアを開発し、設計する時に出てくる「良くあるパターン」をまとめたもの。</p>
<p>僕は以下の本を読んで、とても勉強になった。みんなも読んでほしい。（注意点：本当はまだそんなに読めていない。）</p>
<ul>
<li><a href="https://www.amazon.co.jp/Java%E8%A8%80%E8%AA%9E%E3%81%A7%E5%AD%A6%E3%81%B6%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E5%85%A5%E9%96%80-%E7%B5%90%E5%9F%8E-%E6%B5%A9/dp/4797316462">Java言語で学ぶデザインパターン入門</a></li>
<li><a href="https://www.amazon.co.jp/Java%E8%A8%80%E8%AA%9E%E3%81%A7%E5%AD%A6%E3%81%B6%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E5%85%A5%E9%96%80-%E3%83%9E%E3%83%AB%E3%83%81%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E7%B7%A8-%E7%B5%90%E5%9F%8E-%E6%B5%A9/dp/4797319127">Java言語で学ぶデザインパターン入門 マルチスレッド編</a></li>
</ul>

<h2>デザインパターンとオブジェクト指向は相性が良い</h2>
<p>デザインパターンは、Javaのようなオブジェクト指向と相性が良い。</p>
<p>特に、クラスライブラリを使うだけのプログラミングから、クラスとインスタンス、継承と実装、そしてスレッドを用いた、オブジェクト指向のプログラム設計が出来るようになる。</p>
<p>たくさんのパターンを知っておくことで、プログラム要件が来た時に、どのようにすれば実装出来るか、事前に準備しておくことが出来る。</p>
<p>いわば、「設計のネタ帳」である。</p>
<p>このページに書籍の全てを載せてしまうと、コピーになってしまうので、内容は自ら本を買って読んでほしい。下の説明は目次の引用に過ぎない。</p>
<ul>
<li><a href="https://www.amazon.co.jp/%E5%A2%97%E8%A3%9C%E6%94%B9%E8%A8%82%E7%89%88Java%E8%A8%80%E8%AA%9E%E3%81%A7%E5%AD%A6%E3%81%B6%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E5%85%A5%E9%96%80-%E7%B5%90%E5%9F%8E-%E6%B5%A9/dp/4797327030">増補改訂版Java言語で学ぶデザインパターン入門</a></li>
<li><a href="https://www.amazon.co.jp/%E5%A2%97%E8%A3%9C%E6%94%B9%E8%A8%82%E7%89%88-Java%E8%A8%80%E8%AA%9E%E3%81%A7%E5%AD%A6%E3%81%B6%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E5%85%A5%E9%96%80-%E3%83%9E%E3%83%AB%E3%83%81%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E7%B7%A8-%E7%B5%90%E5%9F%8E-%E6%B5%A9/dp/4797331623">増補改訂版 Java言語で学ぶデザインパターン入門 マルチスレッド編</a></li>
<li><a href="https://www.amazon.co.jp/Reading-%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B6%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%E6%8A%80%E6%B3%95-%E3%83%97%E3%83%AC%E3%83%9F%E3%82%A2%E3%83%A0%E3%83%96%E3%83%83%E3%82%AF%E3%82%B9%E7%89%88-Diomidis-Spinellis/dp/4839956693">Code Reading ~オープンソースから学ぶソフトウェア開発技法~ (プレミアムブックス版)</a></li>
</ul>

<h2>デザインパターンは乱用に注意</h2>
<p>自分の書いたブログ「神々とともに生きる詩人」<a href="../../diary/blog_frey/2021.01.14.html">2021/01/14</a>より。</p>
<p>オブジェクト指向で設計するために、頻出するパターンを教える、GoFのデザインパターンですが、乱用に注意しましょう。</p>
<p>あくまで、大規模なソフトウェアを設計する上で、頻出するパターンを示したものであり、必要ないのに「設計が美しくなる」と思って、なんでもかんでもデザインパターンを使ったところで、保守しやすいソフトウェアにはならないからです。</p>
<p>逆に、複雑で理解できないプログラムになってしまいます。</p>
<p>しかしながら、デザインパターンの用語が分からないと、プログラマとの間で言葉が通じないことがあります。</p>
<p>そのためにも、用語として知っておくとよいでしょう。</p>
<p>以下のリンク先に、より詳しいことが書いてあります。</p>
<ul>
<li><a href="https://qiita.com/tanakahisateru/items/df03d2558f9499d1a64a">GoF デザインパターン チートシート - Qiita</a></li>
</ul>

<h2>デザインパターンへの批判</h2>
<p>GoFのデザインパターンも古くなり、今では批判も存在します。</p>
<p>たとえば、Iteratorパターンは最近のモダンなプログラミング言語の言語仕様では標準的かつ自明のことであり、Template Methodパターンは継承を使った実装の際のテクニックに過ぎません。</p>
<p>Singletonパターンはアンチパターンだと言われています。</p>
<p>関数型プログラミング言語の支持者は、「デザインパターンというものがあること自体が、関数型言語よりもオブジェクト指向言語のほうがプログラミングの抽象化能力が低いということを明確に表している」と批判します。</p>
<p>詳しくは以下が参考になります。</p>
<ul>
<li><a href="https://jp.quora.com/%E4%B8%80%E6%99%82%E6%9C%9F%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A8%E3%81%84%E3%81%86%E3%82%82">一時期プログラミングのデザインパターンというものが大流行しましたが、現在ではどのように評価されているのでしょうか？ - Quora</a></li>
<li><a href="https://qiita.com/e99h2121/items/91d5380932bcd2951d8d">10年前はGoFのデザインパターン本を読んで何やらわかった気になっていました - Qiita</a></li>
</ul>

<h1>詳しいデザインパターンの解説</h1>
<h2>デザインパターン一覧</h2>
<p>以下にデザインパターンの一覧と解説があります。プログラムの設計の前に参照のこと。</p>
<ul>
<li><a href="https://qiita.com/ichi-nakashima/items/ee09c9341f85c18f748a">デザインパターン一覧　[23種類] - Qiita</a></li>
<li><a href="https://qiita.com/sghr/items/774e4f36ab1f8c2c423a">デザインパターンの学習 - Qiita</a></li>
<li><a href="http://www.itsenka.com/contents/development/designpattern/">デザインパターン入門 - IT専科</a></li>
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3_(%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2)">デザインパターン (ソフトウェア) - Wikipedia</a></li>
</ul>

<h2>特におすすめなのはBuilderパターン</h2>
<p>特におすすめなのはBuilderパターンです。</p>
<ul>
<li><a href="https://qiita.com/takutotacos/items/33cfda205ab30a43b0b1">Builderパターン - Qiita</a></li>
<li><a href="https://qiita.com/disc99/items/840cf9936687f97a482b">Javaで書くBuilderパターンのパターン - Qiita</a></li>
</ul>

<h1>簡単な説明</h1>
<h2>デザインパターン</h2>
<ul class="defaultlist list7">
<li>開発技法
<ul>
<li>デザインパターン</li>
</ul></li>
</ul>

<h2>デザインパターン</h2>
<p>23種類の設計のネタ帳。</p>
<p>有名なものにBuilderパターンなど。</p>
<p>イテレータやアダプタのような単純なパターンから、抽象ファクトリーや状態・記憶や代理人を扱ったりする設計上のデザイン、ミニ言語などの高度なパターンもあるので、一度目を通しておこう。</p>

</div></div> <!--page-->










<script type="text/javascript" src="../../js/jquery.toc.js"></script>
<script type="text/javascript" src="../../js/script.js"></script>
<script type="text/javascript" src="../../js/scriptfortoc.js"></script>
<script type="text/javascript" src="../../js/prettify.js"></script>
<script>prettyPrint();</script>
</body>
</html>