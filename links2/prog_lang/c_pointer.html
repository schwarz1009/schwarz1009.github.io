<!DOCTYPE html>
<html dir="ltr" lang="ja">
    <head>
        <title>C関連の世界観４（配列とポインタ） - from Assy</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="keywords" content="Assy,アッシー,詩,小説,物語,歴史,政治,経済,コンピュータ,パソコン,Linux,エッセイ,散文,哲学">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="../../css/style.css">
        <link rel="stylesheet" href="../../css/prettify.css" type="text/css">


<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">

    </head>
    <body>
<div class="page">
<script type="text/javascript" src="../../js/jquery.min.js"></script>
<script type="text/javascript" src="../../js/script_smartmenus.js"></script>
<script type="text/javascript" src="../../js/links2.js"></script>

<p><a href="index.html">プログラミング言語の世界観に戻る</a></p>
<div class="sidebar">
<iframe src="../../menus/prog_lang_c_menu.html" class="sideiframe"></iframe>
</div>
<h1>C言語の世界観（４．配列とポインタ）</h1>
<p>C言語によるプログラミングに関する世界観４（配列とポインタ）です。</p>
<h2>関連ページ</h2>
<ul class="defaultlist list6 menu_list">
<li><a href="c.html">C言語（１．基本）</a></li>
<ul>
<li><a href="c_flow.html">２．制御フロー</a></li>
<li><a href="c_data.html">３．データ構造</a></li>
<li><b>４．配列とポインタ</b></li>
<li><a href="c_io.html">５．入出力</a></li>
<li><a href="c_preprocessor.html">６．プリプロセッサとインラインアセンブラ</a></li>
</ul>
<li><a href="c_comments.html">A．戯言</a></li>
</ul>
<p><a href="c.html">C</a>や<a href="cpp.html">C++</a>も参照のこと。</p>
<p>ツール関係は<a href="c_cpp_tools.html">C/C++ツール</a>に移動しました。</p>
<p>システムに依存する部分は<a href="../linux/linux_api.html">Linux（システムコール・API）</a>や<a href="windows_programming.html">Windowsプログラミング</a>も参照のこと。</p>

<div id="toc"></div>
<div class="page_links">

<h1>配列</h1>
<h2>配列とは</h2>
<p>配列とは、連続した領域に確保される、複数の変数（要素）の集合となる変数のこと。</p>
<p>以下のように、[]を伴って変数を宣言・定義すると、配列となる。</p>
<pre class="prettyprint">
int val[5];
</pre>
<p>x[3]とした時は3つの要素を持つ配列が出来る。これにx[0], x[1], x[2]のようにアクセスすることで、要素の中身を参照・変更できる。</p>
<p>配列の初期化は以下のように記述する。</p>
<pre class="prettyprint">
int x[5] = { 3, 6, 9, 12, 15 };
</pre>
<p>文字列を表現するためには、char型の配列を使ってchar str[256]とする。あるいはchar型のポインタを使ってchar* str = "Hoge";などとする。</p>
<p>後日注記：配列とポインタは結びつきが非常に強く、a[i]という添字表記は*(a+i)とコンパイラによって解釈される。異なるのは、ポインタは変数であるためインクリメントできる。たとえば、p++など。だが、配列名は変数でないためインクリメントできない。ポインタを使うことで、配列を順次にアクセスするために使うことができる。</p>
<p>後日注記：基本的に、C言語では、ポインタと配列はほとんど同じものとして扱われる。配列を関数に渡した時は値渡しではなく参照渡しとなる。また、コピーした時は複製されずアドレスだけのコピーとなる。そのため、配列をコピーする際には別々の変数を作ったかのように見えて同じ場所を指していることがあるため注意が必要。また文字列を表現するためには、基本的に文字の配列へのポインタとして扱われる。そのため、文字列を複製するためにはstrcpy_s()という専用のAPIを使う。</p>

<h2>浅いコピーと深いコピー</h2>
<p>配列の初期化はmemset()、配列のコピーはmemcpy()でできる。</p>
<p>一般に、配列はポインタとして扱われるため、そのまま代入したのではアドレスがコピーされるだけで内容はコピーされない（浅いコピー）。浅いコピーの場合、二つの名前はメモリ上の同じ配列を指す別々の参照となる。</p>
<p>内容をすべてコピーする（深いコピー）には、memcpy()関数を使う。深いコピーの場合、配列はメモリ上の別々の場所に複製される。</p>
<ul>
<li><a href="https://www.sejuku.net/blog/24359">【C言語入門】配列の使い方まとめ(初期化、代入、宣言、コピー) | 侍エンジニアブログ</a></li>
</ul>

<h2>配列の要素数を求める</h2>
<p>配列の要素数を取得することはC言語では方法が用意されていないが、sizeofを使って配列のメモリ上のサイズを知ることはできるため、普通はそこから要素数を計算する。</p>
<ul>
<li><a href="https://www.sejuku.net/blog/24359">【C言語入門】配列の使い方まとめ(初期化、代入、宣言、コピー) | 侍エンジニアブログ</a></li>
<li><a href="https://www.sejuku.net/blog/26940">【C言語入門】配列とは？配列の使い方総まとめ | 侍エンジニアブログ</a></li>
</ul>

<h1>ポインタ</h1>
<h2>ポインタとは</h2>
<p>ポインタ：</p>
<p>ポインタは変数のメモリアドレスの入った変数であり、*pはポインタの先の変数の値、&xは変数のアドレスを指している。</p>
<pre class="prettyprint">
int x;
int *p;

p = &x;
*p = 40;
printf("%d",x);
</pre>
<p>この例では、40と表示される。xに40がポインタを介して代入されている。</p>
<p>後日注記：ポインタを考える時に、単にメモリアドレスを格納しポイントする型であると理解するだけではなく、特定の変数を「ポイント」するというC言語における独自の概念であると考えると理解しやすいかもしれない。</p>

<h2>ポインタと変数のアドレス</h2>
<p>普通、変数は宣言されるごとに、新しい領域に変数のデータが確保されます。</p>
<p>x, y, zを順に次々に宣言すると、xとyとzはそれぞれ、別々の領域に変数が作られます。</p>
<p>これは、それぞれの場所に値を確保したいような、「値型の変数」では問題ありません。</p>
<p>ですが、「参照型の変数」とも呼ばれますが、ポインタを使うことで、「同じ場所（アドレス）にある別の名前の変数」を参照できます。</p>
<p>これは、たとえばデータ構造のように、「プログラムの中で、別の名前でも同じアドレスの変数を参照したい」時に使えます。特に、リストのようなデータ構造では、「リストに連結された次のデータ」を参照するために、ポインタを使います。</p>
<p>ポインタを応用することで、同じアドレスを関数の内部（呼び出し先）と外部（呼び出し元）で共有することもできます。こうした「データの共有」という考え方が、ポインタによって行えます。</p>
<p>つまり、「変数のアドレス」という考え方で、同じ場所にあるデータを「共有」し、「指し示す」という考え方が、ポインタです。</p>
<p>先の連結リストの例のように、ポインタを上手く使うことで、「データ構造の中に別の変数のアドレスを含める」といったようなことができます。ある場所にある変数を、別の場所から操作できるのです。</p>
<p>こうしたことができるのは、変数が単なる数値ではなく、「メモリアドレス上のデータ領域」であるためです。C言語では変数にその変数が位置するメモリアドレスでアクセスすることができます。</p>

<h2>構造体のポインタ</h2>
<p>構造体のポインタは-&gt;でアクセスできる。</p>
<pre class="prettyprint">
struct user schwarz;
struct user *up;
up = &schwarz;
up-&gt;name = name;
</pre>
<p>構造体のポインタを上手く使うことで、関数への引数から同じ構造体を操作することができる。これにより、簡単な変数の保持と共有ができる。</p>
<p>どの関数からも同じデータを使いたい時は、構造体のポインタを使う。C++/Javaのオブジェクト指向は、構造体に関数ポインタを関連付けて、どの関数からも同じ構造体のデータ（構造体のポインタ）にアクセスできるようにしたもの、だと考えることができる。</p>

<h2>ポインタを操作する関数</h2>
<p>C言語では、ファイルポインタのように、構造体へのポインタを関数に渡す、という手法を多用する。</p>
<p>特にWindowsなどで、ポインタを操作する関数というのはたくさん存在し、ポインタを返す関数もたくさんある。特に、ファイルなどシステムのデータを参照する時に、ポインタを返す関数を使い、ハンドラなどを関数に渡すことが多い。</p>
<p>構造体のポインタを関数に渡すのは半ば慣例化していて、Linuxカーネルなどでも、ポインタを関数に渡すことが通例になっている。関数の内部でポインタのデータを操作することができる。</p>
<p>後日注記：関数に構造体データを与える時、単に引数として与えると「複製」になる。これはサイズの大きなデータではオーバーヘッドが大きく、また関数の中から変更することができないため、関数の引数として構造体を与える時はポインタを与えることが多い。この時、呼び出し側では&をつけて構造体変数のアドレスを与える。（与えるのが配列や文字列の場合は既にポインタであるため&は必要ない。）</p>
<p>後日注記：ポインタの引数を純粋にオーバーヘッドの問題のみから使う場合、引数が変更されないことを示すためにconstをつける（たとえばconst char*）こともある。しかしながら、Cの基本型（intなど）を使う場合、参照渡しよりも値渡しを使った方が普通は高速である。</p>

<h2>ポインタのインクリメントと列挙</h2>
<p>高度なプログラミングとして、ポインタをインクリメント（++で繰り返し値を増やしていく）して関数ポインタを操作したり、構造体などで関数ポインタのようなものを列挙したりすることで、汎用的なプログラミングを行うことが出来る。</p>

<h2>ポインタは「データの在り処」</h2>
<p>C言語で出てくる「ポインタ」は、さまざまな関数処理を行うための、「データの在り処」だと考えましょう。</p>
<p>Cでは、ファイルポインタFILE*など、とにかくポインタがたくさん出てきますが、基本的にそれらは、ファイルの読み書き位置やデータへのアクセスを許すものであり、要は「データの在り処」です。</p>

<h2>ポインタを返す関数</h2>
<p>実際のプログラミングでは、ポインタを返す関数というのは良く使われる。</p>
<p>たとえば、このようなコードがよく出てくる。</p>
<pre class="prettyprint">
struct block_object *obj = next_block_object();
</pre>
<p>こうしたポインタと関数の使い方をすることで、open()のようにシステムで確保したデータ領域を保持したり、何らかの処理を行った上で確保されたデータ領域へのアクセス手段を（別の関数でアクセスするために）保持し続けることができる。</p>
<p>ポインタを返す関数を作る時は、変数の寿命に注意すること。関数内で宣言されたローカル変数の「値」を返すのは問題ないが、「アドレス」を返すのは駄目。ローカル変数として宣言された変数は、関数が終わってしまえば削除されてしまうため、ローカル変数へのアドレスは関数が終わった時点でアクセスできなくなる。値の場合はコピーされて渡されるためこういう問題は無い。もし関数内で作った変数のアドレスを返したい時は、malloc()などを使うことが考えられる。</p>
<ul>
<li><a href="https://programming.pc-note.net/c/pointer5.html">ポインタを返す関数(C言語) - 超初心者向けプログラミング入門</a></li>
<li><a href="http://rainbow.pc.uec.ac.jp/edu/program/b1/Prob6-1.htm">ポインタを返す関数 - ２０１１年度　コンピュータ演習 ブロック１ 「構造化プログラミングの基礎」 担当：白川</a></li>
<li><a href="http://www7b.biglobe.ne.jp/~robe/cpphtml/html03/cpp03008.html">ロベールのＣ＋＋教室 - 第８章 アドレスを返す関数 -</a></li>
</ul>

<h2>constとポインタ</h2>
<p>ポインタにconstをつける場合は、constをどの位置に記述するかで文法的な意味が変わってくる。</p>
<pre class="prettyprint">
const char* str = "Hoge";
</pre>
<p>のように、*よりも前にconstをつけた場合、ポインタが参照する値が変更できなくなる。この例ではポインタの参照する文字列が変更できなくなる。</p>
<pre class="prettyprint">
int* const ptr = &n;
</pre>
<p>のように、*よりも後にconstをつけた場合、ポインタそのもの（メモリアドレス）が変更できなくなる。この例ではポインタに別のアドレスを代入することができなくなる。</p>
<p>詳しくは以下を参照のこと。</p>
<ul>
<li><a href="https://rinatz.github.io/cpp-book/ch02-04-pointers-and-references/">2.4. ポインタと参照 - ゼロから学ぶ C++</a></li>
</ul>
<div class="edit_date">
<p>2023.01.20編集</p>
</div>

<h2>メモリをハードウェア的に見た時、あるのは名前ではなく場所である</h2>
<p>自分の書いた「ニュース - 2021-05-第二週」<a href="../../diary/news/2021.05.w2.html">2021/05/06</a>より。</p>
<p>C言語のポインタについて言うと、パソコンやメモリをハードウェア的に見た時に、あるのは「名前」ではなく、「場所」である。</p>
<p>変数において、名前は識別するためのシンボルに過ぎず、真にハードウェアを見た時、あるのは名前ではなく、アドレス空間における場所、すなわちメモリアドレスである。</p>
<p>ポインタは、このような「メモリアドレスを指し示す」変数である。</p>

<h1>動的なメモリ管理</h1>
<h2>mallocとfree</h2>
<p>通常の配列は、要素の数が固定されており、後々になってサイズを変更することができない。</p>
<p>これに対して、malloc()を使って動的に確保された配列は、要素の数を動的に決めたり、realloc()によってサイズを後になって変更することができる。</p>
<p>malloc()で確保したメモリ領域は、使用されなくなった段階で必ずfree()で解放しなければならない。</p>
<ul>
<li><a href="http://www.geocities.co.jp/SiliconValley-Bay/7437/c/malloc.html">メモリの動的割り当て（malloc,free） - パソコン活用研究C&C++であそぼ</a></li>
<li><a href="https://teratail.com/questions/99420">C - malloc関数について｜teratail</a></li>
</ul>
<div class="edit_date">
<p>2023.01.18編集</p>
</div>

<h2>mallocの使い方</h2>
<p>malloc()の使い方は、</p>
<pre class="prettyprint">
int *mem;
mem = (int *)malloc(sizeof(int) * 20);
</pre>
<p>のように、配列のサイズを指定したmalloc()関数を実行し、その返り値を型キャストして配列のポインタに代入する。</p>
<p>後日注記：malloc()で確保した配列は、通常の配列と同様に[]を使ってmem[0]のように要素にアクセスできる。</p>
<ul>
<li><a href="http://www.me.tokushima-u.ac.jp/~miw/wadai/IP3/Tips/Array2.html">配列の使い方 - 徳島大学大学院ソシオテクノサイエンス研究部 - 三輪昌史</a></li>
</ul>
<div class="edit_date">
<p>2023.01.19編集</p>
</div>

<h2>reallocの使い方</h2>
<p>malloc()とrealloc()の使い方として、注意すべきなのはエラーチェック。malloc()は、システムのメモリが使い果たされた場合など、正常にメモリを確保できなかった場合にNULLを返す。このNULLを必ずチェックするようにしよう。</p>
<p>また、realloc()では、一時的にtmpなどの一時変数に格納し、再確保に失敗した場合はその時点で解放し（そのまま使い続けても問題はない）、成功した場合に一時変数を代入するようにしなければならない。</p>
<pre class="prettyprint">
#include &lt;stdio.h&gt;
int main(void){
    int i;
    int *mem;
    int *tmp;

    if ((mem = (int *)malloc(sizeof(int) * 20)) == NULL) {
        fprintf(stderr, "メモリの確保に失敗しました。\n");
        exit(1);
    }

    printf("最初の配列:\n");
    for (i = 0; i &lt; 20; i++) {
        mem[i] = i;
        printf("mem[%d] : %d\n", i, mem[i]);
    }

    if ((tmp = (int *)realloc(mem, sizeof(int) * 40)) == NULL) {
        fprintf(stderr, "メモリの再確保に失敗しました。\n");
        free(mem);
        exit(1);
    } else {
        mem = tmp;
    }

    printf("サイズを変更した配列:\n");
    for (i = 0; i &lt; 40; i++) {
        mem[i] = i;
        printf("mem[%d] : %d\n", i, mem[i]);
    }

    free(mem);
    
    return 0;
}
</pre>
<p>実行結果：</p>
<pre>
最初の配列:
mem[0] : 0
mem[1] : 1
mem[2] : 2
mem[3] : 3
mem[4] : 4
mem[5] : 5
mem[6] : 6
mem[7] : 7
mem[8] : 8
mem[9] : 9
mem[10] : 10
mem[11] : 11
mem[12] : 12
mem[13] : 13
mem[14] : 14
mem[15] : 15
mem[16] : 16
mem[17] : 17
mem[18] : 18
mem[19] : 19
サイズを変更した配列:
mem[0] : 0
mem[1] : 1
mem[2] : 2
mem[3] : 3
mem[4] : 4
mem[5] : 5
mem[6] : 6
mem[7] : 7
mem[8] : 8
mem[9] : 9
mem[10] : 10
mem[11] : 11
mem[12] : 12
mem[13] : 13
mem[14] : 14
mem[15] : 15
mem[16] : 16
mem[17] : 17
mem[18] : 18
mem[19] : 19
mem[20] : 20
mem[21] : 21
mem[22] : 22
mem[23] : 23
mem[24] : 24
mem[25] : 25
mem[26] : 26
mem[27] : 27
mem[28] : 28
mem[29] : 29
mem[30] : 30
mem[31] : 31
mem[32] : 32
mem[33] : 33
mem[34] : 34
mem[35] : 35
mem[36] : 36
mem[37] : 37
mem[38] : 38
mem[39] : 39
</pre>
<p>詳しくは以下のページが参考になる。</p>
<ul>
<li><a href="https://marycore.jp/prog/c-lang/realloc/">【C言語】realloc関数｜正しい使い方と注意点 メモリ断片化など | MaryCore</a></li>
<li><a href="http://www9.plala.or.jp/sgwr-t/lib/realloc.html">realloc - 初心者のためのポイント学習Ｃ言語</a></li>
<li><a href="https://9cguide.appspot.com/19-01.html">配列を自由自在に作る - 苦しんで覚えるC言語</a></li>
</ul>
<div class="edit_date">
<p>2023.01.18</p>
<p>2023.02.17編集</p>
<p>2023.11.17編集</p>
</div>

<h2>動的なメモリ割り当て</h2>
<p>malloc()で動的に確保した配列は、ポインタに代入して操作し、実行時に配列のサイズを動的に決められる。このため、「どれくらいのサイズになるか分からない」変数を扱うために使用できる。</p>
<p>途中で配列のサイズを変更したい場合はrealloc()を使う。また、メモリ領域を0で初期化した上で確保するcalloc()という関数がある。</p>
<p>malloc()で確保した変数はヒープ領域に保管され、スコープを脱出しても削除されない。このため、さまざまな変数から共通してアクセスするような「共有データ」のために使用できる。</p>
<p>使い終わった後はfree()で解放しなければ、メモリリークが起きる。</p>
<ul>
<li><a href="http://www9.plala.or.jp/sgwr-t/lib/malloc.html">malloc - 初心者のためのポイント学習Ｃ言語</a></li>
<li><a href="http://www9.plala.or.jp/sgwr-t/lib/realloc.html">realloc - 初心者のためのポイント学習Ｃ言語</a></li>
</ul>
<p>後日注記：システムのメモリが使い果たされた時、malloc()はNULLを返す。これを必ずチェックすること。Cでシステムやライブラリの関数を使う時は、関数の戻り値をエラーチェックに使うように注意しよう。一連の処理を自作のメモリアロケータ関数にすることもある。また、入出力データなどで、動的にメモリを確保する場合、足りなくなったらrealloc()を用いて調整することもある。</p>

<h2>参照カウント方式のガーベッジコレクション</h2>
<p>自分の書いたブログ「未来のわたしの心より今のあなたへ」<a href="../../diary/blog_frey/2021.03.27.html">2021/03/27</a>より。</p>
<p>並列処理などで動的なメモリ確保と解放が複雑になる時に、参照カウント方式のガーベッジコレクションを使うことがある。</p>
<p>その変数の参照が増えるごとに参照カウントをインクリメントし、参照が減るごとにデクリメントする。</p>
<p>全ての参照が無くなってゼロになった時に、その変数は不要になるため、メモリ領域を解放する。</p>
<p>参照カウント方式の他にも、マーク・スイープやコピーGCなどの方式がある。</p>
<p>以下は参考文献。</p>
<ul>
<li><a href="https://www.amazon.co.jp/Reading-%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B6%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%E6%8A%80%E6%B3%95-%E3%83%97%E3%83%AC%E3%83%9F%E3%82%A2%E3%83%A0%E3%83%96%E3%83%83%E3%82%AF%E3%82%B9%E7%89%88-Diomidis-Spinellis/dp/4839956693">Code Reading ~オープンソースから学ぶソフトウェア開発技法~ (プレミアムブックス版)</a></li>
<li>やねうらお氏の「<a href="https://www.amazon.co.jp/Windows%E3%83%97%E3%83%AD%E3%83%95%E3%82%A7%E3%83%83%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%82%B2%E3%83%BC%E3%83%A0%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-%E3%82%84%E3%81%AD-%E3%81%86%E3%82%89%E3%81%8A/dp/479800314X">Windowsプロフェッショナルゲームプログラミング</a>」</li>
</ul>
<p><a href="java_gc.html">Java（２C．ガーベッジコレクションと例外）</a>も参照のこと。</p>

<h1>関数ポインタ</h1>
<h2>関数ポインタ</h2>
<p>関数ポインタを使うことで、関数をポインタとして変数に格納できる。構造体や配列に格納したり、引数として関数ポインタを使うことも可能。
<p>後日注記：関数ポインタは(*func_p)(int, int)のように定義する。intの部分は引数の型を表す。この関数ポインタの見た目は「醜い」といって批判されがちである。関数を引数にとることもできるので、どのような関数が来るかは分からないがその関数を実行したい時などに使える。</p>
<ul>
<li><a href="http://utsukemononi.gozaru.jp/gc/page23.html">関数ポインタ - Linuxで遊ぼう</a></li>
</ul>
<p>以下は上記サイトを参考に自分でコードを記述。</p>
<p>関数ポインタを引数にとる関数：</p>
<pre class="prettyprint">
#include &lt;stdio.h&gt;

int func_p(int x, int (*func1)(int), int (*func2)(int)){ /* 引数に関数ポインタを指定 */
    return (func1(x) * func2(x));
}

int func_f(int x) {
    return (x * 2);
}

int func_g(int x) {
    return (x + 100);
}

int main(){
    x = func_p(100, func_f, func_g);
    printf("%d\n", x);
    return 0;
}
</pre>
<p><a href="function.html">関数</a>や<a href="functional_programming.html">関数型プログラミング</a>や<a href="closure.html">クロージャ・無名関数・関数オブジェクト</a>も参照のこと。</p>
<div class="edit_date">
<p>2023.01.20編集</p>
</div>

<h1>ポインタの理解</h1>
<h2>同じ箱にアクセスできるか否か</h2>
<p>ポインタを理解するためには、「同じ箱にアクセスできるか否か」ということが重要です。</p>
<p>ポインタとは、メモリアドレスを格納できる変数のことで、そのアドレスが指し示す「箱」の中にある値を参照したり、書き換えたりすることができます。</p>
<p>ですが、ポインタという言葉を聞くと、「普通の変数ではない特殊な変数」だと思われる方が多いでしょう。</p>
<p>ですが、ローカル変数をローカルスコープで扱う際には、ポインタと同じように「同じ箱にアクセスする」ということを普通にやっています。</p>
<p>たとえば、以下のようなコードがあります。</p>
<pre class="prettyprint">
int x = 0;
x = 10;
x = 15;
</pre>
<p>ここで、この3行は、同じxという箱に変数名を使ってアクセスしています。決して、10の格納されたxと、15の格納されたxが、別々に確保されることはなく、「同じxという変数の箱」に10や15を格納しています。</p>
<p>ですが、関数への値渡しの時はそうではなく、関数の中では別の変数の箱が用意され、値はコピーされるだけです。</p>
<pre class="prettyprint">
void plus2(int x) {
    x = x + 2;
}

int main(){
    int x = 0;
    x = 10;
    plus2(x);
}
</pre>
<p>このようにしても、xが12になることはありません。値が別の箱にコピーされて渡されているからです。</p>
<p>ポインタとは、この後者の例ではなく、前者の例のように、変数の箱のアドレスそのものを渡して、「同じ箱にアクセスできる」ようにしたものです。</p>
<pre class="prettyprint">
void plus2(int* x) {
    *x = *x + 2;
}

int main(){
    int x = 0;
    x = 10;
    plus2(&x);
}
</pre>
<p>この例では、plus2(&x)によって、x = x + 2を実行するのと同じように、xに2を加算することができます。</p>
<p>Javaのような多くのオブジェクト指向言語にはポインタがありません。その理由は、同じ変数の箱に関数からアクセスしたいのであれば、クラスのメンバ変数をそれぞれのメソッドから操作すればよいからです。メンバ変数をメソッドから操作することで、ポインタがなくても、各関数から同じ変数の箱に共通かつ効率的にアクセスできます。</p>
<p>また、多くのオブジェクト指向言語で、クラスのオブジェクトは参照型として扱われるため、ある関数やメソッドにオブジェクトを渡して、その関数でオブジェクトを操作することも、ポインタがなくてもできる言語が多いです。</p>
<p>あるいは、Perlのように、myを使ってローカル変数であることを明示しない限り、すべての変数をグローバル変数として扱うような言語も、手軽と言えば手軽なのかもしれません。</p>
<p>ポインタは、グローバル変数とよく似ています。グローバル変数も、それぞれの関数から共通してアクセスできます。違う点は、アドレスを渡すだけで、名前空間を汚染することがないということです。グローバル変数は、グローバルな名前でアクセスするために、グローバルな名前空間を汚染してしまいます。ポインタは、名前空間を汚染せず、必要な関数に必要な時点で変数のアドレスを渡すことができます。</p>

<h2>大きなデータを渡したり、さまざまな場所で変数へアクセスしたりするために使う</h2>
<p>ポインタの使いどころとは、大きくいって、「大きなデータを渡す場合」や、「さまざまな場所で変数へアクセスする場合」などです。</p>
<p>大きなデータを渡す場合、たとえばファイルやソケットのバッファを渡す場合、ポインタを使うことで、値をコピーせず、箱そのもののアドレスを渡すことができ、オーバーヘッドが少なくてすむため、効率的になります。</p>
<p>また、さまざまな場所で変数にアクセスしたい場合にも、ポインタを使うことで、同じ変数にさまざまな場所からアクセスできます。</p>
<p>また、変数のサイズがどれくらいの大きさになるのか分からない時、静的な配列ではコードを書けないことがあります。このような時に、動的に確保したメモリ領域をポインタを使って保持することができます。</p>
<p>ほかにも、データ構造を作る際に、連結リストやツリーのようなデータ構造では、要素が別の要素へと連結されて続いていく場合があります。このような場合にもポインタを使うことが多いです。</p>
<p>また、C言語のハッカーの常套手段として、配列のような連続したデータ領域で、要素にひとつひとつ順番にアクセスするために、ポインタの値をインクリメント（1ずつ加算）して、配列の各要素を指し示すための「カーソル」として使うこともあります。数値の配列だけではなく、文字列などにおいても使えます。ただし連続したデータ領域に対してしかこの手法は使えません。同様の手法を連続していない反復データ構造に使いたい場合、C++のSTLコンテナなど多くの言語では、イテレータ（反復子）を使うこともできます。</p>
<p>また、カーネルやシステムのリソースをユーザーランドのプログラムが使う際に、カーネルとユーザーの間でリソースをやり取りするためにポインタが使われることがあります。たとえば、UNIXやstdioにおけるオープンしたファイル、ソケットなどのバッファ、Windowsのデバイスコンテキストやウィンドウインスタンスなどのシステムオブジェクトは、ファイルディスクリプタやウィンドウハンドラ・インスタンスハンドラのようなシステムによって指定される整数値の識別子か、あるいはファイルポインタのような特定の型やオブジェクトへのポインタを使ってユーザープログラムからアクセスします。また、カーネルの内部でも、たとえばソケットバッファのような場合、バッファをコピーするためのオーバーヘッドを避けるために、ポインタを使って各ネットワーク層でデータの受け渡しがされています。</p>

<h1>関連ページ</h1>
<h2>ポインタとメモリ管理</h2>
<p><a href="programming_pointer.html">プログラミング作法（３C．ポインタとメモリ管理）</a>も参照のこと。</p>

<h2>メモリ</h2>
<p>メモリと仮想メモリについては、<a href="../hardware/memory.html">メモリ</a>や<a href="../linux/linux_kernel_mm.html">Linuxカーネル（メモリ管理）</a>を参照のこと。</p>

<h2>アセンブラ</h2>
<p>アセンブラについては、<a href="assembly.html">アセンブリ言語</a>を参照のこと。</p>

<h2>メモリAPI</h2>
<p>メモリAPIについては、<a href="../linux/linux_api2.html">Linux API（プロセス・メモリ）</a>を参照のこと。</p>

<h2>STLコンテナ</h2>
<p>C++のSTLコンテナについては、<a href="cpp_stl_libs.html">C++（STL・ライブラリ）</a>を参照のこと。</p>

<h2>Java</h2>
<p>Javaについては、<a href="java.html">Java</a>や<a href="java_oop.html">Java（オブジェクト指向）</a>を参照のこと。</p>

<h1>簡単な説明</h1>
<h2>ポインタ</h2>
<ul class="defaultlist list7">
<li>ポインタ
<ul>
<li>ポインタ
<ul>
<li>参照としての利用</li>
<li>ポインタの引数
<ul>
<li>ポインタの引数を使うことで、関数の内部から外部の変数を変更できる</li>
</ul></li>
<li>動的なメモリ管理</li>
<li>関数ポインタ</li>
</ul></li>
</ul></li>
</ul>

<h2>参照としての利用</h2>
<p>ラベルを同じ箱を指す別の名前として使用する。</p>
<p>変数名ではなく、メモリアドレスによって、絶対的位置から変数を操作する。</p>
<p>C言語でリストなどを実装したり、カーネル内部のバッファにアクセスするなどに必要。</p>










</div></div> <!--page-->










<script type="text/javascript" src="../../js/jquery.toc.js"></script>
<script type="text/javascript" src="../../js/script.js"></script>
<script type="text/javascript" src="../../js/scriptfortoc.js"></script>
<script type="text/javascript" src="../../js/prettify.js"></script>
<script>prettyPrint();</script>
</body>
</html>