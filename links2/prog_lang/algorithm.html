<!DOCTYPE html>
<html dir="ltr" lang="ja">
    <head>
        <title>アルゴリズムの世界観 - from Assy</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="keywords" content="Assy,アッシー,詩,小説,物語,歴史,政治,経済,コンピュータ,パソコン,Linux,エッセイ,散文,哲学">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="../../css/style.css">


<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">

    </head>
    <body>
<div class="page">
<script type="text/javascript" src="../../js/jquery.min.js"></script>
<script type="text/javascript" src="../../js/script_smartmenus.js"></script>
<script type="text/javascript" src="../../js/links2.js"></script>

<p><a href="index.html">プログラミング言語の世界観に戻る</a></p>
<div class="sidebar">
<iframe src="../../menus/prog_lang_skill_menu.html" class="sideiframe"></iframe>
</div><h1>アルゴリズムの世界観</h1>
<p>アルゴリズムに関する世界観です。<a href="data_structure.html">データ構造</a>も参照のこと。</p>

<h2>関連ページ</h2>
<ul class="defaultlist list6 menu_list">
<li><b>アルゴリズム</b></li>
<ul>
<li><a href="algorithm_example.html">具体的なアルゴリズム</a></li>
</ul>
</ul>

<div id="toc"></div>
<div class="page_links">

<h1>アルゴリズム</h1>
<h2>アルゴリズムとは</h2>
<p>アルゴリズムとは、コードブロック（プログラム）の全体の構造や流れのこと。</p>
<p>特に、ソートや探索など、ある目的のために順序立てて作られた、データの整理のプログラムのことを「アルゴリズム」と言うことが多い。</p>
<p>ソートや探索では、一時的な記憶領域（変数）にデータを格納し、繰り返し（反復して）データを移動・変更・書き換えることで、データ全体を順番に整理したり（ソート）、目的のデータを探索したり（探索）する。</p>
<p>場合と条件によって反復的にデータを書き換え、全体の処理が終わった時にきちんとソートができるか、といったところを数学的に考えてコードを作る必要がある。</p>
<p>ソートや探索に限らず、ある目的のためのコードブロックの流れや順番に沿った構造のことをアルゴリズムと呼ぶ。プログラミングは、このアルゴリズムを中心に行う。多くの場合一時的なデータを保管し、反復や条件分岐によって場合や条件を変えて書き換える。</p>

<h2>フローチャート</h2>
<p>アルゴリズムを自分で設計・実装する場合、条件分岐や反復構造の中で処理の流れを考える、「フローチャート」と呼ばれる図を描くことが、特に初心者にとっても、また上級者にとっても有効です。</p>
<p>実際のところ、数学的なアルゴリズムを自分で開発するのは、とても難しいことです。いきなりコードを描いてできることではありません。</p>
<p>フローチャートを描くことで、いつどのような条件で処理を実行し、実行内容をどのような手順（それも単純ではなく複雑な手順）で実行するのかを考えることができます。</p>
<p>ソートや探索だけではなく、文字列検索やメモリやデータベースなどのリソース管理などに必要なアルゴリズムも、フローチャートを描くことで書きやすくなるでしょう。</p>

<h2>与える変数や参照・取得する変数だけを変えて同じルーチンを実行する</h2>
<p>アルゴリズムに多いのが、ルーチンワークです。これは、「与える変数や参照・取得する変数だけを変えて同じルーチンを実行する」というものです。</p>
<p>与える変数とは、インクリメントされるカウント変数や、関数やブロックに引数などとして渡す、「一回一回変わるデータの参照先」です。</p>
<p>また、参照・取得する変数とは、データを参照・格納したり、場合によってはソートしたり探索したりする、「保持するデータの格納先」です。</p>
<p>ルーチンを書く時には、こうした変数をどのように捕捉するかを考えながら、どんな場合においても共通の「手順」を書きます。たとえば、ファイルの文字列を一行ごとに検索し、正規表現でマッチするパターンがあればカウントを増やす、あるいは何らかの処理を実行する（マッチした部分と回数のプリント出力など）といったことが記述できます。</p>
<p>そして、条件式やジャンプ命令などで、「この場合に終了する」とか、「この場合は処理を行わず次の処理を行う」などといった「中止命令」を内部に挿入します。場合によっては最後まで処理すれば停止するだけではなく、途中で何らかの文字列が含まれていれば即座にアボートする、などといったことが考えられます。</p>
<p>「アルゴリズム」とは、このようなルーチンの設計を指して言わることが多いです。</p>

<h2>アルゴリズムを自分で書く場面</h2>
<p>最近は、クラスライブラリのようなモジュールが既に用意されていたり、専用のSQLなどのデータベースサーバーがオープンソースで入手できたりすることから、本当にアルゴリズムを自分で書かなければならない場面というのは少なくなっています。</p>
<p>それでも、純粋な数学的記述を行ったり、自分で独自の処理を柔軟に行うために、画像処理やテキスト処理などを自分で独自に実装したり、あるいはハードウェアやバックエンドに近いカーネルやファイルシステムやデータベースなどのデータ構造を作ったり、GUIに近いところではHTMLレンダリングエンジンなどのコアのコンポーネントを作ったりするためには、自分でアルゴリズムを設計しなければなりません。</p>
<p>アルゴリズムの設計としてもっとも単純なのは、分岐命令や繰り返し命令を図にし、その図の中にプリントなどの処理や変数の操作を書く、フローチャートです。</p>
<p>また、オブジェクト指向モデリングやUML図においては、クラス図やシーケンス図を描くことで、行われる処理と「どのようなデータ構造を使うのか」を明確にし、クラス間の関係性や関連性を考えられます。</p>
<p>オブジェクト指向でアルゴリズムを設計するためには、<a href="design_pattern.html">デザインパターン</a>も有効です。デザインパターンは多くの設計に共通する「デザイン上のよくあるパターン」を集めたもので、JavaだけではなくC#やPythonなどでアルゴリズムを書く時も、デザインパターンが参考になります。特にBuilderパターンはよく使われます。</p>
<p>また、アルゴリズムだけではなく、<a href="data_structure.html">データ構造</a>も重要です。ファイルシステムを実装する場合も、アルゴリズムだけではなく、iノードやダーティビットなどを作る上で、双方向リストなどのようなデータ構造を使ってどのようにアルゴリズムを書くかはとても重要です。スケジューリングやメモリ管理についても、たくさんのアルゴリズムがあると同時に、それと関連するひとつひとつのデータ構造があります。</p>
<p>僕は全然データ構造のこともアルゴリズムのことも詳しくありませんが、「バックエンドの開発でもフロントエンドの開発でもアルゴリズムとデータ構造の知識は必須」であると考えた方が良いでしょう。ライブラリやモジュールに頼るだけのプログラミングから、自分でライブラリやモジュールを書けるプログラミングへとレベルアップできるでしょう。</p>

<h2>ハードウェアに近いところにもアルゴリズムはある</h2>
<p>アルゴリズムというと、「抽象的で数学的な方法や手順である」とされることが多いですが、実際のプログラミングにおいては、ハードウェアにとても近いところでもアルゴリズムが多くみられます。</p>
<p>たとえば、Linuxカーネルのメモリ管理のアルゴリズムや、CPUスケジューリングのアルゴリズムなどが代表的です。</p>
<p>具体例をひとつ挙げると、CPUスケジューリング・アルゴリズムとして、「ラウンドロビン」と呼ばれるアルゴリズムがあります。これは、複数のプロセスにひとつひとつ順番に交代してCPUのリソース資源を割り当てるアルゴリズムです。また、これ以外にもスケジューリングのアルゴリズムはあります。以下を参照してください。</p>
<ul>
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%A9%E3%82%A6%E3%83%B3%E3%83%89%E3%83%AD%E3%83%93%E3%83%B3%E3%83%BB%E3%82%B9%E3%82%B1%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0">ラウンドロビン・スケジューリング - Wikipedia</a></li>
<li><a href="https://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%B1%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0">スケジューリング - Wikipedia</a></li>
</ul>
<p>このように、アルゴリズムは必ずしも数学的ではなく、極めてハードウェアに近い部分でも多く見られます。OSカーネルやバックエンドを学ぶ上では、こうしたアルゴリズムの知識が欠かせません。</p>

<h2>独自データベースとアルゴリズム</h2>
<p>データベースのようなバックエンドは、アルゴリズムが分かっていると、独自に設計して開発することができます。</p>
<p>これは、たとえばスケーラビリティが必要な場合（クラスタ・スーパーコンピュータからモバイルやゲームまでスケールが大きい・小さい場合に独自に実装する）とか、扱うプラットフォームやシステム構成が特殊だったりする場合や、独自の機能が必要な場合（ネットワークやセキュリティや並列性など）、あるいは信頼性や性能で妥協を許さない場合などに有効だと思います。</p>
<p>実際は僕もやったことがないので分かりませんが、MySQLやPostgreSQLでは対応できない状況というのはあるでしょう。</p>
<p>こうした場合にデータベースのインデックスや検索などのアルゴリズムを知っておくと、自社でデータベースに必要な機能を取捨選択することができます。</p>
<p>あるいは、自社でデータセンターを運用したい場合などに、自社でデータベース管理システムを「その決まりや作法に従ったスタイルで」構築したい場合もあると思います。リレーショナルデータベースだけがデータモデルではありません。Amazonなども、AWSのデータベース管理システムをOracleから独自実装に切り替えたと話題になりました。今どうなっているかは知りません。</p>
<p><a href="../db/rdbms.html">RDBMS</a>も参照のこと。</p>

<h2>プログラムの効率を上げるためにはボトルネックを解消すること</h2>
<p>なぜ、Linuxカーネルの効率が高いのか、それはメモリやディスク、ネットワークといったリソースを効率的に使っているからです。</p>
<p>そして、プログラムの効率を高めるためにはどうすればいいか、それはボトルネックを解消することです。</p>
<p>プログラムのソースコードの中で、本当に時間のかかる部分というのは、全体ではなく、ほんの一部分であることがあります。全体が遅く動いているのではなく、一部分だけが遅くなって、全体の速度の多くを遅くしているから、そのプログラムは非効率的なのです。これを「ボトルネック」と言います。</p>
<p>プログラムのボトルネックを解消するためには、まずは、重要な部分、特にアルゴリズム部分を見ることです。全体をPythonからCで書き直しても、確かに速度は向上するかもしれません。しかしながら、全体を書き直すことだけでは、「アルゴリズム部分のボトルネック」を解消することができません。アルゴリズムで無駄があった場合、そこがボトルネックになっている場合、低水準言語で書き直すことよりも、まずはアルゴリズム部分に注目して、どのように変えるか、たとえばキャッシュを使ったり並列処理を行ったりすることで効率的にできるか、といったことが肝心になります。</p>
<p>しかしながら、並列処理を行う場合でも、並列処理にできない順序が変えられない処理がもしあったとして、それが全体のボトルネックになっている場合、並列処理だけでは解決しません。キャッシュで効率的になるのは同じデータに繰り返しアクセスする時だけであり、データベースにインデックスをつけるのと同様、間違えれば逆効果になることもあるでしょう。</p>
<p>プログラムを効率的にするためには、まずはアルゴリズムを考えましょう。二分探索木を使うなどのデータ構造的な設計や実装を変えたりすることでも高速化することはあります。</p>

<h2>高速化とボトルネック</h2>
<p>ソフトウェアを高速化する際には、ボトルネックとなっている部分を探します。</p>
<p>ボトルネックとは「瓶の首」の意味で、その部分が全体のほとんどの速度を制限しているような部分のことです。</p>
<p>たとえば、以下にRubyの作者まつもとゆきひろによるRuby三倍高速化についてのインタビュー記事があり、参考になります。</p>
<ul>
<li><a href="https://logmi.jp/tech/articles/320752">Ruby3が目指すのは“3倍速”　まつもとゆきひろ氏が語る「プログラミング言語サバイバル」とRubyの未来 - Part2 - ログミーTech</a></li>
</ul>
<p>また、プログラムの実行時間の50%はコードブロックの4%以下の部分に集中しているとする、クヌース先生の論文は有名である。</p>
<ul>
<li><a href="https://www.sophia-it.com/content/%E3%83%9C%E3%83%88%E3%83%AB%E3%83%8D%E3%83%83%E3%82%AF">ボトルネックとは (bottleneck)： - IT用語辞典バイナリ</a></li>
</ul>
<p>クヌース先生は「早すぎる最適化は諸悪の根源」（最適化は時期を見て行うこと）などとも言っていて、勉強になる。</p>
<ul>
<li><a href="https://qiita.com/shuetsu@github/items/95370b6c208901db3a5e">「早すぎる最適化は諸悪の根源」について - Qiita</a></li>
</ul>

<h2>陰気臭いことをやっているように見えて、文句を言わず正確にやってくれる</h2>
<p>文字をひとつひとつ比較するなど、なんて陰気臭いことをやっているのだろうと、思われるかもしれません。</p>
<p>ですが、コンピュータは、どんなに細かいことであっても、文句を言わず正確にやってくれます。</p>
<p>また、たくさんのデータがあった場合も、すべてのデータに対して正確に処理を行ってくれます。</p>
<p>それから、再利用性があります。一度きちんと動くロジックを書いてしまえば、二度同じことを書く必要はありません。ひとつに対する正しいロジックを書けば、それを再利用してすべてに対するサブルーチンとすることができます。</p>
<p>文字をひとつひとつ比較するロジックであったとしても、それを正確に、間違えることなく、そして大量に行ってくれると考えれば、きちんと書く価値はあります。</p>

<h2>書籍</h2>
<p>以下の書籍が参考になります。</p>
<ul>
<li><a href="https://www.amazon.co.jp/dp/4295002666/">徹底攻略 応用情報技術者教科書 平成30年度</a></li>
</ul>

<h1>余談</h1>
<h2>プログラミング言語はアルゴリズムを書くためにある</h2>
<p>僕がプログラミングができないのは、アルゴリズムが書けないからです。</p>
<p>プログラミング言語は、仕様を学ぶためにあるのではなく、アルゴリズムを書くためにあります。</p>
<p>変数を定義して代入したり加算したり、if文やfor文で制御機構を作ったり条件式を比較したりするのは、それ自体の意味を学ぶためではなく、アルゴリズムを書くためにあります。</p>
<p>そして、僕はそうしたアルゴリズムを書くことができないせいで、プログラミングのマスターから遠ざかっています。</p>
<p>皆さんは、僕のように、学ぶだけでアルゴリズムを書くことができない人間には決してならないようにしてください。</p>
<p>僕は、今から、アルゴリズムを書く術を学びます。技術とは名前の通り「技」と「術」であり、決して勉強して分かるだけがパソコンの学習の目的ではありません。皆さんは、僕のようにならず、アルゴリズムを書く術をきちんと身に着けるようにしてください。</p>
<div class="edit_date">
<p>2023.09.27</p>
</div>

<h2>コンピュータはただの機械</h2>
<p>結局、コンピュータはただの機械です。</p>
<p>コンピュータは、アルゴリズムを計算する機械であり、そのアルゴリズムの計算は、普通のアナログな機械が動くのと何も変わりません。</p>
<p>アルゴリズムは、機械的に、条件が満たされるまで同じ計算を繰り返す、ということを行うだけです。</p>
<p>物質的な機械をハードウェア、プログラムをソフトウェアと呼ぶのは、ソフトウェアはハードウェアと違って具体的な物質的な装置を持ちませんが、やっていることはソフトウェアもハードウェアも変わらないからです。</p>
<p>機械的なモーターや歯車を使ったハードウェアが動くのと、電子頭脳的なソフトウェアが動くのは、何も変わりません。両者ともに同じ機械だから、「ハードウェア」「ソフトウェア」という似たような名称を付けただけです。</p>
<p>アルゴリズムは、それを理解するのが難しいだけで、一度理解してしまえば、その理解に基づいて、正しく論理的に記述するだけできちんと動きます。</p>
<p>アルゴリズムの基本は「状態を変更する」ということです。そのプログラムの中で状態を保持し、その状態を目的の結果になるまで変更処理をし続ける、これがコンピュータという言葉の意味する「計算」なのです。</p>
<div class="edit_date">
<p>2023.09.30</p>
</div>

<h2>本気でやれば僕でもアルゴリズムは書ける</h2>
<p>このホームページを見ると、僕は情報の基本的な知識はあるが、アルゴリズムの書けない人間だと思われるだろう。</p>
<p>だが、実際、本気でやれば、僕であってもアルゴリズムは書ける。</p>
<p>アルゴリズムを書くために必要な基本の知識は、変数の宣言・定義と参照・代入、そして条件分岐や反復のような構造化プログラミングであって、それらの知識は僕は既に知っている。</p>
<p>実際、アルゴリズムの本をきちんと読めば、アルゴリズムを書けるようにはなる。だが、本当にやりたいのであれば、勉強して書くのではなく、自分で考えて、頭を使って試行錯誤して書いたほうがいい。</p>
<p>僕ぐらいの知識がある人間なら、それは本気になればできる。だから、本を買うよりも、本気できちんとアルゴリズムを実装しようとすればいい。それが今後の課題である。</p>
<div class="edit_date">
<p>2025.06.13</p>
</div>

<h1>リンク集</h1>
<h2>基本</h2>
<p>アルゴリズムとデータ構造は、実際の高度なプログラミングの基本を掴むために、学んでおくと良いでしょう。</p>
<ul>
<li><a href="https://www.codereading.com/algo_and_ds/">アルゴリズムとデータ構造 - ソースコード探険隊</a></li>
<li><a href="https://qiita.com/GushiSnow/items/70765a7cae52c0a1b2b8">残業したくないあなたに：データ構造とアルゴリズム - Qiita</a></li>
</ul>

<h2>アルゴリズムとデータ構造</h2>
<p>アルゴリズムとデータ構造。</p>
<ul>
<li><a href="http://www.atmarkit.co.jp/fcoding/index/algorithm.html">コーディングに役立つ！ アルゴリズムの基本</a></li>
<li><a href="http://www.atmarkit.co.jp/ait/subtop/coding/">Coding Edge : プログラミングに誇りを感じるヒトのための技術情報フォーラム</a></li>
<li><a href="http://www.codereading.com/algo_and_ds/">アルゴリズムとデータ構造 - ソースコード探検隊</a></li>
<li><a href="http://vipprog.net/wiki/algo_and_data_const.html">アルゴリズムとデータ構造 - プログラミングスレまとめ in VIP</a></li>
<li><a href="http://fussy.web.fc2.com/algo/index.htm">アルゴリズムの紹介 - Fussy's HOMEPAGE</a></li>
</ul>






</div></div> <!--page-->










<script type="text/javascript" src="../../js/jquery.toc.js"></script>
<script type="text/javascript" src="../../js/script.js"></script>
<script type="text/javascript" src="../../js/scriptfortoc.js"></script>
</body>
</html>