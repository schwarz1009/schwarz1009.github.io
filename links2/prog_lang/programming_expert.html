<!DOCTYPE html>
<html dir="ltr" lang="ja">
    <head>
        <title>プログラミング作法の世界観３（エキスパート） - from Assy</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="keywords" content="Assy,アッシー,詩,小説,物語,歴史,政治,経済,コンピュータ,パソコン,Linux,エッセイ,散文,哲学">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="../../css/style.css">
        <link rel="stylesheet" href="../../css/prettify.css" type="text/css">


<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">

    </head>
    <body>
<div class="page">
<script type="text/javascript" src="../../js/jquery.min.js"></script>
<script type="text/javascript" src="../../js/script_smartmenus.js"></script>
<script type="text/javascript" src="../../js/links2.js"></script>

<p><a href="index.html">プログラミング言語の世界観に戻る</a></p>
<div class="sidebar">
<iframe src="../../menus/prog_lang_skill_menu.html" class="sideiframe"></iframe>
</div>
<h1>プログラミング作法の世界観３（エキスパート）</h1>
<p>プログラミング作法に関する世界観３（エキスパート）です。</p>

<h2>関連ページ</h2>
<ul class="defaultlist list6 menu_list">
<li><a href="programming_intro.html">プログラミングをはじめよう</a></li>
<li><a href="programming_basic.html">プログラミング作法（１．基本）</a></li>
<ul>
<li><a href="programming_method.html">２．プログラミング入門</a></li>
<li><b>３．エキスパート</b></li>
<ul>
<li><a href="programming_flow.html">３A．制御フロー</a></li>
<li><a href="programming_data.html">３B．データ操作</a></li>
<li><a href="programming_pointer.html">３C．ポインタとメモリ管理</a></li>
</ul>
<li><a href="programming_tech.html">４．テクニック</a></li>
</ul>
</ul>

<div id="toc"></div>
<div class="page_links">

<h1>プログラミングエキスパートを目指して</h1>
<h2>プログラミングのコツは、設計、再利用、開発手法</h2>
<p>プログラミングのコツは、設計、再利用、開発手法です。</p>
<p>まず、プログラミングの世界では、コードを書いている時間は、全体の時間のほんの数割にすぎません。</p>
<p>システムを構築する上では、コードを書いている時間よりも、そのシステムを「考えている時間」のほうが、多くを占めます。</p>

<h3>設計</h3>
<p>プログラミングの手法についてまず言えるのは、「コードを書く前にきちんと設計しろ」ということです。</p>
<p>確かに、プロトタイプを作ってそれを改良していくような手法もあるにはありますが、それは例外的であり、実際のプログラミングでは、コードを実装するよりも前に全体の設計を考えます。</p>
<p>どのようなデータ構造を使うのか、クラスのそれぞれのやり取りや継承・包有の関係をどのように行うのかを考え、制御のモデルに何を採用し、ユーザーインターフェースはどのようになり、プログラムでは詳細にどんな機能を必要とするのか、プログラムはどのようにモジュール化されるのか、ということを、「作るよりも以前に考える」ということが必要です。</p>
<p>きちんと設計されていないプログラムは、作っても動きません。作って動くプログラムを開発するためには、「作る前に設計をする」ということが必要です。</p>

<h3>再利用</h3>
<p>次に、プログラミングの手法について言えるのは、再利用することです。</p>
<p>すべての会社で開発するプログラムが、そのプログラムのためにオリジナルで書かれているかというと、それはそうでもありません。</p>
<p>以前に作った機能と同じ機能を実装するためには、再利用性を考える必要があります。</p>
<p>コンポーネントを再利用するということは、単にコードを流用して埋め込むだけではありません。オブジェクト指向の考え方を用いた、再利用可能なコンポーネントを事前に開発しておき、どんな場合においてもそのコンポーネントを汎用的に利用できるようにします。</p>
<p>これは、自社で開発する場合だけではありません。たとえばRubyのgemsのように、ネット上に存在するさまざまなモジュールを使うということも考えられます。</p>
<p>このようにすることで、元のコンポーネントを流用し、ゼロ秒でシステムを開発できます。</p>

<h3>開発手法</h3>
<p>最後に、プログラミングについて重要なのは、コードではなく、開発手法です。</p>
<p>これはすなわち、プロジェクトマネジメントです。プロジェクトをどのように成り立たせるか、ということです。</p>
<p>システム開発は、通常、上流工程でシステムエンジニアが大まかな設計をし、設計が固まった段階で、下流工程の「コードだけを書くプログラマ」へと流れていき、プログラマが具体的なコードを言われたとおりに実装していくことで成り立ちます。</p>
<p>システム開発は、コードを書く前に設計すべきであるとは先にも言いましたが、通常は設計をベテランのシステムエンジニアがし、詳細な実装は若いコーディング専門のプログラマにさせます。</p>
<p>プログラミングは、このように成り立ちます。</p>

<h2>プログラムを書くための基盤となるプログラムを書く</h2>
<p>プログラミングについて言えることは、目的とするプログラムだけを書くのではなく、そのプログラムに必要なベースとなるプログラムをあらかじめ書いておくということです。</p>
<p>これは、どんなクラスにおいても必要となる、基盤となる仕組みやフレームワークを、あらかじめ書いておき、そのプログラムをどんなプログラムでも再利用するということです。</p>
<p>たとえば、やねうらお氏の以下の書籍には、C++で開発する上での、スマートポインタやマイクロスレッドなどを始めとする、主にゲームのための、しかしながらゲーム以外の開発にも使えるような、汎用的なテクニックが紹介されています。</p>
<ul>
<li><a href="https://www.amazon.co.jp/Windows%E3%83%97%E3%83%AD%E3%83%95%E3%82%A7%E3%83%83%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%82%B2%E3%83%BC%E3%83%A0%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-%E3%82%84%E3%81%AD-%E3%81%86%E3%82%89%E3%81%8A/dp/479800314X">Windowsプロフェッショナルゲームプログラミング</a>（やねうらお）</li>
<li><a href="https://www.amazon.co.jp/Windows%E3%83%97%E3%83%AD%E3%83%95%E3%82%A7%E3%83%83%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%82%B2%E3%83%BC%E3%83%A0%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B02%E3%80%90CD-ROM%E4%BB%98%E3%80%91-Game-developer-books-%E3%81%86%E3%82%89%E3%81%8A/dp/4798006033">Windowsプロフェッショナルゲームプログラミング2</a>（やねうらお）</li>
</ul>
<p>そのように、プログラムとは、最初から最後まですべてそのプログラムのために書くのではなく、ある程度の「プログラムを書く仕組み」を作っておいた上で、その仕組みを使ってプログラムを書いていく、という方法をよく使います。</p>
<p>これは、C++のゲームプログラミングだけではなく、たとえばRuby on RailsのようなWebプログラミングについても言えることです。あらかじめWebに必要な機能をRailsというフレームワークに持たせておいた上で、Railsを使って具体的なWebサービスを作るのです。</p>
<p>また、Lispという言語には、「Lispを拡張することで、プログラミング言語そのものを自分で作っていく」という発想があります。これはLispハッカーのポール・グレアム氏の述べていることであり、LispプログラマはLispそのものを拡張して、Lispを自らの理想に近い言語に仕立て上げていき、その言語を用いてプログラミングを行うのです。</p>

<h2>計画は完璧じゃないし、人間は全知全能じゃない</h2>
<p><a href="https://www.amazon.co.jp/ANSI-Common-Lisp-%E3%82%B9%E3%82%BF%E3%83%B3%E3%83%80%E3%83%BC%E3%83%89%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88-%E3%82%B0%E3%83%AC%E3%82%A2%E3%83%A0/dp/4894714337">ANSI Common Lisp (スタンダードテキスト)</a>で言われているように、計画が完璧であり、人間が全知全能であることを前提にプロジェクトを実行しようとしてはいけません。</p>
<p>まずプランがあり、次にインプリメントがあるというモデルでは、プランが完全に完璧な計画で行われることが前提であり、また、人間が間違いを絶対に犯さないことが前提となりますが、これは絶対にありえません。</p>
<p>人間が間違いをするものだ、ということを前提に考えなければ、ことさら人間が間違えやすいプログラミングの世界では、適切にプロジェクトマネジメントをすることはできません。</p>
<p>最初から計画にも流れにも間違いがあるものであるとし、その間違いが起きたとしてそれを修正するコストが一番低くなるように、プロジェクトのやり方を考えるべきなのです。</p>
<p>この書籍では、そのためにLispの持つ特性は有用であると述べられていますが、「人間は間違いを犯すものであり、計画が完璧であると考えるな」とすることは、どんなプログラミング言語にも、どんなプロジェクトであっても大切な原則であると思います。</p>
<p>計画だけの話ではなく、いったん作ったものが失敗作になった時、それを修正するのに多大なコストがかかるというのは地獄です。できるだけ、どんな間違いや失敗があってもそれを修正するコストが最低になるようにするべきです。</p>

<h2>いきなりコードで考えるな</h2>
<p>僕が思うに、プログラムの設計を行う上でのコツは、「いきなりコードで考えないこと」です。</p>
<p>いきなりコードで考えると、どうでもいい雑多な細かいことを考えなければいけません。</p>
<p>そうではなく、まず、もやもやした概念的なイメージを考え、そのイメージを実際にどのように実現すればいいか、ということを抽象的に考えるのです。</p>
<p>プログラムの全体の構造を、大まかに想像力で考えて、それをどのように設計すれば、プログラムが上手く書けそうか、ということをまず考えて、その上でコードを書くべきなのです。</p>
<p>なので、最初の時点では、コードではない形で、もやもやした概念的なイメージを考えましょう。そこから正しい設計が生まれるのです。そして、その設計通りにプログラムを記述すればいいのです。</p>
<p>また、設計をする上で効果的なのは、既にあるプログラムに付け足したり付け替えたりといったことを考えることです。なんらかの単独のプログラムがあって、そのプログラムを別の場所から使ったり、あるいはプログラムの内容に別のプログラムの内容を付け加えたり付け替えたりということを考えます。そのように考えることで、機械部品を作るようにプログラムが成り立ちます。かっこいい言葉で言えば、「コンポーネント指向の考え方をする」ということが大切なのです。</p>
<div class="edit_date">
<p>2023.01.09</p>
</div>

<h2>APIを作ってそれを呼び出すだけでプログラミングはできる</h2>
<p>プログラミングという作業は、そんなに難しくありません。</p>
<p>プログラミングの基本は、「APIを作ってそれを呼び出す」ということです。</p>
<p>たとえば、Webサービスを作るのであっても、GUIアプリケーションを作るのであっても、まず最初に取り掛かるべきことは「APIを作ること」です。</p>
<p>APIの中で、データベース処理をしたり、UIの表示処理をしたり、ファイル処理をしたり、共有されるデータを変更・参照したり、アルゴリズムを書いたりします。</p>
<p>そして、そのAPIを、適切な場所から適時に呼び出せば、それだけでプログラミングはできます。</p>
<p>そう、APIを作ってそれを呼び出すだけで、プログラミングは簡単にできるのです。</p>
<p>後日注記：APIを作る上で、どのメソッドからも共有される「共有データ」が必要になります。そのため、オブジェクト指向の考え方を用いて、ひとつの「オブジェクト」として、共通に使われるデータを共有します。オブジェクトは複数作成できます。また、完璧なひとつのオブジェクトを作るのではなく、オブジェクト同士でインターフェースを使って連携させることもあります。</p>
<p><a href="oop.html">オブジェクト指向</a>も参照のこと。</p>
<div class="edit_date">
<p>2023.03.18-19</p>
</div>

<h2>裏にデータがあってそれを表示する</h2>
<p>プログラミングの基本は、データの保持とビュー画面への表示です。</p>
<p>ビュー画面にデータを表示しながら、その裏でデータ要素を保持し、データとビュー画面の再描画や同期を行うことで、ペイントソフトであっても、Webブラウザであっても、あるいはゲームやモバイルアプリであっても、どんなアプリケーションでも開発できます。</p>
<p>ですが、それだけだと、アプリケーションを終了した時にデータが失われてしまいます。なので、データを永続化するために、ファイルの読み書きやデータベースへのデータの格納と参照を行います。</p>
<p>プログラミングは、一見高度なアルゴリズム処理をやっているように見えますが、それは一部であり、基本的に必要なのはビュー画面に項目を表示しながら裏でデータを保持することです。MFCやMVCフレームワークなどはそのようなことを助ける基盤を提供します。</p>
<div class="edit_date">
<p>2023.09.10</p>
</div>

<h2>権威ある本（名著）を読め</h2>
<p>X（旧ツイッター）で、「リーダブルコードを読んだことがないやつはプログラマとして論外」とするポスト（ツイート）が話題になっています。</p>
<ul>
<li><a href="https://twitter.com/igz0/status/1700855015517442555">@igz0さんのツイート</a></li>
</ul>
<p>ですが、僕が思うに、本当にプログラマとして優秀になりたいのであれば、そういう権威ある本は読んだほうがいいです。</p>
<p>たとえば、以下のリンクでは、プログラマとして読むことがおすすめの名著が掲載されています。</p>
<ul>
<li><a href="https://tech-blog.rakus.co.jp/entry/20200318/programming-book">【2020年】史上最もおすすめされているプログラミング本【25選】 - RAKUS Developers Blog | ラクス エンジニアブログ</a></li>
</ul>
<p>あるいは、MINIX本の巻末にある参考文献には、OSやカーネルを作るための重要な参考となる書籍が掲載されています。</p>
<ul>
<li><a href="https://www.amazon.co.jp/%E3%82%AA%E3%83%9A%E3%83%AC%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E2%80%95%E8%A8%AD%E8%A8%88%E3%81%A8%E7%90%86%E8%AB%96%E3%81%8A%E3%82%88%E3%81%B3MINIX%E3%81%AB%E3%82%88%E3%82%8B%E5%AE%9F%E8%A3%85-S-%E3%82%BF%E3%83%8D%E3%83%B3%E3%83%90%E3%82%A6%E3%83%A0/dp/4894710471">オペレーティングシステム―設計と理論およびMINIXによる実装</a></li>
</ul>
<p>もっと一般的な本が知りたいなら、「ふつうのLinuxプログラミング」の第18章にある「本書を読み終えたあとは」が参考になります。</p>
<ul>
<li><a href="https://www.amazon.co.jp/%E3%81%B5%E3%81%A4%E3%81%86%E3%81%AELinux%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-Linux%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B9%E3%82%8Bgcc%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E7%8E%8B%E9%81%93-%E9%9D%92%E6%9C%A8-%E5%B3%B0%E9%83%8E/dp/4797328355">ふつうのLinuxプログラミング Linuxの仕組みから学べるgccプログラミングの王道</a></li>
</ul>
<p>そのように、プログラミングの世界には、読むことが必須であるような「名著」がたくさんあります。</p>
<p>いつまでも、初心者向けの言語やフレームワークの入門書だけを読んで、分かった気になっていても、一流のLinuxハッカーになることはできません。</p>
<p>本当に優れた優秀なエンジニアは、そのような「名著」を読んでいます。なので、そのような権威ある名著を読むことで、一流のLinuxハッカーになることができます。</p>
<div class="edit_date">
<p>2023.09.11</p>
</div>

<h2>OSやシステムの仕様を学ぶことと、与えられた条件から目的の機能を作ることの両方が必要</h2>
<p>プログラミングにおいては、「OSやシステムの仕様を学ぶこと」と、「与えられた条件から目的の機能を作ること」の、両方が必要です。</p>
<p>OSやシステムの仕様とは、たとえばUNIXのAPIやC/C++言語の言語・ライブラリAPIなどの仕様のことです。</p>
<p>与えられた条件から機能を作るとは、たとえばネットワーク接続環境において、どのようにしてリモート環境からコマンドを実行するようなシェルを開発するか、といった方法論のことです。</p>
<p>プログラミングにおいては、そのような、「仕様に習熟しておくこと」と、「やるべき機能に応じてどのように作ればいいかという方法論を知っておくこと」の二つが必要となります。</p>
<p>これはすべての場合について言えます。UNIXのAPIだけではなく、XlibやGTKやQtのようなライブラリのAPIを知っておくことも重要です。また、ゼロから機能を作る上で、すべてを自分で考えて作るのではなく、「掲示板の作り方のセオリー」や「コンパイラの作り方のセオリー」のように、セオリー通りに作る方法を知っておくことも必要となるでしょう。</p>
<p>この二つの方法が合わさって、はじめてプログラミングのエキスパートになれるのです。</p>
<p>SSHの開発とUNIXプログラミングについては、<a href="../linux/linux_ssh.html">SSH</a>も参照のこと。</p>
<div class="edit_date">
<p>2024.06.18</p>
</div>

<h1>プログラミングとは</h1>
<h2>プログラミングは情報処理</h2>
<p>結局、プログラミングとは何か。プログラムを作ることで、何が出来るのか。</p>
<p>その答えは、「情報処理」です。</p>
<p>プログラミングとは、情報に対して処理を行うということです。</p>
<p>情報とは、数値、文字、データ、入出力、ヒューマンインターフェース、視覚や聴覚などのマルチメディアを操作する、ということです。</p>
<p>コンピュータに与えるものは情報であり、処理するのも情報であり、人間に対して結果を返すのも情報です。</p>
<p>コンピュータ科学のことを、「情報工学」ということがあります。これは、「情報をやり取りするということがコンピュータ科学だから」という意味だと僕は思います。</p>
<p>これは何も、デスクトップやラップトップの場合だけではありません。たとえば体重計に供えられたICチップや、組み込みコンピュータの場合でも同じです。情報を与えられて、計算やデータ処理を行い、その結果となる情報を返す、これがコンピュータの基本です。</p>
<p>また、情報は単純にローカルにあるとは限りません。情報がメモリにあるか、ストレージにあるか、ネットワーク上にあるかは分かりません。このような「どこかにあるデータ情報」をやり取りすることがまず第一です。</p>
<p>そして、プログラミングとは何なのか。それは、「情報をやり取りする過程となるプロセスやロジックを書くこと」です。すなわち、プログラムとは「この情報をこのように処理します」という決まり事なのです。</p>
<p>プログラミング言語とは、すなわち「情報のやり取りを記述する記法的な道具」であると言えます。</p>
<p><a href="computer_science.html">コンピュータ科学</a>も参照のこと。</p>

<h2>プログラミングの発展</h2>
<p>WindowsやMacのようなGUIのOS環境は、書類をファイルとして保存し、アプリケーションから編集する、という「人間の視覚に訴えかける」インターフェースを採用しました。これにインターネットなどのネットワーク機器が合わさって、日常でニュースの取得やメッセージのやり取りもできるようになりました。</p>
<p>コマンドで操作する従来のUNIXのようなOSは、これに対して、自動化やバッチ処理が容易であるという特徴がありますが、GUI操作であっても、最近では、RPAのように、人間がする操作をロボティックに自動化することもできます。</p>
<p>このようなOSの進歩と同時に、プログラミング言語の進歩も考えられます。</p>
<p>アセンブラでは、機械語をそのままニーモニックにすることで、人間が読みやすくし、計算機としての（電卓+記憶的な）単純さが残っています。</p>
<p>FORTRANやCOBOLでは、より人間の記述しやすい形で抽象化され、人間の読みやすい変数定義や条件分岐などを使うことができ、フォーマット入出力のようなことを簡単にできる機能がありますが、行番号を使ったgotoなど記述が原始的なところがあります。</p>
<p>Cなどでは、記述がより構造化し、ネストされたブロック（ALGOLに由来する）による条件分岐・繰り返し文や関数やサブルーチンを使うことができますが、C++に比べると、オブジェクト指向プログラミングの機能がないか劣っています。</p>
<p>C++では、Cに対してクラスベースのオブジェクト指向を用いることができますが、ガーベッジコレクションなど、速度や効率を犠牲にする重要なオブジェクト指向の機能がありませんでした（少なくとも長い間。今ではスマートポインタがある）。また、C++の仕様は、とても巨大かつ難解です。</p>
<p>これに対して、C++をすっきりとさせながらオブジェクト指向言語として使いやすいものにしたのがJavaです。C/C++では長い間プラットフォーム依存だったマルチスレッドの機能も、Javaでは標準で用意されました。</p>
<p>また、もっと手軽で書きやすい、少ない行で書くことのできるスクリプト言語としては、Perl, PHP, Python, Ruby, JavaScriptなどがあります。</p>
<p>また、そのような手順を手続きとして書き記す、手続き型言語とは一線を画す、より数学的かつ抽象的であることで知られる関数型言語としてはLispやHaskellなどがあります。</p>
<p>このように、OSとプログラミング言語は少しずつ進歩・発展しました。しかしながら、「情報を人間から受け取り、情報を処理し、情報を人間に返す」ということは変わっていません。</p>
<P><a href="programming_languages_intro.html">プログラミング言語入門</a>も参照のこと。</p>

<h2>プログラムは書いた通りにしか動かない</h2>
<p>プログラムは、書いた通りにしか動きません。</p>
<p>バグのない正しいコードは、バグのない正しい動き方をします。バグのある間違ったコードは、バグのある間違った動き方をします。</p>
<p>決して、正しいコードが間違った動き方をしたり、間違ったコードが正しい動き方をすることはありません。</p>
<p>ですが、テストが大切です。なぜなら、「自分の少ない実例では正しい動き方をしているように見えても、さまざまな実例においては想定外のバグがでる」ことがあるからです。</p>
<p>実際のところ、コンパイルエラーでコンパイル・実行ができないのは、まだ間違いとしては可愛いもので、コンパイルが通って実行もできるが、それでバグがあるのが一番困ります。</p>
<p>また、セキュリティには「公開の原則」があります。すなわち、セキュリティを確保するためにコードを非公開にするのではなく、コードをあえて公開して万人の目に見えるようにした上で、みんなでバグを発見して直すことでソフトウェアは正常に動くことが可能となります。</p>
<p>また、公開の利点はもうひとつあります。それが「どこに問題があるか特定できる」ことです。非公開のOSは、もし問題がOS側にあったとしても分かりません。いつまで探しても、どこにも問題がなければ、OSのバグかもしれません。公開することで、どこに問題があるか特定できます。すべてのソースコードがオープンならば、すべてのコードをしらみつぶしに見ればどこに問題があるかを特定できるのです。</p>

<h2>ある程度のプロトタイプを作ってそれを改良する</h2>
<p>プログラミングだけではなく、デザインや執筆についても言えることとして、「ある程度のプロトタイプ」を作ってそれを改良する、ということが有効です。</p>
<p>たとえば、ブログを作るのであれば、最初のうちは何の機能もない、最低限投稿と一覧ができるだけのブログで構いません。</p>
<p>最低限の機能が作れた段階で、「そこまでで終わり」にし、また、思いついたらそのプログラムを改良していけばいいのです。</p>
<p><a href="agile.html">アジャイル</a>や<a href="oss_develop.html">オープンソース開発</a>も参照のこと。</p>

<h2>データがあってプログラムがある</h2>
<p>プログラムについて言えることは、「データがあってプログラムがある」ということです。</p>
<p>外部にデータファイルがあって、それと対応するプログラムがあります。プログラムの中ではデータに対する一般的な処理（手続き）を記述します。変数などは、プログラムがプログラムの中で一時的に保持する記憶です。</p>
<p>また、プログラムについてもうひとつ言えることは、「自動の実行処理」であるということです。テキスト処理であっても、ネットワーク処理であっても、GUIのプログラムやビューであっても、すべては汎用的な自動処理、すなわち手続きであると言えます。</p>
<p>このように、プログラミングを行う上では、データとプログラムを対応付けし、データに対してプログラムが一般的手続きを実行すること、そしてすべてのプログラムは自動処理であることを分かっておくといいでしょう。</p>
<p><a href="code_file.html">コードとファイル</a>も参照のこと。</p>

<h2>ビット情報と命令の構築</h2>
<p>簡単に言えば、コンピュータのハードウェアは、1か0かのビット情報を演算していますが、人間であるプログラマは、この情報処理の命令の構築を考えます。</p>
<p>ビット情報とは、たとえば8ビットなら、00001111のように、1か0かの1ビットの情報を、桁の分だけ（ここでは8ビット）持ち、これによって数値や文字、計算命令を表したり、ビット列を変更することで値に対する計算や記憶を行う、ということです。</p>
<p>CPUやメモリなどのコンピュータのハードウェアは、このビット情報を演算することができます。8ビットの情報が扱いやすいため、8ビットを1バイトとします。</p>
<p>ハードウェアがビット情報を計算しているとして、人間であるプログラマは何をしているかというと、「命令の構築」、すなわち「どのような命令文を組み立てるか」ということをしています。</p>
<p>プログラマは、命令が処理される「順番」がどのように変化するか、すなわち、命令をどのように構築し、どのような計算をさせることで、さまざまな便利な機能を計算機を用いて実現するか、ということをしています。</p>
<p>最近のコンピュータは、高水準のプログラミング言語や、すべてのプログラムに必要な基本的処理を行うOSが付属していますが、基本的にそれらも含めて、ビット演算をハードウェアが行い、その命令文をプログラマが記述する、ということは変わりません。</p>
<p>しかしながら、なかなか機械語やアセンブリ言語で計算内容を組み立てるのは至難の業です。アセンブラが書ける人はかっこいいですが、普通のエンジニアはC/C++やPythonなどの「高水準言語」を使って命令文を組み立てることになります。この命令文が、コンパイラ言語であれば機械語に変換されて実行されます。あくまで、命令文をもっと人間の分かりやすい言語で書く仕組みであり、命令文を書かなくてもいいわけではありません。</p>
<p><a href="../hardware/cpu.html">CPU</a>や<a href="../hardware/memory.html">メモリ</a>や<a href="assembly.html">アセンブリ言語</a>も参照のこと。</p>

<h2>コンポーネントが開発できることが理想</h2>
<p>結局のところ、コンポーネントが開発できることが、プログラマにとっての理想かもしれません。</p>
<p>プログラマにとって、ソフトウェアは大きく、カーネルと、それ以外のユーザーランドのソフトウェアに分かれます。</p>
<p>外部から見て、アプリケーションソフトは高度かつ巨大に見えますが、実際は言語とOSの機能を使うだけであり、基本的にはカーネルを使うだけです。</p>
<p>これに対して、カーネルは、外部からは見えませんが、内部ではほとんどすべてをやっています。</p>
<p>ですが、カーネルや言語のような低レベルシステムは、低レベルすぎるため、自分で書く必要はありません。</p>
<p>C#のWindows.Formsのような高レベルな言語は、高レベルであるため生産性が高く、むしろ簡単に作れ過ぎて、実際の技術的なスキルとしては何もしていないだけになってしまいます。</p>
<p>このような中で、もし、ひとつのプログラマの主戦場をあげるとしたら、たとえばWebブラウザのFirefoxのような、大きなアプリケーションソフトを書くことが挙げられるでしょう。</p>
<p>しかしながら、このようなアプリケーション開発では、使うことと作ることは同じです。Firefoxを作るために必要なのは、さまざまな技術を使うこと、あるいはさらに低レベルなシステムを使ってその技術を独自に開発することです。</p>
<p>逆に、Firefoxを作ることよりも、使うことのほうが賢いかもしれません。インフラは、作るだけではなく、使って何かをすべきです。</p>
<p>このようなことは、RubyやPythonのようなサーバーサイドのWeb技術について言えます。</p>
<p>結局、カーネルだけが例外的に賢いだけにすぎず、C#のWindows.Formsエンジニアは、何もしていないように見えて、普通のプログラムを書いている一般的なまともなエンジニアなのです。PHPやRubyのエンジニアも同じで、言語とOSの機能を使うだけで、実質的に何もしていないからといって、自分を卑下する必要はありません。</p>
<p>なぜなら、カーネルや低レベルシステムが例外的に賢いだけにすぎず、それらを自分で書くことは困難を極めるか、多くの場合不必要だからです。MS製品やオープンソース製品を使うことは悪いことではありません。</p>
<p>こうしてみた時、理想とはなんでしょうか。それは、たとえばDelphiやVisual C++やC#などを用いて、Windowsのコンポーネントが作れたりすること、あるいは、RubyのgemsやPythonのモジュールが書けることではないでしょうか。</p>
<p>たとえば、Windowsには、低レベルなOSだけではなく、さまざまなコンポーネントがあります。たとえば、IEコンポーネントなどがその例として言えます。そして、IEコンポーネントは、COMコンポーネントの集合体として作られています。</p>
<p>Windowsだけではなく、GNOMEなどでも、再利用可能なコンポーネントは重視されます。GNOMEの創始者ミゲル・デ・イカザ氏などは、UNIXにおける再利用可能なコンポーネントの重要性をGNOMEとCORBAを論じる論文の中で主張しました。</p>
<p>そう、結局のところ、プログラミングで重要かつ賢いのは、コンポーネントを書くことであると僕は思います。そして、Windowsにおいては、ActiveXとCOMでコンポーネントが開発できること、それが理想ではないかと僕は思うのです。</p>
<p>もしこれがWindowsでない場合、Webであればフレームワークの開発、あるいは言語に近い部分ではgemsなどのモジュールの開発となるでしょう。プログラミングの練習をしたいなら、そういうところから始めていくといいでしょう。優れたgemsは実際に重宝されますし、フレームワークはまだまだ革新的な発想を実現する余地があると思います。</p>
<p><a href="maintenance.html">保守性</a>も参照のこと。</p>

<h2>再利用可能なコアのモジュールやルーチンを注意深く設計する</h2>
<p>僕は本格的なプログラミングの経験がまだまだ浅いので、なんとも言えませんが、プログラミングのコツは、コアのモジュールやルーチンを注意深く設計することにあると思います。</p>
<p>再利用可能な、汎用的かつ一般的なコアのルーチンを書いてしまえば、あとはそれを再利用するだけで、プログラミングは可能です。</p>
<p>コアの部分はほかの雑多な部分から呼ばれるため、コアの部分を注意深く設計してテストすれば、全体の安定性や効率性を高めることができます。</p>
<p>また、クラスにはそれぞれひとつのことをきちんとできる機能を作ります。そして、クラス間のやり取りを考え、それをクラスライブラリにします。</p>
<p>さまざまな流儀はありますが、僕はRailsのように、規定となる抽象的な関係性をまず築いておいて、それを継承して具体的な機能を作っていくように、階層的に低水準のレイヤーから高水準のレイヤーに肉付けしていく方法が一般的でいいと思います。</p>
<p>低水準のレベルで基本的なAPI構造を構築し、アプリケーションはそれを踏まえた上でそれに機能を追加して実装するように作ればいいと思います。</p>
<p>このような手法はデザインパターンの一種として、Template Methodパターンとして知られています。</p>

<h2>標準の汎用ルーチンの使い方を知り、なければ自分で作る</h2>
<p>PythonやRubyなどの言語を使う上で、言語について学び終えた入門者が、プログラムを書く上でするべきことは、プログラムの内容を考えることです。</p>
<p>ですが、プログラムには、「その問題固有の解決方法を記述する」ことと、「汎用的に使えるルーチンを記述する」ということの2つがあると思います。</p>
<p>問題を解決する上で、問題は小部分に分けて考えられます。そして、部分を分けた時に必ず生まれるのが、「この問題を解決するためだけではなく、幅広く多くのことに活用できるような汎用ルーチン」の実装です。</p>
<p>このようなルーチンは、それが専門的な計算などのロジックでなく、一般的なアルゴリズムやデータ構造であれば、言語や標準モジュールに、最初から用意されていることも多いです。多くの場合、言語に付属の標準モジュールを使うことで、このような汎用ルーチンを自分で実装することなく利用することができます。</p>
<p>このような標準の汎用ルーチンの使い方を知ることは、プログラミングに有益ですが、すべてのAPIを暗記することはできません。なので、最低限必要なもの以外は、その都度Googleなどで検索して調べて使うことになります。</p>
<p>そして、汎用ルーチンがもしなかったとしても、諦めてはいけません。そのルーチンを自分で作ればいいのです。</p>
<p>言語における標準のAPIは、汎用的ではありますが、単純なAPIが多く、それを使うだけでは目的の問題が解決できないようなことは多々あります。</p>
<p>このような場合に、諦めるという選択肢はよくありません。なぜなら、JavaやPythonのようなオブジェクト指向言語は、そもそもクラスの継承などを行うことで、標準で存在しない機能の拡張を自分で開発することができるからです。</p>
<p>よって、標準のAPIでできないことがあっても、諦めることなく、「もともとのクラスを利用して自分で継承して作る」という姿勢を持つといいでしょう。</p>

<h1>プログラミングの基本</h1>
<h2>SEの仕事は問題を解決すること</h2>
<p>システムエンジニアの仕事は、「問題を解決すること」です。</p>
<p>まず、要求されている問題を明確に定義します。顧客の要求を考えたり、実際の現場から何が問題として求められているのかを考えます。</p>
<p>そして、どのようなシステムを構築すれば問題を適切に解決できるかを明確にします。</p>
<p>次に、そのようなシステムをどのようにすれば構築できるかを考えます。</p>
<p>その後に、システムの設計を行い、設計からプログラムを実装し、コードを書きます。</p>
<p>そして、テストし、納品し、システムの保守を行います。</p>
<p>実際のところ「コードを書いている時間よりも、考えている時間の方が多い」とよく言われます。</p>
<p>また、プログラミングとは、「問題を解決する」ことそのものです。どのように計算し、操作し、処理し、実行すれば問題の「ソリューション」（解決方法、答え）を与えられるかを考えるのです。</p>

<h2>数値の変換</h2>
<p>プログラミングにおいては、「数値の変換」という発想がよく起きる。</p>
<p>たとえば、「入力された文字を人数分表示する」というプログラムがあったとして、ここでは、人数が表示回数に変換されている。</p>
<p>人数が3人居たとして、その3人がそのまま3回になる。このように、「ある数字が別の数字の元になる」。10人居れば10回になる。3×10という単純な計算を、プログラミングではそのように行う。それぞれの人数だけ行うように、それぞれの数を別の数にする。あるいは、条件式や分岐にすることもある。</p>

<h2>プログラムに必要な機能をよく分析しよう</h2>
<p>プログラムを開発するコツは、「プログラムに必要な機能をよく分析すること」です。</p>
<p>たとえば、テキストエディタを作るのであれば、バッファに文字列を格納し、テキストエリアに整形して表示する機能がまず必要です。バッファが更新されたら、ビューも更新しなければいけません。</p>
<p>また、ファイルから読み込む機能、ファイルに書き込む機能も必要です。</p>
<p>また、検索や置換、あるいは比較のような機能があると、テキストエディタらしくなるでしょう。テキストエリアには、キーワードを色分けする機能（シンタックスハイライト）があると良いでしょう。</p>
<p>機能を分類できたら、今度はどのようなクラス設計でそれを実現するかを考えます。まず、バッファをメンバ変数としたエディタークラスを作ります。同時に、シンタックスハイライトとビューの常時更新機能をつけたテキストエリアコンポーネントを作ります。同時に、ファイルを管理する開く・保存機能を作ります。最後に、検索と置換の関数を作ります。これらをまとめて、エディタークラスに実装します。</p>
<p>常時更新機能を実装するには、バッファを編集するのに専用のインターフェースを設けて、テキストエディタにビューを更新する関数を作り、バッファのインターフェースが呼び出されたら、必ずその更新関数が呼び出されるようにします。この更新関数はどこからでも呼び出せるようにして、ファイルを開いたり保存したり、設定を変えた時にも呼び出します。また、シンタックスハイライトを作るには、テキストエディタコンポーネントが表示する処理を行う時に、バッファ読み込みとビューの表示の間に介入して、ひとつひとつのキーワードを解析し、その情報をテキストにタグのような形で付け足して、表示する処理の部分で、テキストに付属された情報の通り、テキストエリアで文字色を変えてフォントを表示するようにします。</p>
<p>そのように、どんな機能が必要かを考えることで、クラスの設計もしやすくなります。</p>

<h2>入念に作っておいて、あとは何度でも再利用できる</h2>
<p>プログラミングを行うよりも、手動で操作した方が簡単にできることは確かにあります。</p>
<p>たとえば、テキストエディタで検索・置換を行ったり、行ごとにカウントして処理したりすることは、確かに手動でも行えます。</p>
<p>しかしながら、プログラムの真価は再利用できることにあります。一度自動化してしまえば、あとは何度でも再利用できるのです。</p>
<p>そのため、テキストエディタを使うところをRubyを使うようにするだけで、作業ははるかに楽になります。たとえば、ファイル一覧を得るPHP/Rubyなどの関数であるglob()などを使うことで、ひとつのファイルだけではなく、多くのファイルを簡単に操作することができます。</p>

<h2>構成や設計を作る能力をつける</h2>
<p>プログラミングを行う上で必要なのは、構成や設計を行う能力です。</p>
<p>たとえば、オンラインショッピングサイトを作るような「やり方」を学ぶことで、学ぶだけではなく実務的なプログラミングができるようになります。</p>
<p>これについては、Railsのようなフレームワークで実際のやり方を学んだり、本を読んでやり方を学ぶこともできますが、以下に挙げるプログラミングスクールに通うのもおすすめです。</p>

<h2>プログラミングスクール</h2>
<p>方法として言えるのは、リナックスアカデミーや侍エンジニア塾やGEEKJOBやプログラマカレッジなどのプログラミングスクールに通うことです。</p>
<p>以下にリナックスアカデミーの評判があるので参考にしてください。</p>
<p>授業料は高いですがリナックスアカデミーの評価はおおむね良しです。お金があるならおすすめします。</p>
<ul>
<li><a href="https://neolog30.com/archives/4451">【辛口評価】リナックスアカデミーの評判は悪い？最悪？リアルな口コミだけを調査した感想｜NANOBLOG</a></li>
</ul>

<h2>アーキテクチャ概念の構築</h2>
<p>また、プログラミングについて言えるのは、「アーキテクチャ概念の構築」です。</p>
<p>たとえば、MozillaのXULや、RailsのMVCフレームワークなどがこれに当たります。</p>
<p>プログラミングは、単に作るものの枠組みを考えてコードを書くだけの作業ではありません。自分の考えたアーキテクチャ概念を「発明」するという仕事なのです。</p>
<p>ですので、ただのコードを書くだけの「コーダー」と呼ばれるエンジニアではなく、アーキテクチャを創造する「アーキテクト」になってください。アーキテクチャを創造するためには、プログラムの全体像の設計や構成ができることに加えて、必要となる技術やプラットフォームやシステムデザインに精通し、プログラミング以外の能力も必要になるでしょう。</p>

<h2>アプリケーションの設計と実装手順</h2>
<p>色んなやり方や色んなプログラムがあるため、一概に「このように開発しろ」とは言わないが、アプリケーションの設計と実装の手順の一例として、以下が参考になるかもしれない。</p>
<p>まず、どのような処理が必要になるか、明確化する。</p>
<p>・データ（あるいはデータ属性）をどのように保管し、参照し、読み書きするのか？ビューの表示機能にどのようにデータを与えるのか？そのためにどのように変換・保持するのか？</p>
<p>・ビューをどのように表示し、レイアウトや再描画をどのようにするのか？ユーザーは表示されたアートワークをどのように（マウスやボタンによって）操作するのか？</p>
<p>・ユーザーが操作するインターフェース（UI）は、どのようなものにし、どのように表示・参照・変更・適用するのか？どのようなフォームやパネルやダイアログを表示するのか？</p>
<p>・プログラム自体の設定は、どのように保持・参照・変更・適用するのか？プログラムの処理の中でどのように設定を適用するのか？</p>
<p>・プログラムの主要な機能は何か？</p>
<p>・プログラムの主要な機能をどのように実現し、実装するのか？</p>
<p>・機能の呼び出しインターフェース（API）は、どのような規約（ルール）に基づいて構築するのか？</p>
<p>・APIに基づいて、機能をどのように分割・相互参照・モジュール化するのか？</p>
<p>・プログラムの開発のベースとして、どのような技術を採用するのか？（コンソール、Windows、Web、フレームワークなど）</p>
<p>・どのようなプログラムにしたいのか？（多機能、軽量、簡単、プロ仕様など）</p>
<p>また、こうして出てきた「漠然とした全体像」を、明確に、それ以上細分化できないところまで細分化し、決まっていないことが何もないぐらい明確化する。</p>
<p>そして、明確化した内容を、実際のプログラムにするために、「クラス」と呼ばれる単位に分割し、クラスとクラスの関係性を記述する「クラス図」と処理の流れを記述する「シーケンス図」を描く。</p>
<p>最後に、これらに基づいてコードを書く。ここで、初めて、プログラミング言語の知識の内容を活かすことができる。</p>
<p>後日注記：実際のところ、上記はMFCのドキュメント・ビューのような場合に限られる。もっとより一般的には、「処理の流れをどうするか」「内部的な設定情報をどのように保持するか」「ライブラリや再利用可能なコンポーネントをどのように利用・構築するか」などといった具合になる。</p>

<h2>エンジニア向け読み物・良いコードの書き方</h2>
<p>Qiitaでエンジニア向けの読み物系ページをまとめていらっしゃる方がおられます。とても参考になります。</p>
<ul>
<li><a href="https://qiita.com/Connery/items/d2edc58c1470805d6297">エンジニア向け読み物まとめ - Qiita</a></li>
</ul>
<p>後日注記：また、Qiitaで、良いコードの書き方をまとめていらっしゃる方がおられます。とても勉強になります。</p>
<ul>
<li><a href="https://qiita.com/alt_yamamoto/items/25eda376e6b947208996">良いコードの書き方 - Qiita</a></li>
</ul>

<h2>ハードウェアではなくプログラミングで実現する</h2>
<p>日本人の科学者である嶋正利とIntelが一緒になって作ったIntel 4004以降の「マイクロプロセッサ」では、CPUは基本的な演算機能だけを提供し、あとの多くの機能を「プログラミング」によって成り立たせる、という新しい考え方を作りました。</p>
<p>これは、今のプログラム開発についても当てはまります。基本のCPUの機能は少なく、「原則プログラミングで機能を増やしていく」という発想です。</p>
<p>WebブラウザのSleipnirのように、WindowsのGUIアプリケーションには、こうした考え方が色濃くあります。原則、プログラミングとは、「プログラミングによって付け足せる機能をどんどん付け足すこと」に他なりません。CPUのレベルで、プログラミングは機能をいくらでもソフトウェアで付け足していく、ということなのです。</p>
<p><a href="../hardware/old_computer2.html">古いコンピュータ（２．パソコン）</a>も参照のこと。</p>

<h2>Udemy</h2>
<p>先に「プログラミングスクール」について書きましたが、Udemyという有料ながら良質なプログラミング入門コンテンツ（動画講座）を配信しているサイトがあります。</p>
<ul>
<li><a href="https://www.udemy.com/ja/">Udemy</a></li>
</ul>
<p>特に、以下の人はUdemyを「非常に安い買い物だった」と言っています。</p>
<ul>
<li><a href="https://qiita.com/otupy/items/ecbc34376040785e1bbc">100日後にエンジニアになるキミ - 2日目 - 学習方法について - Qiita</a></li>
</ul>
<p>実際、プログラミングスクールに通うには高額な授業料が必要で、コスパが悪いです。Udemyの動画は内容が詳しく、内容に比べて安いのだと思います。</p>

<h2>variableには「変わりやすい」、functionには「機能」という意味がある</h2>
<p>プログラミングを行う上で、使う単語の英語的な意味を知っておくことはいいことかもしれません。</p>
<p>たとえば、変数を表すvariableには「変わりやすい」「変異する」という意味があります。</p>
<p>また、関数を表すfunctionには「機能」「働き」という意味があります。</p>
<p>同様に、objectには「もの」、classには「階級」、instanceには「実例」「事例」「事実」という意味があります。</p>
<p>このような英語の意味を知っておくことで、使う単語の「どういう目的でこのキーワードを使うのか」という意味が分かります。</p>

<h1>コンテンツ</h1>
<p><a href="programming_flow.html">３A．制御フロー</a></p>
<p><a href="programming_data.html">３B．データ操作</a></p>
<p><a href="programming_pointer.html">３C．ポインタとメモリ管理</a></p>
<!--
<p><a href="programming_code_reading.html">３D．Code Reading</a></p>
-->

<h1>機械語・低水準処理</h1>
<h2>Intel CPU</h2>
<p>Intel系のCPUは、32bit（IA-32）ならx86（i386, i486, i586, i686）となり、それ以降はItaniumなどのIA-64とx86互換のAMD64（x86_64）となります。</p>
<p>他に、携帯デバイスとして使われるARMや、昔のMacで使われていたIBMのPowerPC、Sunの開発していたSPARCなどがあります。</p>
<p><a href="../hardware/intel.html">Intel</a>や<a href="../hardware/powerpc.html">PowerPC</a>や<a href="../hardware/arm.html">ARM</a>も参照のこと。</p>

<h2>Intel以外のCPU</h2>
<p>歴史的にUNIXはC言語で書かれたことから、移植性が高いと言われるが、オープンソース系UNIXでは、NetBSDの移植性が高いことで有名だ。</p>
<p>Linuxもさまざまなアーキテクチャに移植されているが、移植にはLinuxカーネル、Glibc、GCCなどの対応が必要（僕も詳しくは知らない。LLVMやNetBSDのlibcを使うこともあるらしい。）なことから、新しいCPUアーキテクチャに対応するのは簡単ではない。</p>
<p>Debian GNU/Linuxは、さまざまなアーキテクチャに向けたバイナリパッケージを公式で配布していることで有名だ。</p>
<p>Gentoo Linuxは、ソースベースのパッケージ管理システムを採用することで、さまざまなCPUアーキテクチャに対応している。だが、ほとんどのパッケージでコンパイルが必要だ。</p>
<p>Fedoraなどのメジャーなディストリビューションも、ARMには対応する傾向にある。</p>
<p>いずれにせよ、Intel以外のCPUアーキテクチャでLinuxなどを使う場合は、自分で問題に対処出来る問題解決能力が必要だ。</p>
<p><a href="portability.html">移植性</a>や<a href="../hardware/cpu_arch.html">CPUアーキテクチャ</a>も参照のこと。</p>

<h1>参考情報</h1>
<h2>LinuxとUNIXの設計</h2>
<p><a href="../linux/linux_os_design.html">Linux設計</a>や<a href="../linux/linux_api.html">Linux システムコール・API</a>にいろいろと書いています。参照してください。</p>

<h2>コンパイラを作る</h2>
<p><a href="compiler_develop.html">コンパイラ開発</a>を参照のこと。</p>

<h1>手法</h1>

<h2>RubyによるWebプログラミングのようなもの</h2>
<p>ある意味、プログラミングなんて、ただ使うだけだ、ということも出来る。</p>
<p>たとえば、ホームページをHTMLで書いていたとして、日記の月別一覧を色んなところに張り付けたい場合は、Rubyなら</p>
<pre>
2017.11.01
2017.11.02
2017.11.04
2017.11.05
</pre>
というテキストファイルを作っておいて、その上で
<pre class="prettyprint">
File.open("diary_2017.11.txt") do |io|
  while line = io.gets
    line.chomp!
    puts "&lt;p&gt;&lt;a href=\"" + line + ".html\"&gt;" + line + "&lt;/a&gt;&lt;/p&gt;"
  end
end
</pre>
<p>とRubyでいくらか書いてやるだけで、簡単に動くRubyのCGIファイルを作ることが出来る。日付を追加する時はdiary_2017.11.txtだけを編集すれば良い。</p>
<p>だから、何をするにしても、プログラミングはただ使うだけだ。自分で何も作っていない。使うだけに終始する、それがプログラミングなのだ。</p>
<p>上のコードを綺麗な関数にすると以下のようになる。</p>
<pre class="prettyprint">
def diary_list(path)
  File.open(path) do |io|
    while line = io.gets
      line.chomp!
      puts "&lt;p&gt;&lt;a href=\"" + line + ".html\"&gt;" + line + "&lt;/a&gt;&lt;/p&gt;"
    end
  end
end

diary_list("diary_2017.09.txt")
diary_list("diary_2017.10.txt")
diary_list("diary_2017.11.txt")
</pre>
<p>また、オブジェクト指向でなぜ作るのか、という話が分からない人が多いが、フィールドは視点を変えてみるとグローバル変数と似ている。クラスの中だけで使われるグローバル変数だ。そういう風に考えると、JavaやRubyのカプセル化という発想も良く分かると思う。</p>

<h2>ワープロを作るために</h2>
<blockquote class="inyou2">
<p>ワープロを作るために必要なのは、</p>
<p>・データの保管と読み書きをするデータオブジェクト</p>
<p>・文字や画像を表示する配置オブジェクト</p>
<p>・データオブジェクトと配置オブジェクトの変換をするメソッド</p>
<p>・配置オブジェクトを表示するメソッドとビュー</p>
<p>・ビューを操作した時に配置オブジェクトとビューを更新する描画モード</p>
<p>・配置オブジェクトの編集機能</p>
<p>ではないかと思う。</p>
</blockquote>
<p>（<!--[過去の日記]--><a href="../../diary/2018.01.24.html">2018-01-24</a>より引用。）</p>
<p>きっと、ブラウザなども同じ要領で作れる。MFCにはドキュメント・ビューという概念が存在するが、僕はそれには詳しくない。</p>
<p>基本的に、配置メソッドは四角形の領域を表示するようにして、表示メソッドによってビューに「全ての配置オブジェクトを表示する」機能をつけて、描画モードによって操作に応じて部分的に配置オブジェクトの表示を更新する機能をつける。そして、保存する時はデータオブジェクトに変換すれば良い。</p>
<p>オブジェクト指向は、クラスによってデータとメソッドを一体化させ、その上でメモリの管理をオブジェクト単位で行い、オブジェクトを簡単に作成・削除し、グローバル変数のようにクラス内部のメソッドからオブジェクトのメンバ関数を処理するものだ、と考えると良く分かる。</p>

<h2>タスクからシステムを作る</h2>
<p><!--[過去の日記]--><a href="../../diary/2018.02.27.html">2018-02-27</a>より。</p>
<blockquote class="inyou2">
<p>僕は、出来ればプロジェクトマネジメントの研究をしたい。特に、グーグルの戦略と働き方に興味がある。あるいは、マイクロソフトの働き方に興味がある。そして、国連の活動に興味がある。先日は、国連の広報ブログを読んでいた。</p>
<p>プログラムとは、手順書だ。パソコンをアセンブリから見ると、ただの電卓だ。プログラムとは計算の手順であり、コンパイラは計算の手順をより基本的なものに変換する。プログラムを実現するのはカーネルだが、ファイルシステムなどは本来は必要ない。システムを具体的に実現するのがソフトウェアだ。</p>
<p>プログラミングとは、手順書を書くことでシステムのインフラ基盤を作る作業だ。</p>
<p>やることが定まっている全てのタスクは、きちんとシステムを作れば簡単に実現できる。それがプログラマだ。</p>
<p>普通、描画システムぐらい簡単に作れる。ブラウザではレンダリングエンジンと言う。一つ一つのシステムを作って、細分化させながら組み合わせれば、きっとIllustratorも作れる。</p>
<p>プログラミングは、ある意味自動実行とリクエストだ。だから、サーバーをやるとできるようになる。</p>
<p>コンパイラは、トークンを解析するシステム、文法を成り立たせるシステム、実行内容を作るシステム、アセンブラを吐き出すシステムを作れば作れる。</p>
<p>コンパイラは決して難しくない。機能と構文ごとにシステムを作れば作れる。Rustなら、借用やトレイトの解釈システムと実行システムを作れば作れる。</p>
</blockquote>

<h2>GUIプログラミングの方法</h2>
<p>僕は、GUIプログラミングには主に3つの方法があると思っている。</p>
<p>まず、Windowsのメッセージループや、X11のイベントループ、Swingのリスナのように、「メッセージループ」を行うことでイベントを分類する方式。</p>
<p>次に、MFCのような、継承とオーバーライドでオブジェクト指向でメソッドを書き換える方式。</p>
<p>そして、GTK+やVBのような、ウィジェットにコールバック関数でイベントドリブンを行う方式。</p>
<p>どの方式も一長一短があるが、少しずつレベルと抽象度が高くなっていく、と考えると良いだろう。理想はGTK+やVBだ。</p>

<h2>処理は画面のウィンドウではなく、CPUがやっている</h2>
<p>パソコンの初心者が勘違いしやすいこととして、「パソコンの処理は、画面に出てくるウィンドウがやっている」ということがある。</p>
<p>本当は、ウィンドウはただやりとりを表示しているだけで、実際の処理はCPUとハードウェアがやっている。</p>
<p>ある意味、「実行ファイルがやっている」という考え方はおかしくはない。それは、OSが実行ファイルを実行する、という発想から生まれている。だが、本当の処理はCPUがやっている。画面に出てこない色々なことを全て、CPUがプログラムコードを実行してやっている。そのことを覚えておくと、パソコンが長い間停止して何をやっているのか分からない、という時でも、「ああ、CPUは今頑張っているのだな」ということが分かる。プログラムとは何なのか、コードはどんなことを書いてどんなことを実行させているのか、良く分かるようになる。</p>

<!--[過去の日記]-->
<h2>関連する日記</h2>
<p><a href="../../diary/2017.10.28.html">2017-10-28</a>、<a href="../../diary/2018.03.01.html">2018-03-01</a>に関連する内容があります。</p>

<h1>さまざまなプログラムの設計</h1>
<h2>共有されるデータを変数に格納し、関数を作って呼び出す</h2>
<p>プログラムを作るセオリーとして、オブジェクト指向のやり方が良く使われます。それは、「共有されるデータを変数に格納し、関数を作って呼び出す」ということです。</p>
<p>多くの場合、これでプログラムは書けます。具体的には、下のカーナビのシステムが参考になるかもしれません。</p>

<h2>カーナビを作る</h2>
<p>たとえば、カーナビのシステムを作る場合。まずは、地図データがあります。この地図データを、まず、変数に格納します。</p>
<p>そして、機能を作る前に、マッピングとして、地図データの基本的な操作メソッドと、ディスプレイやモニター画面に地図を表示する関数群（API）を作ります。</p>
<p>そして、基本的な地図の機能、たとえば拡大・縮小、回転、移動、のような機能を作ります。これは画像的なライブラリを使うと良いでしょう。</p>
<p>地図を解析して、道順を知るための機能は、まず、膨大な地図データをデータベースに登録します。そのために、画像から自動で地図データの「属性」を取得し、自動で登録する解析プログラムを作ります。</p>
<p>このデータには、道路の長さと、必要な移動時間、そして道路の右端と左端の位置情報や、道の分岐の情報を登録します。</p>
<p>そして、現在地と目的地の位置情報から、「どんな道のりのパターンがあるか」を、道路の右端と左端の位置情報や分岐の情報を上手く繋ぎ合わせることで、全パターン洗い出します。</p>
<p>そして、それぞれのパターンにかかる時間を計算し、それをソートして完成です。</p>
<p>その上で、さまざまなナビゲーションに必要な機能（道のりを別の色で表示したり、状況に応じてナビゲーションする機能）をつけて、カーナビのシステムを作ることができます。</p>
<p>このような場合にも、必要なのは、「データを保持する部分と、そのデータを操作する関数の部分を作ること」です。</p>
<p>さらに言えば、「どの道からどの道に繋がるか」というリンク情報をデータベースに登録しておくと、あとあと便利かもしれません。また、さまざまなボタンやメニューを作って、イベント駆動のメソッドを書く必要があるでしょう。そして、きちんと動くかを確認するために、テスト関数のようなものを用意して、さまざまな条件と結果をチェックするようにしましょう。現在位置を取得するGPS機能や、現在位置の変化とともに画面を移動させていく「リアルタイム解析機能」も必要になるでしょう。</p>

<h2>ブラウザを作る</h2>
<p>みんな、Webブラウザのようなものは難しすぎて誰にも作れないのだろうと考えているかもしれないが、意外と簡単である。</p>
<p>まず、HTMLを装飾と文字データの属性を持ったレイアウト情報（レイアウト文字データ）に変換する。ここでCSSを考慮しても良いだろう。そして、与えられたオプションから四角形の領域を表示する部分を実装する。つまり、「divとspanだけを作れば作れる」からである。</p>
<p>pタグやh1タグのようなものは、全部divとspanを使って作れば良い。</p>
<p>レイアウト部分が作れたら、次は装飾部分を作る。まず、文字を表示しなければならない。次に、文字と背景と線に色をつけなければならない。</p>
<p>最初からCSSを考慮した設計にすると、あとで楽が出来るだろう。</p>
<p>また、その上で、画像を表示したり、さまざまな機能を作ったりする必要はある。JavaScriptの実装も難しいし、そのためにはDOMを実装しないといけない。</p>
<p>だが、これくらいの、HTMLをパースして領域を表示する部分は、むしろ、僕のロボット（人工知能）のプログラムを参考にすると上手く作れるだろう。HTMLを読み込んで、CSSを解釈し、タグをパースし、領域とレイアウトを決め、装飾をつけて、最終的にモニターに表示するのを、ひとつの制御の流れとして実装すれば、あとはオプションを解釈して動作を変えるだけで、おそらく作れるだろう。</p>

<h2>テキストエディタを作る</h2>
<p>本当はコントロールを作るのが難しいのだが、テキストエディタは既にあるコントロールを継承して改良することで簡単に作ることができる。</p>

<h1>プログラミングの原則</h1>
<h2>驚き最小の原則</h2>
<p>驚き最小の原則とは、特にPerlなどのプログラミング言語などの設計に言われる考え方で、「みんなが驚いたり勘違いしたりすることを極力なくして、当然そのように発想するように設計しよう」という設計の考え方。</p>

<h2>車輪の再発明（はやめよう）</h2>
<p>車輪の再発明とは、一度作った基本的なベースシステムをもう一度作り直す（再発明）のではなく、出来るだけ共有して再利用しよう、という考え方。UNIXなどの他、Windowsなどでも言われる。</p>
<p>後日注記：実際のところ、「絶対に動くサブルーチン」を作ってしまえば、あとはそのサブルーチンや関数を再利用するだけで絶対に動く。プログラミングではそういう発想をする。同じ処理を別々の場所に何度も書いていると、後で直すのにも時間がかかる。</p>
<p>後日注記：車輪の最発明は、このようにネガティブにとられることもある一方で、学習や習得に対しては、ポジティブに「積極的に車輪の最発明をしよう」と言われることもあります。既にあるプログラムと同じものを作ることで、プログラミングの勉強や習得に結びつきます。たとえば、Web系ならブログエンジンや掲示板、システム系ならターミナルエミュレータのようなものを「車輪の最発明」して作ることで、スキルアップに繋がります。</p>

<h2>Keep it simple, stupid.</h2>
<p>Keep it simple, stupid.（シンプルを保て、愚か者め）とは、UNIXで言われる考え方で、「シンプル（単純）」な状態を保っておかなければ、すぐに使い物にならなくなる（設計の間違いを生む）、という考え方。</p>
<p>また、UNIX哲学として「システムのパワーは、プログラム自身からではなくプログラム間の関係から生じる」という考え方が言われている。ひとつのプログラムを使うのではなく、たくさんのプログラムを使って成り立たせるソフトウェアの環境がシステムのパワーを発揮する。特に、findやgrepのような小さなコマンドプログラムを組み合わせて使う、といった時に言われる。個別のプログラムだけがパワーを発揮するのではなく、プログラムをとりまくシェルやOSなどの環境の関係がシステムのパワーを発揮するという、システムエンジニアらしい考え方である。</p>

<h2>設定より規約</h2>
<p>Ruby on Railsで言われる考え方で、複雑な設定をするよりもある程度の規約をそれぞれが守るようにした方が、フレームワークの管理は簡単になる、という考え方。</p>

<h2>目玉の数さえ十分あれば、どんなバグも深刻ではない</h2>
<p>Linuxやオープンソースで言われる考え方で、バグがいくらあったとしても、それを修正するための発見者や貢献者の目玉がたくさんある（たくさんの人がコードを検査している）のであれば、バグは深刻ではない、とする考え方。</p>

<h1>Web上でプログラミング</h1>
<h2>Web上で開発・コンパイル・実行</h2>
<p>オンラインでソースコードを開発・コンパイル・実行できるサービスは以下のようなものがあります。</p>
<ul>
<li><a href="http://www.tutorialspoint.com/compile_c_online.php">Online C Compiler</a></li>
<li><a href="https://qiita.com/tttamaki/items/2b009aa957cfa4895d50">オンラインでプログラミングして実行できるサイト - Qiita</a></li>
</ul>

<h2>paiza.IO</h2>
<p>paiza.IOはWeb上でプログラムのソースコードを記述し、オンラインでコンパイル・実行できるサービス。C/C++, Java, Perl, Python, PHP, Rubyなどさまざまな言語に対応している。</p>
<ul>
<li><a href="https://paiza.io/ja">paiza.IO</a></li>
</ul>

<h2>AWS Cloud9</h2>
<p>AWS Cloud9は本格的なオンライン開発環境。無料の会員登録が必要。</p>
<ul>
<li><a href="https://aws.amazon.com/jp/cloud9/?origin=c9io">AWS Cloud9（ブラウザのみでコードを記述、実行できるクラウドIDE）｜AWS</a></li>
</ul>







</div></div> <!--page-->










<script type="text/javascript" src="../../js/jquery.toc.js"></script>
<script type="text/javascript" src="../../js/script.js"></script>
<script type="text/javascript" src="../../js/scriptfortoc.js"></script>
<script type="text/javascript" src="../../js/prettify.js"></script>
<script>prettyPrint();</script>
</body>
</html>