<!DOCTYPE html>
<html dir="ltr" lang="ja">
    <head>
        <title>状態の世界観 - from Assy</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="keywords" content="Assy,アッシー,詩,小説,物語,歴史,政治,経済,コンピュータ,パソコン,Linux,エッセイ,散文,哲学">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="../../css/style.css">
        <link rel="stylesheet" href="../../css/prettify.css" type="text/css">


<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">

    </head>
    <body>
<div class="page">
<script type="text/javascript" src="../../js/jquery.min.js"></script>
<script type="text/javascript" src="../../js/script_smartmenus.js"></script>
<script type="text/javascript" src="../../js/links2.js"></script>

<p><a href="index.html">プログラミング言語の世界観に戻る</a></p>
<div class="sidebar">
<iframe src="../../menus/prog_lang_skill_menu.html" class="sideiframe"></iframe>
</div>
<h1>状態の世界観</h1>
<p>状態に関する世界観です。</p>
<div id="toc"></div>
<div class="page_links">

<h1>状態</h1>
<h2>プログラミングにおける状態</h2>
<p>プログラミングにおいて、状態をどのように保持するかということは重要な問題です。</p>
<p>たとえば、関数を実行するごとに1ずつカウントするプログラムや、行をひとつひとつ進めて処理を行うようなプログラムを考えてみます。</p>
<p>関数を実行した度に、その関数の内部のローカル変数は、（スタックに置かれたものについては）失われてしまいます。</p>
<p>どこか、関数の外部に、関数を実行し終わった後でも残るような、「状態」を残さなければなりません。</p>
<p>状態とは、このように局所的な関数だけではなく、プログラム全体としての実行内容を意味することもあります。</p>
<p>たとえば、telnetやsshのようなリモートログインソフトウェアを使う場合、コマンドをひとつひとつ実行しても、相手のホストとの接続状態は維持しておかなければいけません。</p>
<p>このように、プログラミングにおいて、プログラムの状態をどこかに確保しておくということは重要なことです。</p>

<h2>ステートレスとステートフル</h2>
<p>状態を確保しないタイプのプログラムをステートレスと呼び、状態を確保するタイプのプログラムをステートフルと言います。</p>
<p>先に挙げた、telnetやsshのようなプログラムは、ステートフルなプログラムです。</p>
<p>逆に、ステートレスなプログラムの例は、Perl/CGIやPHPのようなCGIのようなプログラムです。</p>
<p>CGIにおいては、そのページの表示と通信ごとにデータはやり取りしますが、ページごとにデータの保持が完結しており、基本的には「ページをまたいだデータ」を持ちません。</p>
<p>ですが、CGIにおいても、Cookieやサーバーセッションなどを使うことで、ステートフルな状態保持をすることはできます。</p>
<p>後日注記：ステートフル・ステートレスについては、以下の書籍が参考になります。</p>
<ul>
<li><a href="https://www.amazon.co.jp/%E7%B5%B5%E3%81%A7%E8%A6%8B%E3%81%A6%E3%82%8F%E3%81%8B%E3%82%8BIT%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF-DB-SELECTION-%E5%B1%B1%E5%B4%8E-%E6%B3%B0%E5%8F%B2/dp/4798125733">絵で見てわかるITインフラの仕組み (DB SELECTION)</a></li>
</ul>
<p><a href="../network/cgi.html">CGI</a>を参照のこと。</p>

<h2>永続化</h2>
<p>また、「永続化」と呼ばれる概念もあります。これは、プログラムが終了したとしても、メモリ上のデータをストレージ上に書き出す（永続化）することで、データをメモリから永続化データに移して残すことです。</p>
<p>たとえば、Javaのオブジェクトは、メモリ上に存在するため、プログラムが終了するか電源を切るかしてしまえば消えてしまうでしょう。</p>
<p>このようなデータは、RDBMSのようなデータベースにマッピング（O/Rマッピング）することで、ストレージ上に永続化することができます。</p>
<p>あるいは、ファイルをこのような永続化の目的に使うこともあります。UNIXでは、PATHの設定などはシェルを使ってもできますが、ログアウトすれば消えてしまうため、/etc以下にある設定ファイルやドットファイルを編集して恒久的に設定が残るようにします。</p>
<p><a href="orm.html">永続化とO/Rマッピング</a>を参照のこと。</p>

<h1>状態を保持する技術</h1>
<h2>状態を保持するために</h2>
<p>プログラムにおいて状態を保持するためには、いくらかの方法があります。</p>

<h2>グローバル変数を使う</h2>
<p>簡単で手軽なのは、グローバル変数を使う方法です。</p>
<p>どの関数からも参照されるような、グローバル変数を宣言し、それをどの関数からも参照するようにすれば、関数の呼び出しが終わってから次の関数が呼び出されたとしても、状態を保持することができます。</p>
<p>しかしながら、グローバル変数を使うことは推奨されません。理由は、「どこから変更されているのかが把握しづらくなる」ということと、「名前空間を汚染する」ということからです。</p>
<p>まず、グローバル変数を多用すると、その変数をプログラムのどこからでも書き換えられてしまいます。なので、バグが出て上手く動かなくなった時に、「どこからかけた変更が別のどこで参照されているのか」が分からなくなってしまい、保守性の低いプログラムになってしまいます。</p>
<p>次に、プログラムを複数人で作っている時に、それぞれが好き勝手に変数名をつけていると、衝突することがあります。別の人の「age」という変数と、自分の「age」という変数があった時に、それが混ざってしまうのです。</p>
<p>しかしながら、グローバル変数を使わなければならない言語も存在するでしょう。そのため、C言語ではstatc宣言をつけることで、そのファイル以外からは参照できないようにすることもできます。名前空間がある言語なら、別の名前空間とは別のグローバル変数であることを区別することもできます。</p>
<p>もし、そうした機能を使わないとしたら、たとえばWebプログラマが作るコードの変数はすべてに「web_」をつけ、データベースプログラマが作るコードの変数はすべてに「db_」をつける、といった方法でも対処は可能です。</p>
<p><a href="c_flow.html">C関連（２．制御フロー）</a>や<a href="c_data.html">C言語（３．データ構造）</a>を参照のこと。</p>
<p>（一部の内容で<a href="https://www.amazon.co.jp/ANSI-Common-Lisp-%E3%82%B9%E3%82%BF%E3%83%B3%E3%83%80%E3%83%BC%E3%83%89%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88-%E3%82%B0%E3%83%AC%E3%82%A2%E3%83%A0/dp/4894714337">ANSI Common Lisp (スタンダードテキスト)</a>を参考にしました。）</p>

<h2>関数の引数を使う</h2>
<p>ほかの方法として、グローバル変数と同じく手軽に使えるのは、関数の引数を使う方法です。</p>
<p>たとえば、実行するたびにカウントする関数は、引数に「今の値」を与え、返り値として「カウントした値」を返すようにすれば実現できます。</p>
<p>あるいは、ポインタを使って、引数として与えたデータを関数の内部から書き換えるようにし、参照型の「今の値」を与えるようにしても、実現できるでしょう。ポインタは値型の編集である必要はないため、構造体のポインタや参照型のオブジェクトを引数として与えることもでき、その構造体やオブジェクトを関数の中で操作してもよいでしょう。</p>
<p>これは、グローバル変数よりもよいやり方です。なぜなら、関数型プログラミングの方法を使っているからです。</p>
<p>関数型プログラミングとは、プログラムを「関数」で成り立たせる方法です。そして、関数型プログラミングでは、「非破壊的な操作」を重要視します。</p>
<p>破壊的な操作とは、既にある変数を書き換える方法のことです。非破壊的操作とは、変数を書き換えずに、新しい値の変数が必要になった場合に、その時その時の変数を新しく作って、関数の返り値として返す方法のことです。</p>
<p>一般的に、破壊的操作を行うよりも、非破壊的操作のほうが保守性の高いプログラムになります。破壊的操作をすべて禁止することではプログラムは書けないように思われるかもしれませんが、実際のプログラミングの場面では、破壊的操作が本当に必要な場合はごく少数であり、破壊的な操作を行う多くのプログラムを非破壊的なプログラムに置き換えることができます。</p>
<p><a href="functional_programming.html">関数型プログラミング</a>を参照のこと。</p>

<h2>オブジェクト指向を使う</h2>
<p>第三の方法として言えるのは、オブジェクト指向を用いる方法です。</p>
<p>オブジェクト指向は、すべてのメンバ関数（メソッド）から共通のデータにアクセスし、そのアクセスを制限したり、継承やポリモーフィズムを使って抽象的にプログラムを拡張することができます。</p>
<p>グローバル変数がスパゲッティプログラムになる原因は、「すべてのプログラム全体にデータの編集を可能にしている」という、いわばスコープの問題です。</p>
<p>オブジェクト指向では、関数すなわちプログラムを書き換える部分を、データの内部のメンバに加えることで、関数とデータのプロパティを同じものであると扱います。</p>
<p>それによって、プログラムはデータの一部となり、データという「基本単位」を基に、プログラムをそのデータをやり取りする「振る舞い」として記述します。</p>
<p>そして、グローバル変数は必要のないものとなります。グローバル変数はデータの中のメンバ変数となり、グローバル変数を書き換えるコードは同じデータの中のメンバ関数（メソッド）となるため、ひとつのクラスの中にそのオブジェクトに必要なすべてがある程度の大きさで分割されるのです。</p>
<p>オブジェクト指向は、さらにデータへのアクセス修飾子によって、データの安全な変更を可能とします。グローバル変数がどこからでも書き変わってバグが出る原因は、通常ならば行わないような不正な操作をどこかで行ったからです。アクセス修飾子を用いることで、そのような不正な操作は最初からできなくなります。すべて、正しい操作をメソッドやアクセサから行うように義務化することができます。</p>
<p>また、オブジェクト指向を使う場合、プログラムの再利用性が高まり、拡張が容易になります。基底クラスの機能を引き継いだ上で、派生クラスでプログラムに機能を付け足したり上書きしたりすること、すなわち「継承」が可能だからです。</p>
<p><a href="oop.html">オブジェクト指向</a>や<a href="c_data.html">C言語（３．データ構造）</a>を参照のこと。</p>

<h2>クロージャを使う</h2>
<p>オブジェクト指向は、きちんとしたプログラムの設計をする際、たとえば大規模なプログラミングを行う際に効果を発揮しますが、もっと小規模で手軽に行いたい場合は、クロージャを使うこともできます。</p>
<p>クロージャとは、関数の宣言と同じスコープにある外部の変数を、関数の中から参照する機能です。</p>
<p>たとえば、実行するたびにカウントを1ずつ増やすプログラムなどは、クロージャを用いることで、カウント変数var c = 0;を宣言したのと同じスコープに、function inct() { c = c + 1; }を宣言することで実現できます。</p>
<p>クロージャはとても便利な機能で、JavaScriptやLispなどに備わっています。関数だけで状態を持ちたいのであれば、クロージャを使うのがよいでしょう。</p>
<p>また、JavaScriptでは、関数は特定のクラスには束縛されません。なので、関数そのものの再利用が、オブジェクト指向のクラスを使う場合よりもやりやすいです。たとえば、先ほどのインクリメント関数をthis.c = c + 1;と書き換えるだけで、thisにどんなオブジェクトが与えられたとしてもそのオブジェクトのcを操作できます（this参照）。これを委譲と呼びます。</p>
<p><a href="closure.html">クロージャ・無名関数・関数オブジェクト</a>や<a href="javascript_prototype.html">JavaScript（３．プロトタイプチェーン</a>）を参照のこと。</p>

<h1>状態遷移</h1>
<h2>状態遷移とは</h2>
<p>状態遷移とは、制御モデルのひとつで、マシンが「状態」を持っていて、その状態がさまざまな値に変わることで、システム全体の動き方が変わるようなプログラムのことです。</p>
<p>この方法の一例として、僕の作った<a href="../programs/robot.html">ロボット</a>が参考になるかもしれません。</p>
<p><a href="event.html">イベント駆動</a>や<a href="computer_science.html">コンピュータ科学</a>を参照のこと。</p>

<h1>状態管理</h1>
<h2>Flux</h2>
<p>FluxはFacebookによって提唱された状態管理のモデルのことで、Redux（React）やVuex（Vue.js）などで実装されている。</p>
<p><a href="javascript_framework_react.html">React</a>や<a href="javascript_framework_vue_js.html">Vue.js</a>を参照のこと。</p>

<h1>書籍</h1>
<h2>参考文献</h2>
<p>一部の内容（グローバル変数の名前汚染の対処法、関数型プログラミングにおける破壊的操作と非破壊的操作の置き換え、オブジェクト指向におけるデータの中の振る舞いとしてのプログラムのあり方）について、以下の書籍を参考に執筆しました。</p>
<ul>
<li><a href="https://www.amazon.co.jp/ANSI-Common-Lisp-%E3%82%B9%E3%82%BF%E3%83%B3%E3%83%80%E3%83%BC%E3%83%89%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88-%E3%82%B0%E3%83%AC%E3%82%A2%E3%83%A0/dp/4894714337">ANSI Common Lisp (スタンダードテキスト)</a></li>
</ul>
<p>また、JavaScriptとクロージャについては以下の雑誌を参考に執筆しました。</p>
<ul>
<li><a href="https://gihyo.jp/magazine/SD/archive/2022/202202">Software Design 2022年2月号</a></li>
</ul>

</div></div> <!--page-->










<script type="text/javascript" src="../../js/jquery.toc.js"></script>
<script type="text/javascript" src="../../js/script.js"></script>
<script type="text/javascript" src="../../js/scriptfortoc.js"></script>
<script type="text/javascript" src="../../js/prettify.js"></script>
<script>prettyPrint();</script>
</body>
</html>