<!DOCTYPE html>
<html dir="ltr" lang="ja">
    <head>
        <title>AltJS/TypeScript関連の世界観 - from Assy</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="keywords" content="Assy,アッシー,詩,小説,物語,歴史,政治,経済,コンピュータ,パソコン,Linux,エッセイ,散文,哲学">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="../../css/style.css">
        <link rel="stylesheet" href="../../css/prettify.css" type="text/css">


<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">

    </head>
    <body>
<div class="page">
<script type="text/javascript" src="../../js/jquery.min.js"></script>
<script type="text/javascript" src="../../js/script_smartmenus.js"></script>
<script type="text/javascript" src="../../js/links2.js"></script>

<p><a href="index.html">プログラミング言語の世界観に戻る</a></p>
<div class="sidebar">
<iframe src="../../menus/prog_lang_javascript_menu.html" class="sideiframe"></iframe>
</div><h1>AltJS/TypeScriptの世界観</h1>
<p>AltJS/TypeScriptによるプログラミングに関する世界観です。</p>
<p><a href="https://www.amazon.co.jp/JavaScript-%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%E5%85%A5%E9%96%80-%E6%8E%8C%E7%94%B0%E6%B4%A5%E8%80%B6%E4%B9%83/dp/4798047848">JavaScript フレームワーク入門</a>を参考にしています。</p>

<div id="toc"></div>
<div class="page_links">

<h1>AltJS</h1>
<h2>JavaScript代替言語とは</h2>
<p>JavaScript代替言語は、AltJSとして知られ、「ブラウザで動くJavaScriptをもっと別の言語で書きたい」というニーズにこたえている。</p>
<p>たとえば、JavaScriptではプロトタイプベースの「とても特殊」なオブジェクト指向を用いるが、「C#やJavaのような静的型付けのクラスベースなオブジェクト指向開発がしたい」というニーズが、特に会社のシステム開発などでは多く見られる。この時、AltJSのTypeScriptを使うことができる。</p>
<p>また、TypeScriptは単なるAltJSではなく、「JavaScriptフレームワークの採用言語」でもある。ここでは、GoogleやFacebookなどが作ったAngularやReact/Vue.jsのような「クライアントサイドでのフレームワーク」を用いた時に、TypeScriptを使うことになる。特にAngularでは全面的にTypeScriptが採用されており、Angularを使う開発者は必然的にTypeScriptを学ばざるを得ない。</p>

<h2>TypeScriptの意味</h2>
<p>自分の書いたブログ「神々とともに生きる詩人」<a href="../../diary/blog_frey/2021.01.27.html">2021/01/27</a>より。</p>
<p><!--また、-->RubyやLaravelなどは、C++やJavaと同様のクラスベースのオブジェクト指向を行うが、JavaScriptでは、クラスベースではなくプロトタイプベースのオブジェクト指向を採用している。</p>
<p>クラスのメンバ変数とメソッドを用いることなく、JavaScriptではプロトタイプを作成することでオブジェクト指向ができるが、従来のプログラミングとは異なるため、クラスベースのオブジェクト指向を行うためにTypeScriptと呼ばれる言語を用いる。</p>
<p>また、C++やJavaには型がある（静的型付け）が、JavaScriptには型が無い（動的型付け）。</p>
<p>動的型付けはプログラムの開発が簡単であるというメリットがあるが、多くの場合、静的型付けの方がプログラムの信頼性や保守性が向上し、たとえばプログラムとプログラムを結合した際にもバグがでることが少ない。</p>
<p>このため、TypeScriptではJavaScriptにおいても静的型付けを実現できる。</p>
<p>TypeScriptでは、TypeScript独自の型のチェックをした後で、TypeScriptコードがJavaScriptコードに変換される。</p>
<p>以前のトレンドでは、RubyやPythonといった動的型付け言語が、プログラムの書きやすさといった点から流行していたが、最近は大規模なプログラム開発において静的型付けが再流行しており、RubyやPythonといった動的型付け言語でも、型アノテーションや型宣言ファイルを用いて、静的型解析を行うことが一般的になりつつある。</p>

<h2>DelphiやC#と同じ開発者が関わっている</h2>
<p>TypeScriptは、DelphiやC#などの開発をリードした元ボーランドで現マイクロソフトのアンダース・ヘルスバーグが関わっています。</p>
<p>僕はDelphi大好きっ子であるため、たとえMSの言語であっても「ヘルスバーグ天才すぎる」と言わざるを得ません。</p>
<p><a href="delphi.html">Delphi</a>や<a href="csharp.html">C#</a>も参照のこと。</p>

<h1>TypeScript</h1>
<h2>TypeScript</h2>
<p>Microsoftによる、JavaScriptの代替言語。</p>
<p>JavaScriptがクラスベースではないプロトタイプベースのオブジェクト指向をするのに比べて、TypeScriptはクラスベースのオブジェクト指向を行うことが出来る。静的型付けであると考えて良い。</p>
<p>GoogleによるDartと言う似たような言語プロジェクトもある。</p>

<h2>TypeScriptのインストール</h2>
<p>TypeScriptはnpmでインストールするため、まずNode.jsをインストールする。Node.jsをインストールすることでnpmが利用可能となる。</p>
<p>Node.jsをインストールしたら、以下のコマンドを実行する。</p>
<pre>
npm install -g typescript
</pre>
<p>（詳しくは<a href="https://qiita.com/ochiochi/items/efdaa0ae7d8c972c8103">TypeScriptチュートリアル① -環境構築編- - Qiita</a>が参考になる。）</p>

<h2>TypeScriptコンパイラを使う</h2>
<p>TypeScriptで.tsファイルをコンパイルするには以下のようにする。</p>
<pre>
tsc hoge.ts hoge.js
</pre>
<p>コンパイルが成功すると、hoge.jsファイルが出力される。これをNode.jsで実行するには、</p>
<pre>
node hoge.js
</pre>
<p>とする。</p>
<p>また、以下のコマンドで、TypeScriptの設定ファイルであるtsconfig.jsonが出力される。</p>
<pre>
tsc --init
</pre>
<p>これにより、TypeScriptの設定を自動化できる。</p>
<p>詳しくは以下のページが参考になる。</p>
<ul>
<li><a href="https://noumenon-th.net/programming/2019/06/29/typescript/">TypeScriptのインストールからコンパイルまで入門 - 思考の葉</a></li>
<li><a href="https://designsupply-web.com/media/programming/5923/">TypeScriptの導入・コンパイルと設定ファイルtsconfig.jsonを触ってみる | 大阪市天王寺区ホームページ制作 | 合同会社デザインサプライ-DesignSupply. LLC-</a></li>
</ul>

<h2>型付けされた変数宣言</h2>
<p>（以下は<a href="https://www.amazon.co.jp/JavaScript-%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%E5%85%A5%E9%96%80-%E6%8E%8C%E7%94%B0%E6%B4%A5%E8%80%B6%E4%B9%83/dp/4798047848">JavaScript フレームワーク入門</a>を参考に執筆・編集して引用しました。）</p>
<p>基本的に、</p>
<pre>
let 変数名 : 型名 ;
let 変数名 : 型名 = 値 ;
</pre>
<p>のように、変数名の後にコロンを付け、型名を記す。</p>
<p>TypeScriptでは、JavaScriptのコードを変数の型を指定して記述しますが、型はコンパイル時にチェックされるだけで、生成されるJavaScriptコードは型を指定しない場合と全く同じです。注意してください。</p>
<p>配列にも型を設定できるほか、型の別名であるエイリアスを使うことができる。列挙型やタプルも使うことができる。タプルは、すべての要素にそれぞれの型を指定した配列のようなもので、データベースにおけるレコードのような用途に使用できる。</p>
<p>後日注記：また、TypeScriptでは単に変数や関数に型を指定できるだけではなく、class構文を使ったクラスベースのオブジェクト指向もできる。クラスベースはプロトタイプベースよりも劣ったものでは決してなく、class文を使った方がオブジェクトの要素や構造をすっきりと書ける。</p>

<h2>TypeScriptの型</h2>
<p>自分の書いたブログ「神々とともに生きる詩人」<a href="../../diary/blog_frey/2021.01.11.html">2021/01/11</a>より。編集済み。</p>
<p>TypeScriptについて勉強した。</p>
<p>TypeScriptの型は、number（数値）, boolean（真偽値）, string（文字列）, any, voidなどを使う。</p>
<p>これを、変数なら変数名の後に、関数定義なら引数名やカッコの後ろに、コロンをつけて記述する。</p>
<pre class="prettyprint">
let n:number = 0;
let s:string = "Hoge";

function returnAdd(x:number, y:number): number {
    return x + y;
}
</pre>
<p>配列はnumber[]とする。</p>
<pre class="prettyprint">
let arr:number[] = [0, 1, 2, 3, 4];
</pre>
<p>また、interfaceを用いれば、オブジェクトの要素となるメンバと型の一覧を記述できる。</p>
<p>オブジェクトの場合、interfaceを記述し、それぞれの要素に型名を記述し、名前を付けてDataObjectなどとし、変数名の後に、このDataObjectを付ける。</p>
<pre class="prettyprint">
interface DataObject {
    x: number;
    y: number;
}

let values: DataObject = { x: 10, y: 30 };
</pre>
<p>この時、?を付けることで、あってもなくても構わない要素とすることができる。</p>
<p>nullを許容するにはstring | nullとする。明示的にnullを許容しない限り、nullは許容されないため、nullチェックをする必要はない。</p>
<p>そして、TypeScriptはJavaScriptのスーパーセットであり、JavaScriptモジュールを利用できるが、JavaScriptモジュールは当然ながらJavaScriptで書かれているため、型情報がない。</p>
<p>このようなモジュールのために、型定義ファイル（型宣言ファイル）が利用できる。</p>
<p>これはC言語のヘッダファイルのようなもので、関数などが型とともに記述されている。</p>
<p>TypeScriptでは、npmでモジュールを導入する際に、モジュールだけでなく、型定義ファイルも追加的にインストールする。</p>
<p>TypeScriptで書かれたtsファイルは、tscでjsにコンパイルする。たとえば、npx tscを使う。この際に型チェックが行われる。</p>
<p>また、VS-Codeでは、コードを書いている際に、型が間違っている時にその部分を教えてくれる。</p>
<p>以上は、以下の動画を見て、自分なりに書きました。</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=FSTrSYwqhLg">TypeScript超入門 覚えることは9個だけ！ - YouTube</a></li>
</ul>

<h2>TypeScriptのクラス文</h2>
<p>自分の書いたブログ「神々とともに生きる詩人」<a href="../../diary/blog_frey/2021.01.11.html">2021/01/11</a>より。編集済み。</p>
<p>TypeScriptでは、このほか、列挙型、タプル型、ジェネリクス型、可変長引数、などを利用できる。</p>
<p>また、TypeScriptでのオブジェクト指向では、class文を用いて、クラスベースのオブジェクト指向が可能。</p>
<pre class="prettyprint">
class Calc {
    x: number;
    y: number;
    
    constructor(a: number, b: number){
        this.x = a;
        this.y = b;
    }
    
    returnAdd(): number {
        return this.x + this.y;
    }
}
</pre>
<p>クラスにはコンストラクタ、メソッド、プロパティがあり、継承やオーバーライドも可能。</p>
<p>インスタンスをnewで生成でき、getやsetも使うことができる。</p>
<p>そして、インターフェースを使うことで、メソッドやプロパティを必ず実装しなければならないように、強制できる。</p>
<pre class="prettyprint">
interface Calc {
    x: number;
    y: number;
    
    returnAdd(): number;
}

class CalcAdd implements Calc {
    public x: number;
    public y: number;
    
    constructor(a: number, b: number){
        this.x = a;
        this.y = b;
    }

    returnAdd(): number {
        return this.x + this.y;
    }
}
</pre>
<p>TypeScriptでは、インターフェースも型として扱われる。</p>
<p>以上は、以下の書籍を参考に執筆しました。</p>
<ul>
<li><a href="https://www.amazon.co.jp/JavaScript-%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%E5%85%A5%E9%96%80-%E6%8E%8C%E7%94%B0%E6%B4%A5%E8%80%B6%E4%B9%83/dp/4798047848">JavaScript フレームワーク入門</a></li>
</ul>

<h2>TypeScriptのタプル</h2>
<p>自分の書いた「ニュース - 2021-04-第五週（2021-05-第一週）」<a href="../../diary/news/2021.04.w5.html">2021/04/29</a>より。編集済み。</p>
<p>TypeScriptのタプル型が便利だということが分かった。</p>
<p>JavaScriptの配列には、どんな型の値でも自由に入れることができる。</p>
<p>これに対して、TypeScriptのタプルは、決まった型の値しか入れることができない。</p>
<p>enum型などと組み合わせることで、「決められた型の値だけを格納する」ということが可能である。</p>
<p>これは、データベースレコードなどのような場合に便利だ。</p>
<p>たとえば、nameはstring、ageはnumber、genderはmaleあるいはfemaleのenum型などとし、これらの型の値しか受け付けないタプルを定義できる。</p>
<pre class="prettyprint">
enum Gender {male, female};
let tpl : [string, number, Gender];

tpl = ["Assy", 32, Gender.male];
</pre>
<p>（詳しくは<a href="https://www.amazon.co.jp/JavaScript-%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%E5%85%A5%E9%96%80-%E6%8E%8C%E7%94%B0%E6%B4%A5%E8%80%B6%E4%B9%83/dp/4798047848">JavaScript フレームワーク入門</a>が参考になります。）</p>

<h2>型エイリアス</h2>
<p>型エイリアスは、型に別名をつける機能。たとえば、stringの別名としてName、numberの別名としてAgeなどとできる。</p>
<pre class="prettyprint">
enum Gender {male, female};
type Name = string;
type Age = number;

let tpl2 : [Name, Age, Gender];
</pre>

<h2>型定義ファイルのインストール方法</h2>
<p>型定義ファイルは、もし@typesで提供されていた場合以下でインストールできる。</p>
<pre>
npm install --save @types/hoge
</pre>
<p>あるいは、</p>
<pre>
yarn add @types/hoge
</pre>
<p>提供されていない場合、型定義ファイル（d.tsファイル）を自分で作るか、importではなくrequireを使って読み込む方法（型はany型として扱われる）で対応することができます。</p>
<p>詳しくは以下のページを参照のこと。</p>
<ul>
<li><a href="https://qiita.com/Nossa/items/726cc3e67527e896ed1e">TypeScript で型定義ファイル( d.ts )がないときの対処法 - Qiita</a></li>
</ul>

<h2>サンプルコード</h2>
<p>自分で書いたコード。</p>
<pre class="prettyprint">
class Calc {
    private x:number;
    private y:number;
    private a:number;
    private s:number;
    private m:number;
    private d:number;
    
    constructor(x:number, y:number) {
        this.x = x;
        this.y = y;

        this.a = x + y;
        this.s = x - y;
        this.m = x * y;
        this.d = x / y;
    }
    
    printAll():void {
        console.log(this.x + " + " + this.y + " = " + this.a);
        console.log(this.x + " - " + this.y + " = " + this.s);
        console.log(this.x + " * " + this.y + " = " + this.m);
        console.log(this.x + " / " + this.y + " = " + this.d);
    }
}

let calc_list:Calc[] = [ new Calc(1, 3), new Calc(13, 23), new Calc(16, 15), new Calc(20, 7) ];

for (const value of calc_list.values()) {
    value.printAll();
}
</pre>

<h2>JavaScriptのclass文</h2>
<p>最近のJavaScriptでは、糖衣構文としてのclass文が導入されたため、クラスベースのオブジェクト指向だけをやりたいなら、TypeScriptを使う必要は必ずしもない。</p>
<p>だが、静的型付けの型宣言（型アノテーション）を使いたい場合は、引き続きTypeScriptの利用が必要となる。</p>
<ul>
<li><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Classes">クラス - JavaScript | MDN</a></li>
</ul>

<h1>その他のAltJS</h1>
<h2>CoffeeScript</h2>
<p>CoffeeScriptはAltJSのひとつで、後発のTypeScriptが登場する以前から存在し、かつてはAltJSの最前線だった。</p>
<ul>
<li><a href="https://www.codegrid.net/articles/cofeescript-1/">CoffeeScriptで学ぶJSの設計 | 第1回 CoffeeScriptとはなにか | CodeGrid</a></li>
<li><a href="https://qiita.com/raccy/items/fae9fc5923d78112d935">CoffeeScriptは本当に駄目なのか？ - Qiita</a></li>
</ul>

<h2>Dart</h2>
<p><a href="javascript_framework_dart.html">Dart</a>を参照のこと。</p>

<h2>Elm</h2>
<p><a href="elm.html">Elm</a>を参照のこと。</p>

<h2>Haxe</h2>
<p><a href="haxe.html">Haxe</a>を参照のこと。</p>

<h1>関連ページ</h1>
<h2>プロトタイプベースのオブジェクト指向</h2>
<p>JavaScriptでは、標準でプロトタイプベースの「委譲」と呼ばれるオブジェクト指向を行う。<a href="javascript_prototype.html">JavaScript（プロトタイプチェーン）</a>を参照のこと。</p>

<h2>型</h2>
<p><a href="type.html">型</a>も参照のこと。</p>

<h2>オブジェクト指向</h2>
<p><a href="oop.html">オブジェクト指向</a>も参照のこと。</p>

<h1>簡単な説明</h1>
<h2>AltJS（TypeScript, Dart, Elm）</h2>
<p>TypeScriptなどはJavaScriptでクラスベースの静的型付け言語を実現する。</p>
<p>TypeScriptではコンパイルされた後は型情報は残らず、コンパイルの時にチェックして通常のJavaScriptを吐く。</p>








</div></div> <!--page-->










<script type="text/javascript" src="../../js/jquery.toc.js"></script>
<script type="text/javascript" src="../../js/script.js"></script>
<script type="text/javascript" src="../../js/scriptfortoc.js"></script>
<script type="text/javascript" src="../../js/prettify.js"></script>
<script>prettyPrint();</script>
</body>
</html>