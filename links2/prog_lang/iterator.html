<!DOCTYPE html>
<html dir="ltr" lang="ja">
    <head>
        <title>イテレータとジェネレータの世界観 - from Assy</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="keywords" content="Assy,アッシー,詩,小説,物語,歴史,政治,経済,コンピュータ,パソコン,Linux,エッセイ,散文,哲学">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="../../css/style.css">
        <link rel="stylesheet" href="../../css/prettify.css" type="text/css">


<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">

    </head>
    <body>
<div class="page">
<script type="text/javascript" src="../../js/jquery.min.js"></script>
<script type="text/javascript" src="../../js/script_smartmenus.js"></script>
<script type="text/javascript" src="../../js/links2.js"></script>

<p><a href="index.html">プログラミング言語の世界観に戻る</a></p>
<div class="sidebar">
<iframe src="../../menus/prog_lang_skill_menu.html" class="sideiframe"></iframe>
</div>
<h1>イテレータとジェネレータの世界観</h1>
<p>イテレータとジェネレータに関する世界観です。<a href="functional_programming.html">関数型プログラミング</a>も参照のこと。</p>
<div id="toc"></div>
<div class="page_links">

<h1>イテレータ</h1>
<h2>イテレータ（反復子）とジェネレータ（yield）</h2>
<p>C++のSTLやJava、Python、Rubyなどの多くの言語が提供している機能として、「イテレータ（反復子）」というものがある。</p>
<p>これは、配列やコレクション、コンテナなどの各要素に対して、順にアクセスするための機能。</p>
<p>イテレータを取得して、next()などの関数を呼び出すことで、ひとつひとつの要素に順にアクセスできる。言語によってはfor文で使うこともできる。</p>
<p>また、イテレータと対応して使われることが多いのが、ジェネレータ。これはPythonやC#ではyieldと呼ばれるreturnと良く似たキーワードで行うことができる。一回の繰り返しに対して、一回の「yieldまでの処理」が行われる。よって、イテレータを一回実行すれば、ジェネレータ関数（yieldが記述された関数をジェネレータ関数と呼ぶ）が一回分実行される。</p>
<p>後日注記：ジェネレータとは「生産するもの」といった意味ですが、要するにfor文で反復する要素をyieldで「ひとつひとつ生み出す」ことができるのです。</p>
<p>後日注記：Pythonなどの言語では、イテレータとfor文は密接な関係にあります。Pythonでは、for文そのものが、イテラブルなオブジェクト（イテレータによる操作が可能なオブジェクト）に対する繰り返し実行処理であり、もしかすると「for文はイテレータのための構文」であるとすら言えるかもしれません。for文に与えることができるのはイテラブルなオブジェクト全般であり、リストやタプルや辞書以外であっても、イテレータさえ実装されていれば、Pythonではfor文で操作することができるのです。</p>
<p>下のリンク先はC++による最近のイテレータの解説であり、めちゃくちゃ難しいですが、イテレータの持つ可能性を感じられます。</p>
<ul>
<li><a href="https://qiita.com/yumetodo/items/245e94a0e85db9bf5cbb">イテレータの解説をするなんて今更佳代 - Qiita</a></li>
</ul>
<div class="edit_date">
<p>2023.01.20編集</p>
</div>

<h2>イテレータは反復処理のカプセル化</h2>
<p>僕は、イテレータの面白い点は、イテレータのインターフェースを実装したクラスは、共通の反復インターフェースから操作できる、というところにあると思う。</p>
<p>イテレータは単純な反復処理のためにも使えるが、イテレータのインターフェースを実装したクラスを自分で記述することで、「自分独自のイテレータ」を作ることができる。</p>
<p>この時、反復処理の内容で何をやるかは、クラスを作る側の自由。よって、とても高度で複雑な処理を、反復処理の中ですることができる。一見反復処理とは全く異なる処理であっても、イテレータインターフェースが実装されていれば、言語によってはfor文などからそのクラスを利用できる。</p>
<p>僕は、イテレータは反復処理のカプセル化と言えると思う。実装の詳細を知らなくても、共通の繰り返しインターフェースから、あらゆる拡張イテレータを操作できるのである。</p>
<p>また、イテレータの中で使うことができるのが、yield returnすなわちジェネレータである。C#やPythonなどで使えるこの機能は、for文からreturnと同じように値を返すことができるが、一回きりで終わりになるのではなく、繰り返し処理の中でひとつひとつ要素を「生み出す」ことができる。</p>
<p>イテレータとジェネレータを上手く使うことで、どんなデータでも反復処理、すなわち繰り返し処理が簡単にできる。これはfor文やwhile文の「構造化プログラミング」よりも先の「イテレータプログラミング」であると言えると思う。</p>
<p>後日注記：僕は、C#やPythonのジェネレータの良い点は、「言語機能であるfor文と特定のクラスであるイテレータとジェネレータを統合した」ということにあると思う。標準の組み込みのfor文で、繰り返し関数を応用的にインターフェース化し、再利用した。これこそ、オブジェクト指向プログラミングの真価の発揮ではないかと思う。</p>
<p>詳しくは以下の書籍が参考になります。</p>
<ul>
<li><a href="https://www.amazon.co.jp/Java%E8%A8%80%E8%AA%9E%E3%81%A7%E5%AD%A6%E3%81%B6%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E5%85%A5%E9%96%80-%E7%B5%90%E5%9F%8E-%E6%B5%A9/dp/4797316462">Java言語で学ぶデザインパターン入門</a></li>
</ul>

<h2>順番を自由に吐き出せ、繰り返しの数列と処理を分離できる</h2>
<p>イテレータは「全ての要素に対して順番に処理する」ことのできる機能ですが、全ての要素をどのように作り出し、そしてどのような順番をその順番とするかは、プログラマに任されています。</p>
<p>そのため、たとえばジェネレータを使って「素数の一覧オブジェクト」を作って、順番に処理する際に素数をひとつひとつ「作り出す」ように反復させることもできます。</p>
<p>また、イテレータを使うことで、繰り返しの数列と処理を分離できます。反復して要素を作成する処理はデータベースの機能を使って、表示処理をHTMLへの出力としたりすることが可能です。</p>

<h2>イテレータの使いどころ</h2>
<p>たとえば、C++のSTLコンテナのvectorは、可変長の非連続的データであるため、ポインタをインクリメントしてカーソルに使うことはできません。インデックス変数のインクリメントを使った添え字アクセスも難しいです。</p>
<p>このような時に、STLではイテレータを使って、コンテナの要素をひとつひとつ順番にアクセスできます。</p>
<p>JavaScriptなどにもイテレータはありますが、JavaScriptのイテレータは「繰り返しのみに特化したオブジェクト」とされます。配列からイテレータを作成すれば、これを配列名の代わりにfor文に与えてやれば順序的にアクセスできます。</p>
<p>イテレータは、ジェネレータと組み合わせることで、一行一行読み込むたびにその一行を処理したり、といったことができます。</p>
<p>単に、インデックスや添え字やポインタを使った場合、配列の要素の数や場所が変わることも、データ構造や中身のロジックの変化によっては起こり得ます。このような場合にイテレータを使うことがよいとされます。</p>
<p>詳しくは以下の書籍が参考になります。</p>
<ul>
<li><a href="https://www.amazon.co.jp/%E3%83%91%E3%83%BC%E3%83%95%E3%82%A7%E3%82%AF%E3%83%88JavaScript-PERFECT-4-%E4%BA%95%E4%B8%8A-%E8%AA%A0%E4%B8%80%E9%83%8E/dp/477414813X">パーフェクトJavaScript (PERFECT SERIES 4)</a></li>
</ul>

<h2>ジェネレータ</h2>
<p>ジェネレータはイテレータとともに用意されていることが多い機能。</p>
<p>通常のイテレータと同様、配列のような連続したデータと同じように反復処理をかけることができるが、実際に配列をデータ構造として持っているわけではなく、呼び出されるたびに要素を自動作成することができる。</p>
<p>いわば「反復処理の仮想化」のようなもの。Pythonではfor文に対して関数からyield returnで値を返し続けることができる。</p>

<h2>順番は重要</h2>
<p>プログラミングにおいては、「順番」すなわち「順序付けされていること」は非常に重要です。</p>
<p>配列や単なる繰り返しだけではなく、探索やソートのようなアルゴリズムにおいても、リストやツリーをトラバース（順序的にアクセス）する場合においても、あるいは並列処理やスケジューリングにおいて実行プロセスを次々と切り替える場合や、イベントループを行う場合、データベースからデータを一行ずつHTMLに変換して表示させる場合など、あらゆるプログラミング技術が「順番」ということに基づいています。</p>
<p>順番は、抽象的なレイヤーにしか存在しないものではなく、たとえばHTMLのヘッダータグから目次を自動作成する場合などは、単なる順序付けではなく、構造的で複雑な順序付けを高度に行う必要があります。</p>
<p>このような場合に、順序をひとつひとつ辿っていくという意味で、イテレータと呼ばれるアクセスの方法が提供されています。</p>
<p>イテレータを使うことで、順序付けされたデータをひとつひとつアクセスすることができます。そのデータが、どのような型のオブジェクトか、あるいはどのような具体的な要素の種類が含まれているか、ということは、イテレータを使う上では重要ではありません。どのような順序付けされたデータに対しても、「次の要素を取り出す」ということができます。</p>
<p>イテレータを使うことにより、順序付けされたデータの型や要素の種類を考えて、別々の書き方をする必要がなくなります。そのため、現在使っているデータの型や要素の種類が変わっても、それを使う側のコードを書き換えることなく、実装の内部だけを書き換えることで対応することができます。このため、さまざまな場所にある点在したコードを書き換えなくても、カプセル化された中の限られた実装部分だけを書き換えることで対応することができます。APIを変えなくても実装の内部だけを変えるだけで済みます。</p>
<p>イテレータを使う上で、データは配列のように静的に変わらず存在している必要はなく、要素ひとつひとつを取り出しながら自動的に要素が生成されるようなデータであっても構いません。これを「ジェネレータ」といいます。その要素にアクセスした時点で要素が生成されるため、最初から要素が変わらず存在しているわけではない、雑多なイベントへの応答などに応用例が考えられます。実際のジェネレータでは、ファイルから一度に全部の行を読み出すのではなく、一行ずつバッファを使って読み出すためにyield returnを使う例などが主に挙げられます。バッファに一気にすべてのデータを格納せず、少しずつ格納してyield returnで返すことができるため、使用メモリが大幅に削減されます。</p>
<div class="edit_date">
<p>2023.04.06</p>
</div>

<h1>各言語のAPI</h1>
<h2>C++</h2>
<p><a href="cpp_stl_libs.html">C++（STL・ライブラリ）</a>を参照のこと。</p>

<h2>Java</h2>
<p><a href="java_lib_list.html">Java（コレクションと配列）</a>を参照のこと。</p>

<h2>Python</h2>
<p><a href="python_intro_flow.html">Python入門（制御フロー）</a>や<a href="python_intro_functional.html">Python入門（関数型プログラミングの機能）</a>を参照のこと。</p>

<h2>C#</h2>
<p><a href="csharp.html">C#</a>を参照のこと。</p>

<h1>簡単な説明</h1>
<h2>イテレータ</h2>
<p>反復処理を行うための反復子。</p>

<h2>ジェネレータ</h2>
<p>yield returnなどにより、「ひとつひとつの要素をその都度生成する」かのように、for文の繰り返しごとに新しい値を返す。</p>


</div></div> <!--page-->










<script type="text/javascript" src="../../js/jquery.toc.js"></script>
<script type="text/javascript" src="../../js/script.js"></script>
<script type="text/javascript" src="../../js/scriptfortoc.js"></script>
<script type="text/javascript" src="../../js/prettify.js"></script>
<script>prettyPrint();</script>
</body>
</html>