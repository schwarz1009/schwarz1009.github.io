<!DOCTYPE html>
<html dir="ltr" lang="ja">
    <head>
        <title>プログラミング作法の世界観３C（ポインタとメモリ管理） - from Assy</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="keywords" content="Assy,アッシー,詩,小説,物語,歴史,政治,経済,コンピュータ,パソコン,Linux,エッセイ,散文,哲学">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="../../css/style.css">
        <link rel="stylesheet" href="../../css/prettify.css" type="text/css">


<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">

    </head>
    <body>
<div class="page">
<script type="text/javascript" src="../../js/jquery.min.js"></script>
<script type="text/javascript" src="../../js/script_smartmenus.js"></script>
<script type="text/javascript" src="../../js/links2.js"></script>

<p><a href="index.html">プログラミング言語の世界観に戻る</a></p>
<div class="sidebar">
<iframe src="../../menus/prog_lang_skill_menu.html" class="sideiframe"></iframe>
</div>
<h1>プログラミング作法の世界観３C（ポインタとメモリ管理）</h1>
<p>プログラミング作法に関する世界観３C（ポインタとメモリ管理）です。<a href="c_pointer.html">Cの世界観４（配列とポインタ）</a>も参照のこと。</p>

<h2>関連ページ</h2>
<ul class="defaultlist list6 menu_list">
<li><a href="programming_intro.html">プログラミングをはじめよう</a></li>
<li><a href="programming_basic.html">プログラミング作法（１．基本）</a></li>
<ul>
<li><a href="programming_method.html">２．プログラミング入門</a></li>
<li><a href="programming_expert.html">３．エキスパート</a></li>
<ul>
<li><a href="programming_flow.html">３A．制御フロー</a></li>
<li><a href="programming_data.html">３B．データ操作</a></li>
<li><b>３C．ポインタとメモリ管理</b></li>
</ul>
<li><a href="programming_tech.html">４．テクニック</a></li>
</ul>
</ul>

<div id="toc"></div>
<div class="page_links">

<h1>ポインタとメモリ管理</h1>
<h2>ポインタと参照型変数</h2>
<p>ポインタに限らず、参照型の変数は、「同じ領域を違う名前が参照する」という考え方をします。このため、メモリアドレス（変数の場所）をポインタとして操作するC言語だけではなく、PHPなどでも同様に参照型の考え方を良く用いるため、C言語プログラマではなくても、「参照型」という考え方は知っておきましょう。</p>

<h2>複数の名札から変数の入った箱そのものにアクセスする</h2>
<p>たとえば、C言語で</p>
<pre class="prettyprint">
int x = 10;
</pre>
<p>とするのを、「int型の変数xに整数値10を代入する」と表現しますが、この時、変数とは「名札」とか「値を入れる箱」などと言った説明がされると思います。</p>
<p>先の例で言えば、xという「名札」のついた「箱」に、10という「整数値」を入れます。</p>
<p>この時、なんとなく、「名札＝箱」だと思っていると思いますが、ポインタを使うと、ひとつの「箱」に対して複数の「名札」を付けることができます。</p>
<p>たとえば、</p>
<pre class="prettyprint">
int *y = &x;
*y = 20;
printf("%d", x); /* 20 */
</pre>
<p>とすると、int型変数へのポインタyは、xと「同じ箱」を指しながら、「別の名前」を使っています。そのため、yの参照先を変えると、xの参照先も変わるのです。</p>
<p>プログラミングにおけるポインタを理解するためには、このように「名札と箱は必ずしもイコールではない」と考える必要があります。</p>
<p>なぜポインタを使うのか、という答えは、ポインタでしか作れないデータ構造や、ポインタを使った方が作りやすい関数などがあるためです。特に、連結リストを作ったり、あるデータ構造体の一部として別の変数を参照したい場合、あるいはカーネルのファイルバッファにアクセスしたい場合など、さまざまな低レベルな部分でポインタを使います。</p>
<p>そう、ポインタとは「名札ごとに箱を作るのではなく、たくさんの名札で箱を共有する（値の共有ではない）」ということです。そして、この箱がメモリアドレスなのです。</p>

<h2>もしもJavaにポインタがあったとしたら</h2>
<p>僕は、ポインタは変数を名前で管理するのとは別に、絶対的な位置によって管理・参照する方法だと考えると分かりやすいと思います。</p>
<p>Javaにポインタはありませんが、もしもJavaにポインタがあったとしたら、以下のようになるでしょう。</p>
<pre class="prettyprint">
Address adr = str.getAddress();
adr.setValue("text");
System.out.println(str); // textと表示される。
</pre>

<h2>スタックとヒープ</h2>
<p>int num = 1;のように、スコープがはっきりと分かっている変数はスタックで確保され、malloc()などの動的に確保したメモリ領域はヒープで確保される。</p>
<p>スタックは、上にどんどん積み上げていくイメージで、最後に積んだデータを最初に解放する。</p>
<p>ヒープは、より動的に確保するために、malloc()を使ってデータを確保するが、自分の手でデータをfree()で解放しなければならない。</p>
<!--
<p>と言うことなのかもしれないが、全く分かっていないので、間違いを書いているかもしれない。本当はもっと奥が深いし、そんな単純なことではない。</p>
-->
<ul>
<li><a href="http://ufcpp.net/study/computer/MemoryManagement.html">メモリ管理 - ++C++; // 未確認飛行 C</a></li>
</ul>
<p>後日注記：ヒープ領域は実行中に大きさが変わる。また、スコープを抜けてもmalloc()したメモリを自分のタイミングでfree()するまでメモリ上に残り続ける。また、サイズが実行するまで分からなくても、実行中にサイズを動的に決められる。そして、スタック領域には扱える大きさに制限があるが、ヒープはそのような制限がない。そのため、サイズの分からない、スコープにかかわらず残り続けてほしいような、巨大なデータを確保するのに向いている。</p>
<ul>
<li><a href="https://rinatz.github.io/cpp-book/ch06-01-memory-areas/">6.1. メモリ領域 - ゼロから学ぶ C++</a></li>
</ul>
<div class="edit_date">
<p>2023.05.17編集</p>
</div>

<h2>メモリアドレス空間</h2>
<p>Linuxでは、プログラムがメモリ上にロードされると、カーネルがメモリアドレス空間にテキスト領域（プログラムコードを格納する）、ヒープ領域、スタック領域を各プロセスごとに割り当てる。</p>
<p>このうち、ヒープ領域とスタック領域がプログラムのデータの格納のために使われる。</p>
<p>機械語の論理アドレスは、カーネルによって仲介され、メモリ上の物理アドレスへと翻訳される。それぞれに割り当てられたメモリは「ページ」という小さな単位でカーネルによってメモリ上に領域を割り当てられる。</p>
<p><a href="../linux/linux_kernel_mm.html">Linuxカーネル（メモリ管理）</a>も参照のこと。</p>

<h2>動的なメモリ確保</h2>
<p>ポインタは、動的に確保したメモリ領域を配列としてアクセスしたり、配列の要素にひとつひとつ順番にアクセスするために使うこともある。</p>
<p>動的なメモリ確保の例は、以下のようになる。</p>
<ul>
<li><a href="http://math.shinshu-u.ac.jp/~hanaki/c-lang/c06.html">06 回 動的なメモリの確保 - Akihide Hanaki</a></li>
</ul>

<h2>スマートポインタとガーベッジコレクション</h2>
<p>Javaでは、ガーベッジコレクションがあるため、malloc()やfree()のようなメモリ管理に煩わされることが無い。</p>
<p>だが、C++のようなガーベッジコレクションがない言語でも、最近はスマートポインタを使うことで勝手に使われないメモリを破棄してくれる方法が存在する。</p>
<p>Rustでは、ムーブセマンティクスと所有権の考え方によって、GCを使わずにして不要なメモリを削除する方式を提供した。</p>
<p>また、ガーベッジコレクション（GC）がある言語でも、GCのやり方はそれぞれの言語によって違う。参照カウント方式、マーク・アンド・スイープ方式、コピーGC方式などが存在する。</p>
<ul>
<li><a href="https://ja.wikipedia.org/wiki/%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3">ガベージコレクション - Wikipedia</a></li>
<li><a href="https://geechs-magazine.com/tag/tech/20160229">5分で分かるガベージコレクションの仕組み | geechs magazine</a></li>
<li><a href="https://qiita.com/hmito/items/db3b14917120b285112f">C++11スマートポインタ入門</a></li>
<li><a href="https://qiita.com/myhr47/items/262b8b8f1edd8097d03c">Rustの所有権システムについて - Qiita</a></li>
<li><a href="https://qiita.com/cactaceae/items/2c70a9947364c60ec100">Rustの所有権に親しむ - Qiita</a></li>
<li><a href="https://qiita.com/nebutalab/items/1d7a03c36c087c3f6360">Rustのポインタ（所有権・参照）・可変性についての簡単なまとめ - Qiita</a></li>
</ul>
<p><a href="java_gc.html">Java（２C．ガーベッジコレクションと例外）</a>も参照のこと。</p>

<h2>メモリアロケータを自前で実装する</h2>
<p>ゲームなどでカスタムメモリアロケータを自前で実装する方法には以下が参考になる。</p>
<ul>
<li><a href="http://marupeke296.com/CPP_No18_allocator.html">その18 最低限のカスタムメモリアロケータ - C++踏み込み編 - ゲームつくろー！ - マルペケつくろーどっとコム</a></li>
<li><a href="https://www.slideshare.net/alwei/ss-11521742">カスタムメモリマネージャと高速なメモリアロケータについて - SlideShare</a></li>
<li><a href="https://qiita.com/nanashi/items/ad67417bf231fb86833b">自作メモリアロケータ - Qiita</a></li>
<li><a href="https://qiita.com/jun_moka/items/50d24e7a2709e19234d9">C++の簡単なメモリアロケータ実装 - Qiita</a></li>
</ul>

<h2>なんであれアドレスを必要とする場合は意外と多い</h2>
<p>ポインタの使いどころとして、「なんであれ変数のアドレスを必要とする場合は意外と多い」というのが言えます。</p>
<p>たとえば、文字列や配列をアドレスからアクセスする場合に、その文字列や配列の「最初の位置」に、「アドレスというラベル」を保持することで、そのラベルから実体へアクセスします。</p>
<p>動的なメモリ確保についても同じで、確保した動的メモリ領域に「アドレスというラベル」からアクセスするのです。</p>
<p>言ってみれば、一種の「ファイル名」あるいは「インデックス」のようなものです。アドレスという「その場所を指し示す位置情報」があることで、どこからでもその位置情報にアクセスできるのです。</p>
<p>これは、たとえば、引数のポインタや参照型変数、あるいはオブジェクト指向の動的なインスタンスあるいはクラス内の動的メンバについても同様で、「位置情報を持っていることで、どこからでもダイレクトにアクセスすることができる」また「ダイレクトにアクセスする変数を自分で削除しない限り永続的に保持することができる」ということを意味します。</p>
<p>データ構造などでも、「位置情報を保管した変数からアクセスする」ということができます。たとえば連結リストの次のメンバをポインタで保持することで、「位置情報をメンバとして維持し続けることができる」のです。これは、単にポインタというだけではなく、「そのポインタを操作する関数処理までを考えた上でのデータ構造」であると言えます。ここから、ポインタは単なる位置情報ではなく、アルゴリズムによって処理されるデータ構造になり、話はオブジェクト指向のカプセル化まで広がっていくのです。</p>

<h2>ムーブセマンティクス</h2>
<p>自分の書いたブログ「神々とともに生きる詩人」<a href="../../diary/blog_frey/2021.01.21.html">2021/01/21</a>より。</p>
<p>ムーブセマンティクスにおいては、変数をコピーした時に、同じだけの領域を確保して複製するのではなく、ポインタだけをコピーして、元の変数は使えなくなる。</p>
<p>ポインタしかコピーしなくても、ある場所から別の場所に変数を移動したように見えるため、ムーブセマンティクスと呼ばれる。</p>
<p>巨大なベクター配列をコピーする際などに、効率的にデータを別の場所から参照できる。</p>
<p>常に2つの変数を保持しなくても、あっちやらこっちやらと移動させて使うイメージである。</p>
<p>後日注記：このムーブセマンティクスの説明は、明らかに間違っている。正しくは以下のようなページを参照してほしい。</p>
<ul>
<li><a href="https://rinatz.github.io/cpp-book/ch06-04-move-semantics/">6.4. ムーブセマンティクス - ゼロから学ぶ C++</a></li>
</ul>

<h2>ポインタの用途</h2>
<p>自分の書いたブログ「神々とともに生きる詩人」<a href="../../diary/blog_frey/2021.01.21.html">2021/01/21</a>より。</p>
<p>僕は、ポインタは配列やリストと関係が深いと思う。</p>
<p>配列はメモリ上の連続データであるため、ポインタを通じて連続的にアクセスできる。</p>
<p>文字列でも、構造体でも同様。</p>
<p>このように、メモリ上の連続したデータに対する、カーソルとして利用する。</p>
<p>また、連結リストでは、今の要素と次の要素を紐付けする役割を、ポインタが担う。</p>
<p>それから、ポインタは低レベル処理と、参照型変数として使われる。</p>
<p>システムのバッファを保持・参照したり、低レベル処理の中で動的にメモリ確保や参照や操作や解放をするために、ポインタは使われる。</p>
<p>ある意味、C言語における自由度とパフォーマンスを確保するために、利便性や安全性を犠牲にした結果である。</p>
<p>ヒープ領域の確保や、実行時にしかサイズの分からないメモリ確保に、ポインタは使われる。</p>
<p>最後に、参照としての利用。</p>
<p>関数の内部から、呼び出せた時にはじめて決定される、参照型変数やコールバック関数としての利用である。</p>
<p>単なるリンクだけでなく、関数型プログラミングとしての側面や、あるいは、コピーの際のコストの軽減、オブジェクト指向や準グローバル変数としての利用も考えられる。</p>
<p>ポインタの用途の例について、より正しい内容は<a href="https://www.amazon.co.jp/Reading-%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B6%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%E6%8A%80%E6%B3%95-%E3%83%97%E3%83%AC%E3%83%9F%E3%82%A2%E3%83%A0%E3%83%96%E3%83%83%E3%82%AF%E3%82%B9%E7%89%88-Diomidis-Spinellis/dp/4839956693">Code Reading ~オープンソースから学ぶソフトウェア開発技法~ (プレミアムブックス版)</a>が参考になります。上記は、この本を読んだうえで、自分なりに違う内容を書きました。</p>

<h2>メモリ上の物理データと、それを指し示すポインタがあってデータが成り立つ</h2>
<p>C言語では、メモリ上の物理データと、そのアドレス（番地）を指し示すポインタがあって、はじめてデータが成り立ちます。</p>
<p>一見すると、「物理データだけでいいじゃないか」と思われるかもしれませんが、C言語ではそうではありません。</p>
<p>まず、メモリ上のそれぞれのアドレスに格納される「物理データ」があり、その物理データをひとつひとつメモリアドレスを指し示すことで参照する「ポインタ」があります。</p>
<p>物理データとポインタは、このようにセットで使います。物理データだけではなく、ポインタがあることによって、C言語のデータへのアクセスは成り立つのです。</p>
<p>なので、なんらかのポインタがあった場合、そのポインタはNullポインタでない限り、どこかにある物理データを指し示しています。そして、この指し示しているポインタが指し示す先は、新しいメモリアドレスをポインタに代入することで変えられます。実際の物理データを変更しなくても、ポインタの指し示す場所を変えるだけで、効率的に別々のデータにアクセスできます。そのため、物理データを破壊することなく、メモリに存在するさまざまな物理データに自由にアクセスできます。</p>
<p>ポインタは、低水準のOSのようなプログラムを書くために必須となります。OSのような低レベルのソフトウェアでは、メモリを直接操作できなければならないからです。C/C++よりも高水準の言語であるJavaにはポインタは存在しません。C#の場合、unsafeと呼ばれる低レベルのメモリを「破壊」することは、明示的にunsafeコードであることを記述しない限り、基本的にできません。JavaやC#ではその代わり、ガーベッジコレクションのような自動的なメモリの解放機構を使えます。逆に、C/C++では低レベルのメモリを扱うことができますが、ガーベッジコレクション機構のようなものは、自分で参照カウントを実装したりしない限り、デフォルトでは使えません（一応、C++にはスマートポインタがあります）。</p>

<h2>ポインタにすればなんであろうが動く</h2>
<p>結局のところ、ポインタの利点とは、なんであろうがポインタにすれば動くということです。</p>
<p>たとえば、以下のようなコードがあります。</p>
<pre class="prettyprint">
struct object x;
for(;;){
    func(x);
}
</pre>
<p>このコードで、func()の中から参照できるのは「その場その場のx」だけです。</p>
<p>ですが、func()の中で、xのさまざまな情報にアクセスしたい時があります。場合によっては書き換えることもあるでしょう。</p>
<p>このような時には、ポインタにしてしまいましょう。</p>
<pre class="prettyprint">
struct object x;
for(;;){
    func(&x);
}
</pre>
<p>そう、こうするだけで、関数の中から外側のデータになんでもアクセスできてしまうのです。</p>
<p>ポインタの使い時は、そんな感じです。難しく考える必要はありません。「ポインタにすればなんであろうが動く」のです。</p>

<h2>共通の参照先データを指し示す別名として使う</h2>
<p>実際のところ、ポインタは、共通の参照先データを指し示す別名として使います。</p>
<p>複数の関数から、共通の「同じ場所」にあるデータをどこからでも操作する場合に、同じ参照先を指し示す「別名」として操作します。</p>
<p>ポインタを使うメリットは、さまざまな場所から「同じ場所」を参照することができること、別の場所から参照だけではなく「変更」できること、「巨大なデータの一部だけ」を参照できること、複製するよりも「オーバーヘッドが小さい」ことです。</p>
<p>ポインタはC言語の機能ですが、Javaのようなオブジェクト指向の言語ではポインタがありません。その代わり、オブジェクトは参照型変数として扱われます。このような言語であっても、基本はポインタと同じで、参照型のオブジェクトを「同じ場所」を指すポインタとして使います。クラスの中のメンバ変数も、同様に「同じ場所」をそれぞれのメソッドから指し示すポインタであると考えられます。</p>
<p>同じデータにアクセスし、参照し、変更するということは、このようなポインタのない言語であっても、プログラミングを行う上で基本となります。</p>


</div></div> <!--page-->










<script type="text/javascript" src="../../js/jquery.toc.js"></script>
<script type="text/javascript" src="../../js/script.js"></script>
<script type="text/javascript" src="../../js/scriptfortoc.js"></script>
<script type="text/javascript" src="../../js/prettify.js"></script>
<script>prettyPrint();</script>
</body>
</html>