<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet"  href="style.css">
<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">
<title>Linuxカーネル - schwarz1009</title>

</head>
<body>
<p><a href="index.html">トップページに戻る</a></p>
<iframe src="menu_menu.html" class="iframe_menu"></iframe>
<p>AUTHOR: schwarz1009<br>
TITLE: Linuxカーネル<br>
BASENAME: 2020/06/26/204700<br>
STATUS: Publish<br>
ALLOW COMMENTS: 1<br>
CONVERT BREAKS: 0<br>
DATE: 06/26/2020 20:47:00<br>
CATEGORY: Linux<br>
CATEGORY: CPU・メモリ・カーネル<br>
CATEGORY: おすすめ

</p>
<ul class="table-of-contents">
    <li><a href="#Linuxカーネル">Linuxカーネル</a></li>
    <li><a href="#マルチタスク">マルチタスク</a><ul>
            <li><a href="#LinuxはマルチタスクのOS">LinuxはマルチタスクのOS</a></li>
            <li><a href="#プロセスとスレッド">プロセスとスレッド</a></li>
            <li><a href="#コンテキスト切り替え">コンテキスト切り替え</a></li>
            <li><a href="#プロセスディスクリプタ">プロセスディスクリプタ</a></li>
            <li><a href="#仮想アドレス空間">仮想アドレス空間</a></li>
            <li><a href="#ページアドレッシング">ページアドレッシング</a></li>
            <li><a href="#アドレス空間の構造">アドレス空間の構造</a></li>
        </ul>
    </li>
    <li><a href="#割り込み">割り込み</a></li>
    <li><a href="#デバイスドライバ">デバイスドライバ</a></li>
    <li><a href="#ファイルシステム">ファイルシステム</a></li>
    <ul>
            <li><a href="#コピーオンライトとスナップショット">コピーオンライトとスナップショット</a></li>
        </ul>
    </li>
    <li><a href="#ネットワーク">ネットワーク</a></li>
    <li><a href="#入出力とシステムコール">入出力とシステムコール</a></li>
    <li><a href="#シグナル">シグナル</a></li>
    <li><a href="#カーネルはシステムコールを待ち受けるだけ">カーネルはシステムコールを待ち受けるだけ</a></li>
    <li><a href="#開発には英語力が必要">開発には英語力が必要</a></li>
</ul>
<div class="section">
    <h3 id="Linuxカーネル">Linuxカーネル</h3>
    <p>Linuxカーネルについて書きたいと思う。<br />
参考文献：</p>
    <ul class="some_lists">
        <li><a href="https://www.amazon.co.jp/%E3%81%B5%E3%81%A4%E3%81%86%E3%81%AELinux%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-Linux%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B9%E3%82%8Bgcc%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E7%8E%8B%E9%81%93-%E9%9D%92%E6%9C%A8-%E5%B3%B0%E9%83%8E/dp/4797328355">ふつうのLinuxプログラミング Linuxの仕組みから学べるgccプログラミングの王道</a></li>
        <li><a href="https://www.amazon.co.jp/%E8%A9%B3%E8%A7%A3-Linux%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB-%E7%AC%AC3%E7%89%88-Daniel-Bovet/dp/487311313X">詳解 Linuxカーネル 第3版</a></li>
        <li><a href="https://www.amazon.co.jp/%E3%82%AA%E3%83%9A%E3%83%AC%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E2%80%95%E8%A8%AD%E8%A8%88%E3%81%A8%E7%90%86%E8%AB%96%E3%81%8A%E3%82%88%E3%81%B3MINIX%E3%81%AB%E3%82%88%E3%82%8B%E5%AE%9F%E8%A3%85-S-%E3%82%BF%E3%83%8D%E3%83%B3%E3%83%90%E3%82%A6%E3%83%A0/dp/4894710471">オペレーティングシステム―設計と理論およびMINIXによる実装</a></li>
        <li><a href="http://en.tldp.org/LDP/tlk/tlk.html">The Linux Kernel</a></li>
    </ul>

</div>
<div class="section">
    <h3 id="マルチタスク">マルチタスク</h3>
    
<div class="section">
    <h4 id="LinuxはマルチタスクのOS">LinuxはマルチタスクのOS</h4>
    <p>まず、LinuxカーネルはマルチタスクなOSのカーネルである。<br />
マルチタスクとは、「複数のプログラムを同時に並列実行できる」ということ。</p>

</div>
<div class="section">
    <h4 id="プロセスとスレッド">プロセスとスレッド</h4>
    <p>ここで、プログラムにはプロセスとスレッドがあることが重要である。<br />
プロセスは、それぞれに個別の独立したメモリ領域が与えられる。<br />
それに対して、スレッドはプロセスの中に存在する並列処理であり、<br />
同じメモリ領域を参照することができる。<br />
このため、マルチスレッド環境では、排他制御を行う「ロック」が肝心となる。<br />
ロックを適切に行うことで、スレッドセーフな関数を作らなければならない。<br />
プロセスにおいても、プロセス間通信（IPC）と呼ばれる機構を使うことで、<br />
メモリを共有したり、簡単な排他制御を行う（セマフォ）ことが可能となっている。</p>

</div>
<div class="section">
    <h4 id="コンテキスト切り替え">コンテキスト切り替え</h4>
    <p>プログラムがもしあったとして、それをマルチタスクで実行するためにどうするか。<br />
プログラムは、実際、機械語でCPU命令とメモリアドレスが記述されているため、<br />
単純に考えれば、CPUとメモリがそれぞれのプログラムに必要となる。<br />
しかしながら、マルチタスクのOSでは、<br />
プログラムの命令を、とても小さな時間で切り替えながら実行することで、<br />
CPUの仮想化を実現する。<br />
つまり、プログラムの実行しているレジスタの内容や、プログラムカウンタなどを、<br />
task_structと呼ばれる構造体に退避させて、<br />
プログラムを「安全に停止させる」ことができればいい。<br />
この上で、プログラムを次々に停止・再実行する。<br />
これを「コンテキスト切り替え」と呼ぶ。</p>

</div>
<div class="section">
    <h4 id="プロセスディスクリプタ">プロセスディスクリプタ</h4>
    <p>カーネルはプロセスを管理するために、「プロセスディスクリプタ」と呼ばれるプロセスの情報によってプロセスを管理する。<br />
カーネルがプロセスの実行を停止すると、CPUレジスタ内のさまざまな情報がプロセスディスクリプタの中に退避される。<br />
この情報には、プログラムカウンタや汎用レジスタ、浮動小数点レジスタ、プロセッサ制御レジスタ、メモリ管理レジスタなどが含まれる。<br />
カーネルがプログラムの再開を決めると、プロセスディスクリプタに退避された情報を使って、停止されたCPUレジスタを復旧する。</p>

</div>
<div class="section">
    <h4 id="仮想アドレス空間">仮想アドレス空間</h4>
    <p>また、メモリ領域については、<br />
カーネルがハードウェアのMMUという機構を上手く使うことで、<br />
プログラムが実際のメモリ領域（論理アドレスやリニアアドレスと呼ぶ）にアクセスした段階で、<br />
カーネルがそれを物理アドレスに翻訳する。<br />
このようにすることで、カーネルはメモリ領域を全てのプログラムに「個別に与える」ことができる。<br />
このような仕組みを「仮想アドレス空間」と呼ぶ。</p>

</div>
<div class="section">
    <h4 id="ページアドレッシング">ページアドレッシング</h4>
    <p>Linuxはメモリアドレスをページと呼ばれる小さな単位で管理している。<br />
Linuxでは効率化と使用メモリ領域の削減のために、<br />
三段階のページアドレッシングを採用しており、<br />
大きなものから順に、<br />
ページグローバルディレクトリがあり、<br />
その中にページミドルディレクトリがあり、<br />
その中にページテーブルがあり、<br />
ページテーブルにおいて実際のページ領域をマッピングする。</p>

</div>
<div class="section">
    <h4 id="アドレス空間の構造">アドレス空間の構造</h4>
    <p>アドレス空間には、<br />
・テキスト領域（機械語のプログラムコードが入る）<br />
・ヒープ領域（malloc()が管理する）<br />
・スタック領域（ローカル変数や関数の引数）<br />
などがあり（ほかにデータ領域やBSS領域がある）、プロセスが作られると割り当てられる。<br />
基本的に、プロセスを実行すると、そのプロセスに対してテキスト領域、ヒープ領域、スタック領域が割り当てられることを知っておけば良い。</p>

</div>
</div>
<div class="section">
    <h3 id="割り込み">割り込み</h3>
    <p>カーネルは、IOデバイスにアクセスする時点で、<br />
IOデバイスの処理の終了を待機するが、<br />
IOデバイスはプログラムの命令よりも動作が遅いので、<br />
いちいちIOデバイス処理を待っていたのでは効率が悪い。<br />
そのため、カーネルはIOデバイス処理を待つ間に、<br />
必要とあれば別の処理を行う。<br />
そして、IOデバイスの処理が終わった段階で、<br />
カーネルに対して「割り込み」を行う。<br />
割り込まれた時、カーネルはIOデバイスの処理の完了を知り、<br />
その後の命令を実行する。</p>

</div>
<div class="section">
    <h3 id="デバイスドライバ">デバイスドライバ</h3>
    <p>実際のところ、カーネルはデバイスコントローラの詳細を<br />
デバイスドライバという小さなソフトウェアモジュールによって知っている。<br />
カーネルにおいて、実際のデバイスの詳細を知っているのは、<br />
デバイスドライバだけである。<br />
デバイスには、キャラクタ型デバイスとブロック型デバイスがある。<br />
キャラクタ型デバイスは、その時その時の状況を、<br />
バイト列（文字列）によって知らせるようなデバイスであり、<br />
システムコールのストリームを通じて操作できる。<br />
ブロック型デバイスは、内部にファイルシステムが存在するデバイスであり、<br />
ファイル処理APIを通じてアクセスする。<br />
キャラクタ型デバイスは、ランダムアクセス（好きな時に好きな場所のデータを知ること）ができないが、<br />
ブロック型デバイスは、ランダムアクセスができる。</p>

</div>
<div class="section">
    <h3 id="ファイルシステム">ファイルシステム</h3>
    <p>Linuxカーネルでは、モノリシックカーネルであるため、<br />
ファイルシステム処理がカーネルに統合されている。<br />
ブロック型ファイルシステムのext2やext4が標準的に使われるが、<br />
B-Tree型のファイルシステムであるReiserFS, XFS, JFSなども使うことができる。<br />
また、次世代の（おそらくZFSを超える）ファイルシステムであるBtrfsも開発されている。<br />
LinuxカーネルではVFSの仕組みにより、<br />
ファイルシステムが変わってもシステムコールのAPIは変わらない。<br />
どのファイルシステムにも、同じようにプログラムからアクセスできる。<br />
また、ジャーナリングに対応したファイルシステムでは、<br />
一度マシンを強制終了しても、ファイルやデータが消え去ることがない。<br />
また、内部的にはi-nodeと呼ばれるインデックス処理を行っている。<br />
全てのファイルにはi-nodeから参照できる。</p>

<div class="section">
    <h4 id="コピーオンライトとスナップショット">コピーオンライトとスナップショット</h4>
    <p>BtrfsやZFSは、コピーオンライトという仕組みを採用している。コピーオンライトでは、複製された時に「全てを複製」するのではなく、データのほとんどを共有状態に置き、実際に書き込みが行われた時点でその部分だけを書き込み・複製する。これにより、コピー速度が著しく高速になり、リソース空間の節約になる。<br />
コピーオンライトでは、元のデータを読み込み専用にし、読み出す時は共有データから読み出す。そして書き込みが必要になればその時に複製を作成する。<br />
メモリやストレージだけではなく、Linuxカーネルではfork()などの親プロセス・子プロセスの関係でも、コピーオンライトで処理が行われている。<br />
また、コピーオンライトではデータを書き込む際に既存のデータに書き込むのではなく、ディスク上の新しい場所に書き込み、完了した上で元のデータを削除するため、書き込みの不具合による破損がなくなる。<br />
また、スナップショットは、データを取得した時点の瞬間のデータを保持する仕組み。コピーオンライトとともに使うことで、毎日スナップショットをとってもそんなに大きくデータを消費しない。</p>

</div>
</div>
<div class="section">
    <h3 id="ネットワーク">ネットワーク</h3>
    <p>Linuxカーネルはネットワークをサポートしており、<br />
BSDソケットインターフェースからネットワーク通信ができる。<br />
BSDソケットは、互いに2つのソケットが繋がると有効になり、<br />
片方に書き込むと片方から読み込むことができる。<br />
TCPやUDPもサポートされている。<br />
TCPでは、再送制御などの多くの機能がある。<br />
UDPには、そうした機能がない代わり、ビデオや音声を送ったりする時に、<br />
誤りを無視して高速に通信することができる。<br />
BSDソケットは多くの場合サーバー・クライアントシステムであり、<br />
片方のサーバが待ち受けをし、そのサーバに対してクライアントが接続する。</p>

</div>
<div class="section">
    <h3 id="入出力とシステムコール">入出力とシステムコール</h3>
    <p>また、Linuxでは端末を用いた入出力が可能である。<br />
端末のデバイスファイルは、多くの場合/dev/tty0が第一の仮想コンソールである。<br />
Linuxにおいては、標準入力、標準出力、標準エラー出力が<br />
多くの場合プロセスに与えられるが、<br />
このほかにも、open()で開いたファイルやソケットなどにも文字列を入出力できる。<br />
システムコールについては、open(), close(), write(), read()が、<br />
ファイルに対しての読み書きとして使える。<br />
ファイルディスクリプタと呼ばれる整数が、それぞれのストリームの識別に使われる。<br />
しかしながら、多くの場合、システムコールを使うよりも、<br />
C言語のstdioというライブラリを使った方が高速であり、また便利である。<br />
システムコールに比べて、stdioはバッファリングを行うため、<br />
何度も同じデータにアクセスする時の速度が高速になる。<br />
また、システムコールのread()やwrite()は固定長の読み書きを行うが、<br />
stdioは文字単位や行単位の読み書きが可能であり、<br />
printf()のようなフォーマット出力と呼ばれる便利な仕組みが存在する。<br />
stdioではファイルディスクリプタを生に触るのではなく、<br />
FILE型のポインタと呼ばれるラッパーを使う。</p>

</div>
<div class="section">
    <h3 id="シグナル">シグナル</h3>
    <p>プログラムを強制終了するためには、シグナルを使う。<br />
シグナルにはいくらかの種類があるが、<br />
カーネルがシグナルを処理する際のデフォルトの挙動は、<br />
「無視する」「強制終了」「強制終了してコアダンプを吐く」「一時停止する」「一時停止を再開する」の5種類。<br />
しかしながら、シグナルはプロセス側で処理を書き換えることができる。<br />
これを「シグナルを捕捉する」あるいは「トラップする」と言う。<br />
シグナルを上手くプロセス側で捕捉することで、<br />
標準で無視されるシグナルも活用できる。</p>

</div>
<div class="section">
    <h3 id="カーネルはシステムコールを待ち受けるだけ">カーネルはシステムコールを待ち受けるだけ</h3>
    <p>このようなカーネルをどのように開発するか、という問題だが、<br />
Linuxカーネルは、基本的にシステムコールを待ち受けるだけの<br />
イベント駆動なOSである。<br />
よって、Linuxカーネルは自分からは何もしない。<br />
何かの要求があった時にだけ、働くように作られている。</p>

</div>
<div class="section">
    <h3 id="開発には英語力が必要">開発には英語力が必要</h3>
    <p>Linuxカーネルの開発には英語力が必要である。<br />
カーネル内部のコメントも、<br />
メンテナンスされているドキュメントも、<br />
全て英語で書かれている。<br />
この英語が読めれば、きちんと開発できるようになる。</p>

</div>

<script type="text/javascript" src="script.js"></script>
</body>
</html>

