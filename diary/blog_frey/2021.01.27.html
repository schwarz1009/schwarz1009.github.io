<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet"  href="style.css">
<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">
<title>ネットワークの基本 - schwarz1009</title>

</head>
<body>
<p><a href="index.html">トップページに戻る</a></p>
<iframe src="menu3_menu.html" class="iframe_menu"></iframe>
<p>AUTHOR: schwarz1009<br>
TITLE: ネットワークの基本<br>
BASENAME: 2021/01/27/064537<br>
STATUS: Publish<br>
ALLOW COMMENTS: 1<br>
CONVERT BREAKS: 0<br>
DATE: 01/27/2021 06:45:37<br>
CATEGORY: ネットワーク<br>
CATEGORY: Linux<br>
CATEGORY: おすすめ


</p>
<ul class="table-of-contents">
    <li><a href="#ネットワークの基本">ネットワークの基本</a></li>
    <li><a href="#ソケット">ソケット</a></li>
    <li><a href="#ネットワークの基本コマンド">ネットワークの基本コマンド</a></li>
    <li><a href="#デーモン">デーモン</a></li>
    <li><a href="#ネットワーク系のプログラム">ネットワーク系のプログラム</a></li>
    <li><a href="#HTTPとWebプログラミング言語">HTTPとWebプログラミング言語</a></li>
    <li><a href="#データベース">データベース</a></li>
    <li><a href="#並列処理">並列処理</a></li>
    <li><a href="#パッケージ管理システム">パッケージ管理システム</a></li>
    <li><a href="#仮想化">仮想化</a></li>
    <li><a href="#暗号">暗号</a></li>
    <li><a href="#コンピュータの原理">コンピュータの原理</a></li>
    <li><a href="#ファイルシステム処理">ファイルシステム処理</a></li>
    <li><a href="#プロセスと入出力">プロセスと入出力</a></li>
    <li><a href="#コンパイラ">コンパイラ</a></li>
    <li><a href="#Xサーバー">Xサーバー</a></li>
    <li><a href="#フリーソフトウェアライセンス">フリーソフトウェアライセンス</a></li>
    <li><a href="#バザール開発とMozillaorg">バザール開発とMozilla.org</a></li>
    <li><a href="#MS-Officeとオープン文書形式">MS-Officeとオープン文書形式</a></li>
    <li><a href="#MSのオープン化とGAFA">MSのオープン化とGAFA</a></li>
    <li><a href="#軟骨がおかしい">軟骨がおかしい</a></li>
</ul>
<div class="section">
    <h3 id="ネットワークの基本">ネットワークの基本</h3>
    <p>ネットワークにおいては、パケットと呼ばれる単位でデータ通信を行う。<br />
パケットにはIPアドレスという宛て先が記述されており、<br />
ルータと呼ばれる「どの機器にパケットを送れば<br />
目的の機器に近づくことができるか（経路情報）を<br />
知っている機器」にパケットを送り、<br />
バケツリレー方式でパケットを送り続けることで、<br />
インターネットにおけるネットワーク通信は行われる。<br />
ルータは、周辺の経路情報を芋づる式にひとつの代表ルータに集め、<br />
すべてのルータとの間で経路情報を共有することで、<br />
どのルータに送れば目的の場所にたどり着けるかを知っている。<br />
LANは家庭内のネットワークであり、<br />
ネットワークとネットワークが家庭内のブロードバンドルータや<br />
ISPやインターネット上のルータによって繋がったものが、<br />
インターネットである。<br />
イーサネットは、もっとも普及しているLANの規格。<br />
イーサネットにおいては、MACアドレスとIPアドレスによって通信を行う。<br />
MACアドレスは、ネットワーク機器の識別番号であり、<br />
リンクバイリンクで、各機種の間で変わる。<br />
IPアドレスは、パケットの送受信の宛て先情報であり、<br />
エンドツーエンドで、最初から最後まで変わらない。<br />
MACアドレスとIPアドレスを変換するには、<br />
ARPというプロトコルを用いる。<br />
ARPにおいては、ブロードキャストパケットで全ての機器に、<br />
目的のIPアドレスを持っている機器（MACアドレス）を確認し、<br />
ユニキャストアドレスで応答する。<br />
ブロードキャストアドレスとは、1対多の通信で、<br />
ネットワーク上のすべてのホストに対する通信のこと。<br />
ユニキャストアドレスは、1対1の通信のこと。<br />
実際、IPアドレスは無限ではないため、<br />
ネットワーク部とホスト部に分かれており、<br />
ネットワーク部はインターネット上の一意のアドレスだが、<br />
ホスト部は家庭内で自由につけることができる。<br />
IPアドレスをビットにした時に、<br />
ネットワーク部を1とし、ホスト部を0としたものを<br />
サブネットマスクと言い、<br />
たとえば255.255.255.0となる。<br />
サブネットマスクにより、ネットワーク部とホスト部を識別できる。<br />
また、インターネットにおける一意のアドレスをグローバルアドレスと言い、<br />
家庭内で自由につけられるアドレスのことをプライベートアドレスと言う。<br />
この変換を行うシステムをNATと呼ぶ。<br />
また、IPアドレスと同時に使われるのがポート番号であり、<br />
どのアプリケーションに対して送受信を行うかを数値で指定し、<br />
たとえばHTTPであれば80番となる。<br />
ポートはファイアーウォールによって通常は閉じられており、<br />
不正な通信を遮断しているが、<br />
あえてポートを開けることによって、<br />
HTTPサーバーなどを外部に公開することができる。<br />
NATとファイアーウォールは、Linuxであればiptablesのようなシステムが行う。<br />
また、IPアドレスは機械にとっては識別しやすいが、<br />
人間にとっては理解し辛い。<br />
このため、人間のためにドメインとホスト名によって、<br />
名前付けを行う仕組みをDNSと呼ぶ。<br />
DNSで名前を解決することを「名前解決」と呼ぶ。<br />
実際はDNS以外にも、ネットワーク上の名前をホスト名の羅列によって解決したり、<br />
NISなどによって設定することもあり、<br />
これらすべての解決をするシステムのことを「リゾルバ」と呼ぶ。<br />
プロトコルとは、ネットワーク上のやり取りを行う上で、<br />
必要な「取り決め」のことであり、<br />
通常は「通信します、いいですか」<br />
「いいですよ」「ではデータを送ります」といったような<br />
3ウェイハンドシェイクといったような取り決めが決められている。<br />
プロトコルはOSI参照モデルという7階層のレイヤー分けがされており、<br />
上から下へ階層を下がる時にヘッダと呼ばれる通信や接続のための情報を付加し、<br />
通信を物理的に行った上で、ヘッダを除去して下から上へと上がる、<br />
リファレンスアーキテクチャを採用している。<br />
こうすることで、別の階層に影響を与えることなく、<br />
目的の階層だけに処理を分割できる。<br />
IPアドレスには経路情報をたどっていく機能があるが、<br />
これに信頼性とデータのセグメント分割を与えるのがTCPというプロトコル。<br />
TCPには、データの再送制御や、ふくそう制御など、<br />
信頼性を確保する多くの機能がある。<br />
これに対して、信頼性を犠牲にしても、効率やリアルタイム性を取るのがUDP。<br />
通常のネットワーク通信はTCP/IPによって行うが、<br />
動画や音声など、信頼性よりもリアルタイム性が必要な場合はUDPを使う。<br />
また、さらに上のプロトコルには、HTTP, FTP, SMTP, POP, IMAP, NTPなどがあり、<br />
それぞれよく知られたポート番号（ウェルノウンポート番号）を用いる。<br />
ネットワーク機器においては<br />
スイッチとルータがある。<br />
スイッチは、ネットワークの中で、各機器において通信を行う。<br />
ルータは、ネットワークとネットワークを繋げる。<br />
デフォルトゲートウェイは、ネットワークの外部からの案内役であり、<br />
デフォルトゲートウェイのアドレスを指定する時は、<br />
通常はルータのアドレスを指定する。<br />
（放送大学「情報学へのとびら ('16)」、<a href="https://www.amazon.co.jp/%E3%81%8A%E3%81%86%E3%81%A1%E3%81%A7%E5%AD%A6%E3%81%B9%E3%82%8B%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%81%AE%E3%81%8D%E3%81%BB%E3%82%93-Gene/dp/4798125261">おうちで学べるネットワークのきほん</a>、<a href="https://www.amazon.co.jp/dp/4295002666/">徹底攻略 応用情報技術者教科書 平成30年度</a>を参考に執筆しました。）</p>

</div>
<div class="section">
    <h3 id="ソケット">ソケット</h3>
    <p>また、このようなTCP/IPの仕組みは、<br />
便利だがソフトウェアの開発においては複雑である。<br />
よって、OSがソケットと呼ばれる仕組みで簡素化を行う。<br />
ソケットは、BSD UNIXで最初に採用されたTCP/IPスタックであり、<br />
二つのソケットが繋がると有効になり、<br />
繋がったソケット同士では、片方からwrite()すればもう片方からread()できる。<br />
BSDではソケットをファイルとして実現し、<br />
ファイルをシステムコールでやり取りする際の情報である、<br />
ファイルディスクリプタによって操作できるようにしたため、<br />
ファイルの読み書きと同様にソケットの読み書きができる。<br />
ソケットを使うことで、<br />
カーネルだけがネットワークの詳細と接続情報の管理を行えばよい。<br />
ソケットは通常サーバー・クライアントで接続を行い、<br />
ユーザーはソケットをサーバー側で待ち受け、<br />
クライアント側で接続を要求するだけでよい。<br />
UNIXでは、これは<br />
socket(), bind(), listen(), accept(), connect()の各APIで行われる。<br />
カーネルの内部では、<br />
たとえばLinuxではsk_buff型のポインタを使っており、<br />
sk_buff型のポインタを各階層に順々に渡していくことで処理が行われている。<br />
カーネルは、確実にパケットを目的の機器に送らなければならないが、<br />
このためにはルータのアドレスさえ知っておけばよい。<br />
LinuxにおいてはBSDソケット層とINETソケット層で、<br />
複雑な接続情報の管理を行っている。<br />
（<a href="https://www.amazon.co.jp/%E3%81%B5%E3%81%A4%E3%81%86%E3%81%AELinux%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-Linux%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B9%E3%82%8Bgcc%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E7%8E%8B%E9%81%93-%E9%9D%92%E6%9C%A8-%E5%B3%B0%E9%83%8E/dp/4797328355">ふつうのLinuxプログラミング Linuxの仕組みから学べるgccプログラミングの王道</a>と<a href="https://www.amazon.co.jp/%E8%A9%B3%E8%A7%A3-Linux%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB-%E7%AC%AC3%E7%89%88-Daniel-Bovet/dp/487311313X">詳解 Linuxカーネル 第3版</a>を参考にしました。）</p>

</div>
<div class="section">
    <h3 id="ネットワークの基本コマンド">ネットワークの基本コマンド</h3>
    <p>Linuxでは、traceroute, route, netstat, ifconfig, arp, nslookupなどのコマンドで、<br />
ネットワーク関連の操作を行うが、<br />
これらのコマンドの多くは型遅れとなっており、<br />
現在はiproute2パッケージを代わりに使う。<br />
また、ifconfigなどのコマンドは低レベルで強力だが使いづらいため、<br />
より上の高レベルな設定システム、<br />
たとえばDebianであればifupdownを用いて<br />
設定を行うことがデフォルトとなっている。</p>

</div>
<div class="section">
    <h3 id="デーモン">デーモン</h3>
    <p>また、サーバーはデーモンと呼ばれるシステムに常駐するプログラムによって<br />
一度に一回実行するコマンドではなく、<br />
システムで常にサービスを提供するが、<br />
これの管理にはsystemdと呼ばれる仕組みを用いる。<br />
以前はSysV initと呼ばれるプログラムとrcスクリプトによって設定を行っていたが、<br />
現在はinitに「デーモンの並列起動処理ができない」という問題があり、<br />
systemdが使われることが多い。<br />
FreeBSDなどの*BSD系UNIXでは、SysV initではなくrc.confと呼ばれる、<br />
ひとつの設定ファイルにおいてinit処理を行う。<br />
以前のrcスクリプトでは、デーモンごとに起動を行う起動スクリプトがあり、<br />
スクリプトへのシンボリックリンクに番号をつけることで順番を管理していたが、<br />
これでは並列で起動処理を行うことができず、<br />
現在のマルチコアプロセッサにおいては起動が遅くなる。<br />
そのため、systemdではUnitファイルを用いて、可能な限り並列で起動する。<br />
同時に、systemdはinitの代替以外にも多くの機能を提供し、<br />
たとえばコマンドを定期的に実行するcrondや、<br />
システムロガーなどの代わりにもなる。<br />
systemdは「新しいLinuxの管理の中心」ともいえるシステムであり、<br />
複雑であるため賛否の両論があるが、<br />
現在のLinuxの管理機構の中心となっている。</p>

</div>
<div class="section">
    <h3 id="ネットワーク系のプログラム">ネットワーク系のプログラム</h3>
    <p>Linux上におけるほかのネットワークプログラムとしては、<br />
リモートによる接続やリモートログインを行う、<br />
telnetやrlogin, sshのようなプログラムや、<br />
ネットワーク上でログイン情報を共通化するNIS/YP、<br />
ネットワーク上のファイルシステムをローカルにあるのと同じように<br />
マウントできるNFSなどがある。<br />
NFS以外のネットワークファイルシステムに準ずるシステムとしては、<br />
サーバとの間でファイル転送を行うFTPや、<br />
Windowsネットワークを実装したSambaなどがある。</p>

</div>
<div class="section">
    <h3 id="HTTPとWebプログラミング言語">HTTPとWebプログラミング言語</h3>
    <p>HTTPにおいては、サーバとクライアントの間でHTMLデータをやり取りする。<br />
この時、リクエストに対してサーバはレスポンスを返す。<br />
WebブラウザはWebサーバにリクエストを要求し、<br />
この時GETやPOSTなどのメソッドを要求する。<br />
これに対して、Webサーバは、<br />
「安全にデータを返します」「エラーが発生しました」といった<br />
番号（HTTPステータスコード）による応答と、<br />
具体的なデータ（エンティティボディ）を返す。<br />
ブラウザはHTMLをCSSなどと同時に解釈し、<br />
HTMLデータを内部的なツリー構造であるDOMツリーに変換する。<br />
DOMツリーはブラウザにおいては、<br />
JavaScriptと呼ばれる言語で操作することができる。<br />
JavaScriptによる操作は、クライアントのWebブラウザの内部で行われるため、<br />
クライアントサイドと呼ばれる。<br />
これに対し、そもそもサーバでHTMLデータを返す際に、<br />
動的にサーバ側で処理を行うことをサーバサイドと呼ぶ。<br />
クライアントサイドではJavaScriptを用いるが、<br />
サーバサイドではPHPやRubyといった言語を用いることが一般的。<br />
実際は単にPHPやRubyを直接書くこともできるが、<br />
よりWebサービスの開発のために便利な機能を詰め込んだ、<br />
フレームワークというものを用いてサーバサイドの処理を記述する。<br />
PHPではLaravel, RubyではRuby on Railsといったフレームワークが知られている。<br />
しかしながら、クライアントサイドでJavaScriptを使いながら、<br />
サーバサイドでRailsを使うのは、言語が二種類あって非効率である。<br />
このため、サーバサイドでもJavaScriptを使うNode.jsといった<br />
「サーバサイドJavaScript」と呼ばれる仕組みもある。<br />
RailsやLaravelでは、MVCフレームワークと呼ばれるモデルで開発を行う。<br />
MVCフレームワークでは、<br />
まず外部からのリクエストを処理するルーティングと呼ばれる処理があり、<br />
そのルーティングによって、<br />
MVCのCに相当するコントローラのアクションに処理が移る。<br />
アクションでは、Mに相当するモデルによって、<br />
データベースとのやり取りを行い、<br />
Vに相当するビューによって、<br />
HTMLを動的に作成してブラウザに返す。<br />
従来はこのMVCの処理を全てサーバ側で行っていたが、<br />
ビューの処理はクライアントサイドだけでも行えることが最近分かってきたため、<br />
Vue.jsやReactといったビューに特化したJavaScriptフレームワークで、<br />
クライアントでビューの処理を行うことも一般的になってきている。<br />
また、RubyやLaravelなどは、<br />
C++やJavaと同様のクラスベースのオブジェクト指向を行うが、<br />
JavaScriptでは、クラスベースではなくプロトタイプベースの<br />
オブジェクト指向を採用している。<br />
クラスのメンバ変数とメソッドを用いることなく、<br />
JavaScriptではプロトタイプを作成することでオブジェクト指向ができるが、<br />
従来のプログラミングとは異なるため、<br />
クラスベースのオブジェクト指向を行うためにTypeScriptと呼ばれる言語を用いる。<br />
また、C++やJavaには型がある（静的型付け）が、<br />
JavaScriptには型が無い（動的型付け）。<br />
動的型付けはプログラムの開発が簡単であるというメリットがあるが、<br />
多くの場合、静的型付けの方がプログラムの信頼性や保守性が向上し、<br />
たとえばプログラムとプログラムを結合した際にもバグがでることが少ない。<br />
このため、TypeScriptではJavaScriptにおいても静的型付けを実現できる。<br />
TypeScriptでは、TypeScript独自の型のチェックをした後で、<br />
TypeScriptコードがJavaScriptコードに変換される。<br />
以前のトレンドでは、RubyやPythonといった動的型付け言語が、<br />
プログラムの書きやすさといった点から流行していたが、<br />
最近は大規模なプログラム開発において静的型付けが再流行しており、<br />
RubyやPythonといった動的型付け言語でも、<br />
型アノテーションや型宣言ファイルを用いて、<br />
静的型解析を行うことが一般的になりつつある。</p>

</div>
<div class="section">
    <h3 id="データベース">データベース</h3>
    <p>また、Webにおいては、<br />
「データベース管理システム」を用いてデータの管理を行う。<br />
たとえば、掲示板を作るのであれば、<br />
投稿された投稿内容をデータベースサーバに登録し、<br />
表示する際にはそれを参照する。<br />
リレーショナルデータベース管理システム（RDBMS）では、<br />
二次元の表によってデータを管理する。<br />
PythonやR言語でいうデータフレームも、これに準ずるものである。<br />
（Pandasなどでは、<br />
二次元のラベル付きデータ構造であるデータフレームを用いる）。<br />
RDBMSでは、「リレーション」と呼ばれる仕組みを用いて、<br />
小さく細分化（正規化）されたデータを、<br />
結合したり、選択したり、射影したりして、<br />
さまざまなデータテーブルを自動的に作成して処理を行う。<br />
データベース管理システムでは、<br />
まず、巨大なデータを検索する時に高速で、<br />
同時にSQLクエリを用いて処理を行うという、<br />
パフォーマンスと柔軟性のメリットがあり、<br />
同時に、複数のプログラムから操作しても、<br />
排他制御などにより矛盾が発生しないという、<br />
矛盾のないデータの整合性を保つといったメリットもある。<br />
また、データが破壊されることをできるだけ防ぎ、<br />
破壊されることがないように復旧したり、<br />
データを複製する冗長化や、<br />
ひとつのサーバが落ちても別のサーバが代わりを務めるという、<br />
フェイルオーバと呼ばれる仕組みもある。<br />
このような信頼性を「可用性」と呼び、<br />
信頼性ではなく効率を重視したクラスタのことを「HPC」と呼ぶ。<br />
HPCにおいては、どれだけのマシンで並列処理ができるかが重要になる。</p>

</div>
<div class="section">
    <h3 id="並列処理">並列処理</h3>
    <p>ネットワーク以外にも、一般的に並列処理を行うには、<br />
スレッドセーフを考えた設計が重要になる。<br />
スレッドセーフでは、データの競り合い状況が発生しないように、<br />
共有データを処理する間ロックして、処理した後でロックを解除する。<br />
この仕組みのことをmutexと呼ぶ。<br />
C++には長らくスレッドの概念がなかったため、<br />
マルチスレッドコードはプラットフォーム依存のコードを書く必要があったが、<br />
Javaでは標準でスレッドの概念があり、<br />
ロックはsynchronizedメソッド・ブロックで可能となっており、<br />
スレッドの待機や割り込み（中断）もできるようになっている。<br />
また、制御モデルにおいて、並列処理には3つのモデルがある。<br />
まず、同じ処理を全てのスレッドで行う単純な並列処理モデル。<br />
次に、マスター（主人）がスレーブ（奴隷）を従えるマスター・スレーブモデル。<br />
最後に、プログラムの出力を次のプログラムの入力として次々に渡していく、<br />
パイプラインモデルである。<br />
並列処理以外の制御モデルとしては、<br />
これ以外にも、コールバック関数をイベントループのリスナとして設定する、<br />
イベントドリブン（イベント駆動）モデルなどがある。<br />
イベントドリブンは、Windowsのウィンドウプログラムのほか、<br />
Linuxカーネルのシステムコールなどにもみられる考え方である。<br />
（一部の内容で<a href="https://www.amazon.co.jp/Reading-%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B6%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%E6%8A%80%E6%B3%95-%E3%83%97%E3%83%AC%E3%83%9F%E3%82%A2%E3%83%A0%E3%83%96%E3%83%83%E3%82%AF%E3%82%B9%E7%89%88-Diomidis-Spinellis/dp/4839956693">Code Reading ~オープンソースから学ぶソフトウェア開発技法~ (プレミアムブックス版)</a>を参考にしました。）</p>

</div>
<div class="section">
    <h3 id="パッケージ管理システム">パッケージ管理システム</h3>
    <p>また、Linuxなどではパッケージ管理システムと呼ばれる管理機構によって、<br />
システムの全ソフトウェアを管理する。<br />
このメリットは、依存性の解決であり、<br />
プログラムが導入されていても、<br />
それに依存するプログラムが導入されていないから、<br />
といった理由でシステムが動かず破損することを防げる。<br />
通常は、RPMやDpkg/Debなどといった低レベルなシステムの上に、<br />
DNFやAptといった使いやすい管理ツールを用いる。<br />
このDNFやAptを用いると、ネットワーク上のリポジトリから、<br />
パッケージをコマンドひとつでインストールし、<br />
更新や依存するパッケージの導入なども全て自動で実行できる。<br />
パッケージ管理システムを用いると、<br />
システムを常に安全かつ最新に保つことができるが、<br />
実際は全てのパッケージがリポジトリに用意されているわけではなく、<br />
自分の使いたいバージョンが導入できるとも限らないため、<br />
ソースtarball（tar.gzファイルのこと）から<br />
configureやmakeでビルドすることも時には必要である。<br />
最近ではシステムとアプリケーションをサンドボックス環境で分離する、<br />
Flatpakなどのパッケージ管理システムもある。<br />
このメリットは、クロスディストリビューションであること。<br />
従来のパッケージ管理システムにおいては、<br />
ひとつひとつのディストリビューションに<br />
対応するパッケージを用意する必要があった。<br />
Flatpakを用いることで、全てのバージョンのパッケージを、<br />
全てのディストリビューションに配布することができる。</p>

</div>
<div class="section">
    <h3 id="仮想化">仮想化</h3>
    <p>また、ネットワークにおいては、仮想化と呼ばれる仕組みを使うこともある。<br />
これは、OSの上で仮想マシンや仮想CPUをエミュレートし、<br />
OSの上で別のOSを実行できる機能。<br />
VM型の仮想化では、OSそのものを仮想化するため、<br />
たとえばWindows上でLinuxを実行できる。<br />
VM型仮想化としては、Virtualboxなどが有名。<br />
これに対して、Linux上でLinuxの仮想化を行うDockerなどでは、<br />
カーネルを共有するコンテナ型の仮想化を行うため、<br />
軽量でパフォーマンスがいい。<br />
コンテナ型の仮想化では、<br />
プロセスを専用のコンテナプロセスとして「隔離」することができ、<br />
それを「コンテナイメージ」とすることができる。<br />
Docker Hubなどのホスティングサイトでは、<br />
このコンテナイメージをインターネットからダウンロードでき、<br />
たとえば何の設定や導入もしなくても、<br />
簡単にRuby on Railsの環境をDockerだけで実現することができる。<br />
また、必要がなくなったら、簡単に仮想サーバごと削除できる。<br />
こうしたコンテナ型の仮想化は、<br />
システムの開発（DevOps）においてはとても便利で、<br />
本番環境を開発環境で再現するために使えるほか、<br />
レンタルサーバなどでは、<br />
簡単にroot権限のある仮想サーバを利用者に与えることができる（VPS）。</p>

</div>
<div class="section">
    <h3 id="暗号">暗号</h3>
    <p>ネットワーク上でセキュリティを確保するためには、<br />
暗号化という仕組みを用いる。<br />
共通鍵暗号方式では、<br />
暗号化と復号化に用いる鍵が同じだが、<br />
公開鍵暗号方式では、<br />
公開鍵と秘密鍵を使う。<br />
秘密鍵は知られてはならないが、公開鍵は誰に知られても構わない。<br />
暗号化通信においては、公開鍵暗号方式を使うことが多い。<br />
まず、受信者が公開鍵と秘密鍵のペアを作り、<br />
自分の公開鍵を相手に送る。<br />
送信者は、その公開鍵を使ってデータを暗号化する。<br />
そしてデータを受信した受信者は、秘密鍵を用いてデータを復号化する。<br />
（<a href="https://www.amazon.co.jp/%E6%9A%97%E5%8F%B7%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80-%E7%AC%AC3%E7%89%88-%E7%A7%98%E5%AF%86%E3%81%AE%E5%9B%BD%E3%81%AE%E3%82%A2%E3%83%AA%E3%82%B9-%E7%B5%90%E5%9F%8E-%E6%B5%A9/dp/4797382228">暗号技術入門 第3版 秘密の国のアリス</a>を参考にして執筆しました。）</p>

</div>
<div class="section">
    <h3 id="コンピュータの原理">コンピュータの原理</h3>
    <p>また、コンピュータの原理においては、<br />
二進数の計算は、00+00=00, 01+00=01, 00+01=01, 01+01=10の4通りしかない。<br />
これは、論理回路におけるANDとEXORで機械的に計算できる。<br />
実際は、これは下桁からの繰上りを考慮していないため、半加算器と呼ばれる。<br />
下桁からの繰上りを考慮した全加算器は、<br />
二つの半加算器とOR回路によって実現できる。<br />
また、減算については2の補数を加算することで実現できる。<br />
2の補数とは、ビットの0と1を反転させて1を加算した表現のことで、<br />
正の数に負の数を加算すれば必ず桁あふれが起きて結果が0になる。<br />
乗算と除算については、小学校で習う筆算と同様に、<br />
桁ごとに演算を行えば実現できる。<br />
（放送大学「情報学へのとびら ('16)」を参考にして執筆しました。）</p>

</div>
<div class="section">
    <h3 id="ファイルシステム処理">ファイルシステム処理</h3>
    <p>Linuxでは、ファイルシステムはまずパーティションを作成し、<br />
その中にファイルシステムを作成し、<br />
それをマウントすることでディレクトリツリーとファイルを操作できる。<br />
/etc/fstabには、<br />
起動時にマウントされるファイルシステムボリュームの設定をする。<br />
Linuxのファイルシステムでは、<br />
VFSと呼ばれる仕組みによって、<br />
さまざまな別のファイルシステムを使うことができる。<br />
ブロック型のext2や<br />
ジャーナリング（途中で強制終了しても壊れない）に対応した<br />
ext3/ext4などがある。<br />
また、ReiserFSやXFSはB-Treeファイルシステムと知られる。<br />
ブロック型のext4ではなく<br />
データベースと同様のインデックス技術を用いた高速な検索が可能。<br />
また、ZFSやBtrFSのようなコピーオンライトのファイルシステムでは、<br />
ファイルをコピーしてもほとんどのデータを共有データとし、<br />
書き換えられた時点で複製を作る（コピーオンライト）仕組みを採用している。<br />
これにより、データリソースを大幅な削減ができるほか、<br />
毎日スナップショットをとってもデータの大幅な利用に繋がらないため、<br />
いつでも好きな地点にスナップショットからデータを復旧させることができ、<br />
信頼性の確保に繋がる。<br />
ファイルシステム階層としては、<br />
基本的に/usrにはシステム全体で共有される、<br />
あまり頻繁に変更されないファイルを置く。<br />
/varには、頻繁に変更されるファイル、<br />
たとえばログやスプールファイルを置く、<br />
そして、/etcにはシステム管理者が設定する設定ファイルなどを置く。<br />
/usr/localは、/usrと同様だが、パッケージ管理システムではなく、<br />
システム管理者が手動で管理するmakeビルドのプログラムを置く。<br />
そして、/home/usernameにはユーザー個別のホームディレクトリが置かれる。<br />
これらは、所有者、所有グループ、その他のユーザーに対する、<br />
実行、読み込み、書き込みの許可権限であるパーミッションで守られる。<br />
しかしながら、<br />
特権ユーザーであるrootに莫大な権限があることが問題だったり、<br />
Webサーバなどのプロセスに権限を付加させたい場合などは、<br />
SELinuxなどのより強固なセキュアOSモジュールを使うこともできる。</p>

</div>
<div class="section">
    <h3 id="プロセスと入出力">プロセスと入出力</h3>
    <p>プロセスは、シェルと呼ばれるプロンプトからコマンドで実行することが多いが、<br />
この時&をつけることで、バックグラウンドで実行できる。<br />
また、パイプとリダイレクトを用いることで、<br />
あるコマンドの出力を別のコマンドに渡したり、<br />
標準入出力をファイルと変換することができ、<br />
特にgrep, find, xargs, sed, awkあるいはUNIXのさまざまなフィルターコマンドは、<br />
このパイプとリダイレクトを用いて、<br />
「複数のコマンドを組み合わせてひとつの作業をする」ことが一般的である。<br />
UNIXではプロセスは、fork()とそれに準ずるシステムコールによって作成する。<br />
また、デーモンを作る時は、fork()した後でsetsid()で端末を切り離す。<br />
マルチタスクにはプロセスとスレッドがあり、<br />
プロセスはそれぞれ個別にメモリ領域が与えられるが、<br />
スレッドでは共有データとなる。<br />
一応、プロセス間通信などの例外もある。<br />
プロセスには、付属するメモリ領域として、<br />
テキスト領域（プログラムそのもの）、<br />
スタック領域、ヒープ領域などが与えられる。<br />
入出力処理は、ストリームを通じて行われる。<br />
ストリームはバイト列のことで、<br />
バイト列としてあらわされるものは何でもストリーム。<br />
ストリームを使うためには、<br />
デバイスファイルを媒介に使う。<br />
キャラクタ型デバイスかブロック型デバイスかによって使い方は異なるが、<br />
キャラクタ型デバイスはバイト列の処理としてあらわされ、<br />
ランダムアクセスができない。<br />
ブロック型デバイスは、ファイルシステムにマウントして用い、<br />
ランダムアクセスができる。<br />
標準で標準入力、標準出力、標準エラー出力が、<br />
ストリームを識別するファイルディスクリプタとして、<br />
プロセスに与えられるが、<br />
open()/close()したファイルについては<br />
それぞれのストリームがファイルディスクリプタとして対応し、<br />
read()やwrite()から読み書きできる。<br />
しかしながら、システムコールはバイト固定長の入出力しかできず、<br />
バッファ管理を行わないため速度も遅い。<br />
これに対して、C言語のstdioライブラリでは、<br />
バッファ管理ができて高速であるほか、<br />
1文字単位や1行単位の入出力、フォーマット入出力もサポートしている。<br />
stdioを使う時は、<br />
fopen()とfclose()を使ってファイルをオープンし、<br />
fread()やfwrite()で固定長の操作ができる。<br />
注意点として、gets()は使ってはならない。<br />
バッファオーバーランの脆弱性を回避できないためである。<br />
通常、入力にはfgets()を使い、<br />
一文字単位の入出力にはgetchar()とputchar()、<br />
コンソールへの出力はputs()やprintf()、ファイルへの出力はfprintf()を使う。<br />
また、文字列をフォーマット変換のみしたい場合は、sprintf()を使えばよい。<br />
また、プログラミングの特性上、<br />
「一文字余計に読み込まなければトークンの終端か分からない」ということがある。<br />
この時、一文字元に戻すAPIとしてungetc()がある。<br />
（<a href="https://www.amazon.co.jp/%E3%81%B5%E3%81%A4%E3%81%86%E3%81%AELinux%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-Linux%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B9%E3%82%8Bgcc%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E7%8E%8B%E9%81%93-%E9%9D%92%E6%9C%A8-%E5%B3%B0%E9%83%8E/dp/4797328355">ふつうのLinuxプログラミング Linuxの仕組みから学べるgccプログラミングの王道</a>を参考に執筆しました。）</p>

</div>
<div class="section">
    <h3 id="コンパイラ">コンパイラ</h3>
    <p>Linuxでは、主にC言語を用いてプログラムを記述し、<br />
それをGCCなどのコンパイラを用いてコンパイルする。<br />
GCCでは、コンパイラの前段階として<br />
プリプロセス（#defineや#includeなどの処理）を行い、<br />
コンパイル可能なC言語の完全なソースコードを生成したら、<br />
それをアセンブリ言語にコンパイルする。<br />
コンパイラの手順としては、<br />
字句解析でトークンを解析し、<br />
構文解析で構文ルールからパースツリーを作成し、<br />
三番地コードなどの中間言語を作成し、<br />
最適化を行ってアセンブリ言語を出力する。<br />
GCCでは、フロントエンドとバックエンドに構造が分かれており、<br />
フロントエンドではFORTRANなどのC/C++以外の言語にも対応して解析でき、<br />
バックエンドではさまざまなCPUアーキテクチャのアセンブリ言語を吐き出せる。<br />
コンパイルが終わったら、<br />
アセンブルして機械語のオブジェクトファイルを生成し、<br />
リンクを行う。<br />
機械語のオブジェクトファイルになった段階で、<br />
プログラムは実行可能なプログラムとライブラリに分かれている。<br />
ライブラリには二つの種類があり、<br />
スタティックリンク（*.a）では、<br />
リンクの時点で完全に実行プログラムと結合される。<br />
一方、ダイナミックリンク（*.so）では、リンクの時点では結合を行わず、<br />
実行時にリンクローダ（/lib/ld-linux.so.2）が動的にリンクを行う。<br />
最近のUNIXでは、ダイナミックリンクを使うのが一般的だが、<br />
一部の軽量libc（Muslなど）ではスタティックリンクに最適化されたものもある。<br />
また、全てのプログラムは暗黙のうちに、<br />
libc.so.6にダイナミックリンクされている。<br />
バイナリがどの共有ライブラリに依存しているかはlddコマンドで確認できる。<br />
参考文献：</p>
    <ul class="some_lists">
        <li><a href="https://www.amazon.co.jp/%E3%81%B5%E3%81%A4%E3%81%86%E3%81%AELinux%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-Linux%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B9%E3%82%8Bgcc%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E7%8E%8B%E9%81%93-%E9%9D%92%E6%9C%A8-%E5%B3%B0%E9%83%8E/dp/4797328355">ふつうのLinuxプログラミング Linuxの仕組みから学べるgccプログラミングの王道</a></li>
        <li><a href="https://www.amazon.co.jp/%E3%82%A8%E3%82%AD%E3%82%B9%E3%83%91%E3%83%BC%E3%83%88C%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E2%80%95%E7%9F%A5%E3%82%89%E3%82%8C%E3%81%96%E3%82%8BC%E3%81%AE%E6%B7%B1%E5%B1%A4-Ascii-books-%E3%83%94%E3%83%BC%E3%82%BF%E3%83%BC-%E3%83%B4%E3%82%A1%E3%83%B3%E3%83%BB%E3%83%87%E3%83%BB%E3%83%AA%E3%83%B3%E3%83%87%E3%83%B3/dp/4756116396">エキスパートCプログラミング―知られざるCの深層 (Ascii books)</a></li>
    </ul>

</div>
<div class="section">
    <h3 id="Xサーバー">Xサーバー</h3>
    <p>Linuxでは、GUI環境をWindowsと同様に利用することができる。<br />
このために、Xサーバーを使う。<br />
X Window System（X11）は、クライアント・サーバー方式で、<br />
ネットワーク透過と呼ばれるネットワーク通信をサポートしており、<br />
その中核のプトロコルをXプロトコルと呼ぶ。<br />
Xプロトコルは、ディスプレイを表示するXサーバーと、<br />
アプリケーションウィンドウを担当するXクライアントの間で、<br />
ネットワークで通信しながら、<br />
マウスボタンクリックなどのイベントメッセージをやり取りする。<br />
Xプロトコルの詳細を知らなくてもいいように、<br />
Xlibと呼ばれるライブラリが用意されており、<br />
プログラマはXlibを使ってXクライアントを書くことができる。<br />
また、X11においては、ウィンドウを表示するプロトコルとAPIは決まっていても、<br />
ボタンやメニューなどのウィジェットツールキットまでは用意されていない。<br />
そのため、Motif, Qt, GTKなどのウィジェットツールキットを用いて<br />
アプリケーションを書くことが一般的である。<br />
また、X11はウィンドウマネージャと呼ばれるGUI環境を用いて、<br />
ユーザーは操作するが（これがWindowsやMacの環境に相当する）、<br />
標準ではとても簡素なウィンドウマネージャしか提供されておらず、<br />
これを使ってデスクトップ環境を操作することは一般的ではない。<br />
ウィンドウマネージャにはたくさんの種類があるが、<br />
ウィンドウマネージャだけではなく、<br />
統合的なデスクトップ環境を与えるものとして、<br />
GNOME, KDE, Xfce, MATE, Cinnamonなどがある。<br />
GNOMEではツールキットにGTKが、KDEではツールキットにQtが採用されている。<br />
GNOMEなどでは、CORBAと呼ばれる分散システムを設計の基本にすることで、<br />
プラットフォームと言語とネットワークの垣根を超えた<br />
モジュールのリンクが可能であり、<br />
これを長らくKDEに比べた優位性としてきた。<br />
しかしながら、GNOME 3では<br />
CORBAはD-Busによってリプレースされている。<br />
また、GNOMEのGTKはGLib/GObjectと呼ばれる<br />
オブジェクト指向の仕組みを提供しており、<br />
GLibにのっとってC言語でオブジェクト指向の環境でプログラムを開発できる。<br />
また、C言語は比較的各種言語のバインディングが作りやすく、<br />
C++/Python/JavaScript/Vala/Rustなどにも対応している。<br />
これに対して、QtはC++の仕組みを採用しているが、<br />
比較的、美しくて機能的なのはKDE/Qtの方である。<br />
しかしながら、Qtはそもそも昔はフリーソフトウェアではないツールキットであり、<br />
GNUなどではこれに対してGNOMEプロジェクトを開始するに至った。<br />
今ではQtはフリーソフトウェアライセンスで提供されている。<br />
また、GNOMEは比較的独立性が高く、<br />
また初心者向けで、最初のログイン時に動画で使い方を教えるなど、<br />
Windowsも使えない初心者ユーザーのためによく考えられている。<br />
しかしながら、Linux開発者のリーナス・トーバルズなどは、<br />
「ユーザーを馬鹿だとみなすGNOMEの姿勢は根本的に誤りである」としている。<br />
標準となっているのはGNOMEだが、<br />
デスクトップのデザインが美しく、<br />
また、搭載アプリケーションの高機能性が光るのはKDEである。<br />
特に、KDEアプリケーションには、<br />
Windowsに遜色のない機能的GUIアプリが多く備わっている。</p>

</div>
<div class="section">
    <h3 id="フリーソフトウェアライセンス">フリーソフトウェアライセンス</h3>
    <p>フリーソフトウェアライセンスには、大きく二種類がある。<br />
それは、GPLなどのコピーレフトのライセンスと、<br />
BSDライセンスやMITライセンスなどの緩いパーミッシブライセンスである。<br />
コピーレフトのライセンスでは、<br />
コピーレフトなコードを含まれたコードは、<br />
必ずコピーレフトなライセンスで再配布しなければならない。<br />
つまり、GPLで書かれたソフトウェアは、<br />
含まれているコードがどれだけ一部分であったとしても、<br />
必ずどんな場合でもGPLで再配布される。<br />
そのため、永久にGPLが保たれる。<br />
逆に、ソフトウェア開発者は、<br />
GPLのコードが含まれていないかどうかを確認し、<br />
含まれている場合はGPLで配布しなければならない。<br />
GPLでは、ソフトウェアの実行、コピー、再配布、改造を認めており、<br />
この前提としてソースコードを配布しなければならない。<br />
つまり、GPLコードは必ずオープンソースで配布しなければならないため、<br />
商用的なソフトウェアのソースコードとして、<br />
GPLのものを含めることは適切ではない。<br />
なぜなら、含めた時点でソースコードを公開しなければならず、<br />
それは自由に再配布や改造を認めなければならないため、<br />
はっきり言って「商売にはならない」。<br />
しかしながら、パブリックドメインのUNIXが後にクローズドになった経験や、<br />
多くの商用UNIXでフリーソフトウェアが<br />
非フリーの状態で提供されていたことを受け、<br />
「フリーなUNIXのクローンを作ろう」と<br />
GNU創始者のリチャード・M・ストールマンが考えた結果、<br />
GPLはGNUによるソフトウェアの多くに採用されており、<br />
初期のMINIXのコンポーネントを<br />
GNUのコンポーネントに置き換えたLinuxカーネルにおいても、<br />
商用利用を禁じる初期のライセンスを撤廃して、GPLが採用されている。<br />
GPLに対して、GNU以外のフリーソフトウェアプロジェクトは、<br />
パーミッシブライセンスと呼ばれる<br />
BSDライセンスやMITライセンスを採用したものもある。<br />
FreeBSD/NetBSD/OpenBSDのソフトウェアや、<br />
X.org Serverなどでは、パーミッシブライセンスが採用されている。<br />
パーミッシブライセンスでは、<br />
「コードが含めれていてもフリーなライセンスで配布しなくてよい」。<br />
プロジェクトがフリーソフトウェアのままで存続するためには、<br />
オリジナルのプロジェクトがきちんと組織管理すればよいと考え、<br />
たとえフリーでないライセンスで配布されてもそれを許している。<br />
このような姿勢は「緩い」ライセンスと知られている。<br />
しかしながら、パーミッシブライセンスにおいても、<br />
著作者の表示とライセンスの表示は行わなければならない。<br />
こうしたフリーソフトウェアのライセンスを、<br />
ソフトウェアだけではなく文書やコンテンツに適用したものとして、<br />
クリエイティブ・コモンズなどが知られている。<br />
クリエイティブ・コモンズは、<br />
たとえば日本の同人誌や同人作家のように、<br />
「二次創作における自由なライセンスを確保するため」に<br />
フリーソフトウェアを参考にして法律化されたもので、<br />
さまざまなライセンス形態が選べる。<br />
クリエイティブ・コモンズは、<br />
Wikipediaの共同文書のライセンスなどに採用されている。<br />
また、インターネット上には多くのクリエイティブ・コモンズで<br />
ライセンスされた画像ファイルや文書ファイルがある。<br />
しかしながら、GPLと同様に、<br />
継承条項を付けたSAライセンスを選ぶことができるため、<br />
商用利用を行う際には、<br />
継承条項がついているかどうかに注意する必要がある。<br />
もしついていたとしたら、<br />
そのコンテンツを自分たちもSAで公開する必要がある。</p>

</div>
<div class="section">
    <h3 id="バザール開発とMozillaorg">バザール開発とMozilla.org</h3>
    <p>また、フリーソフトウェアという言葉とよく似た言葉として、<br />
オープンソースという言葉がある。<br />
これは、開発をオープンにし、みんなのパッチをどんどん取り込むことで、<br />
片手間のボランティアによって一流のカーネルが開発された、<br />
Linuxカーネルの開発手法から生まれた言葉で、<br />
「伽藍とバザール」というエリック・レイモンドの文書を代表として、<br />
作られた造語である。<br />
伽藍とバザールでは、GNUのように、<br />
一部のきちんと分かっているエンジニアが慎重に作り上げる開発手法のことを、<br />
「伽藍」すなわち教会のカテドラルになぞらえ、<br />
これに対して「乱交まがいにオープンにする」Linuxカーネルの開発手法を、<br />
「バザール」と呼んだ。<br />
この伽藍とバザールは、インターネットの多くの人々に衝撃と称賛を与え、<br />
これにならってオープンソース開発をしようとする企業が現れた。<br />
それが、マイクロソフトのIEとのブラウザ戦争に負けたNetscapeである。<br />
Netscapeはインターネットの黎明期にWebブラウザの覇者として君臨したが、<br />
Windowsの成功と、バンドルされたIEとのブラウザ戦争に負け、<br />
その時「伽藍とバザール」の影響を受けて、<br />
ブラウザの存続をかけて、Netscapeブラウザのオープンソース化を決める。<br />
新しいブラウザの名前は「Mozilla」となり<br />
（「Mozilla」は昔からのNetscapeの愛称だった）、<br />
そのプロジェクトはオープンなMozilla.orgによって行われる。<br />
しかしながら、Mozillaはなかなか安定したバージョンをリリースできず、<br />
開発は遅れ、<br />
開発の中心メンバーもコミュニティのボランティアではなく、<br />
Netscape社員であるままが続いた。<br />
Netscapeの業績不振もあり、Netscape社はAOLに買収される。<br />
しかしながら、その後もMozillaの開発は続く。<br />
MozillaはXULと呼ばれるXMLとJavaScriptを用いた抽象的なUI言語を持っており、<br />
ブラウザだけではなくメールクライアントやHTML編集エディタもあったが、<br />
このせいでIEに比べてとても巨大で重かった。<br />
しかしながら、XULの機構を用いることで、<br />
拡張機能をEmacsのLispのように分離することができる。<br />
いつまでもMozillaは日進月歩で開発されたが、<br />
こうした機能を上手く使って、<br />
メールクライアントやHTML編集エディタを削除し、<br />
最低限の機能を持った軽量なWebブラウザである、<br />
Mozilla Firefox（以前の名はPhoenixあるいはFirebird）を新たにリリースし、<br />
使いたい機能を拡張機能としてユーザーが自由に拡張できるようにした。<br />
Firefoxと同様、メールクライアントもThunderbirdとして分離。<br />
一時期はIEに次ぐ第二のブラウザとして、<br />
NewYork Timesに広告を掲載するなどの流行を見せていたが、<br />
GoogleによるWebKit系のブラウザであるGoogle Chromeなどに<br />
第二位の座を奪われ、<br />
今ではFirefoxは「商用企業ではなくユーザーのためのブラウザ」として<br />
なんとかインターネット上で続いている。<br />
Linuxにおいては、<br />
GNOMEではFirefoxがデフォルトのブラウザになっていることが多いが、<br />
KDEではKonqueror（WebKitの元になったKHTMLをベース）が標準であり、<br />
XfceではMidoriなどが軽量ブラウザとして提供されており、<br />
またGNOMEにおいてもGNOME Webなどが開発されており、<br />
サーバーサイドJavaScriptのNode.jsはChromeのV8エンジンの上で動くなど、<br />
しだいにFirefoxも草葉の陰に隠れつつある。<br />
WindowsやMacでも、決してFirefoxはマイナーなブラウザではないが、<br />
メインのブラウザとしてはChromeを使う人が増えてきている。</p>

</div>
<div class="section">
    <h3 id="MS-Officeとオープン文書形式">MS-Officeとオープン文書形式</h3>
    <p>また、「なぜこのようなWindowsが勝利するのか」と言えば、<br />
まず、WindowsはIBM PC/AT互換機で標準だったMS-DOSから始まる、<br />
「バンドルの歴史」がある。<br />
IBM PC/AT互換機を買うと、必ずWindowsがついてくる。<br />
IEやMS-Officeなども、標準でWindowsにくっついてくる。<br />
そのため、初期ユーザーを簡単に得ることができた。<br />
もうひとつの要因は、「MS-Officeの文書形式」である。<br />
MS-Officeは独自の文書形式を採用しており、<br />
これは長い間Microsoftの独自形式であったため、<br />
MS-Officeで作った文書は、MS-Officeでしか編集できない。<br />
そのため、簡単にMS-Officeから別のOfficeソフトウェアに変えられない。<br />
しかしながら、オープンソースの世界では、<br />
これに対して「オープン標準の文書形式を採用しよう」という声があり、<br />
それが、Sunが買収してオープンにした、<br />
OpenOffice.orgのOpenDocument Formatである。<br />
OpenOffice.orgは、オープンソースのOfficeソフトウェアであり、<br />
Office形式にOpenDocumentを採用し、<br />
ほかのOfficeソフトウェアと相互運用ができるようにした。<br />
今では、さまざまな経緯からOpenOffice.orgはApacheの所管に移り、<br />
メインの開発はLibreOfficeという後継ソフトウェアに移行している。<br />
しかしながら、LibreOfficeの問題は、「使いづらい」こと。<br />
MS-Officeでは、ユーザーが間違った操作をしたり、<br />
ユーザーがあまりOfficeに詳しくなくても、<br />
適当になんとなく操作できるようになっていることが多いが、<br />
これがLibreOfficeだと「まったくどの機能を使っていいか分からない」。<br />
ユーザーは、MS-Officeとの操作性の違いなどから、<br />
まともにLibreOfficeを使うことができない。<br />
もうひとつは、果たして<br />
「MS-Officeを捨ててまでLibreOfficeを使う理由がない」ということ。<br />
WindowsからLinuxに移行すると、<br />
普通にLibreOfficeを使おうとすれば使えるのだが、<br />
逆にMS-Officeを使える環境がなくなってしまう。<br />
これは、「無料のOfficeを使えるといっておいて、<br />
有料の標準のMS-Officeを奪っていく行為に等しい」。<br />
このことから、いくらLinuxがオープンソースかつ無料で利用できるといっても、<br />
なかなかMS-OfficeからLibreOfficeへの移行は起きていない。<br />
同様のことが、Adobe PhotoshopとGIMPなど、オープンソース全般に言える。<br />
GIMPは確かに無料だが、<br />
Adobe Photoshopに慣れているデザイナーは、<br />
誰もがAdobe Photoshopを使うことを楽しみとしており、<br />
無料のGIMPを与えたところで、簡単には移行しようとしないのである。</p>

</div>
<div class="section">
    <h3 id="MSのオープン化とGAFA">MSのオープン化とGAFA</h3>
    <p>しかしながら、Microsoftの栄華も安泰ではない。<br />
なぜなら、今の世界は完全にWebサービスの時代であり、<br />
特にGAFAと呼ばれるインターネット企業の時代だからである。<br />
WindowsはあくまでローカルのコンピュータOSであり、<br />
いくらクライアントを中心に普及しているからといって、<br />
Webサーバーの世界ではLinuxなども普及しているし、<br />
何より、モバイルOSやモバイルアプリの存在がある。<br />
モバイルではGoogleのAndroidとAppleのiOSが覇権を握っており、<br />
Windowsは完全に野外に追いやられてしまっている。<br />
また、商業的なシステムにおいても、<br />
Windowsをエンタープライズで作る事例は多くない。<br />
エンタープライズでは、メインフレームやUNIXが今でも多く、<br />
このような現場ではJavaが使われており、<br />
ある程度の規模のシステムではLinuxをOSによく使う。<br />
何より、最近はクラウドと呼ばれるネットワークサービスとしての、<br />
コンピュータの利用が増えている。<br />
このクラウドで強いのはLinuxであり、<br />
Microsoftもこうした現状を受けて、<br />
オープンソースへの取り組みを多く行っている。<br />
たとえば、MicrosoftはVS-Codeと呼ばれる<br />
オープンソースのテキストエディタを作っており、<br />
ほとんどエンジニアの間で標準である。<br />
また、MicrosoftはJavaScriptの拡張言語であるTypeScriptを<br />
オープンソースで開発している。<br />
PHPのWebフレームワークのLaravelも、MSの社員によるものである。<br />
また、リーナス・トーバルズによる分散バージョン管理システムGitの、<br />
ホスティングサイトGitHubはMicrosoftによって買収された。<br />
Windows上でLinux互換環境を実現するWSLは、<br />
WSL 2によって、Linuxカーネルを完全にWindows上で仮想化し、<br />
Windowsで全てのLinuxアプリケーションが動くようになる。<br />
WindowsでGUIアプリを開発するための標準開発環境である、<br />
.NET Frameworkについても、<br />
.NET Coreをオープン化することでオープンソース化し、<br />
Linuxなどでも.NET Coreを使うことができるようになった。<br />
Azureでも、Linuxをサポート対象に加えている。<br />
このように、Windowsがオープンソースに近づいているのは、<br />
やはり、GoogleやFacebookといったGAFA系の企業がある。<br />
彼らはどんどんオープンソースでプロダクトを公開・標準化しており、<br />
このままだと「Microsoftが開発するよりも先にGAFAが制覇してしまう」。<br />
よって、MSはあえてオープンに近い戦略を取ることで、<br />
GAFAの力をくじいているのである。<br />
しかしながら、いくらMSの技術力とOSシェアが高くても、<br />
GAFAに勝つのは容易ではない。<br />
それは、たとえば開発者視点でのフレームワークである。<br />
Googleのモバイル向けフレームワークのFlutterや、<br />
FacebookのJavaScriptフレームワークのReactなどは、<br />
国際的な視野で見て、圧倒的な開発者の支持を得ている。<br />
地球規模で、FlutterやReactはほぼ標準であり、<br />
多くのプロのエンジニアがそれらを使って開発をしている。<br />
このような波の中で、いくらMSが一流の技術企業であっても、<br />
GAFAに勝つのは困難を極めるだろう。<br />
特に、GoogleのYouTubeなどは、<br />
再生回数に応じて収入が入る仕組みになっており、<br />
たくさんの勝ち馬に乗ろうとするYouTuberが動画をアップし、<br />
一部のYouTuberは莫大な利益をあげている。<br />
それくらい、MSがWindowsで金があるのと同様、<br />
GAFAも同じぐらい金がある。<br />
しかしながら、僕はあえて綺麗事を言う。<br />
それは、「金儲けだけじゃないものもある」ということ。<br />
今のIT技術というのは、<br />
金儲けがまず先にあり、そのためにサービスを作って提供するが、<br />
昔のインターネットはそうじゃなかった。<br />
たとえば2ちゃんねるのようなアングラ匿名掲示板でも、<br />
あるいは昔先駆的だったブログでも、<br />
金儲けではない、「新しいものを一緒に共有する楽しさ」があった。<br />
みんなで掲示板にAAで作った顔文字を投稿するのも、<br />
時には高度な2ちゃんねる専用ブラウザを開発するのも、<br />
「IT技術そのものを楽しんでいる楽しさ」があった。<br />
今のGAFAには、それがない。<br />
Appleのカリスマ経営者スティーブ・ジョブズ氏が死去したことも、<br />
原因のひとつかもしれない。<br />
ジョブズは偉大なエンジニアで、経営者で、デザイナーだったが、<br />
彼が死んだことで、MacだけではなくWindowsやLinuxでさえ、<br />
「デザイン性の欠如したコピー製品になった」。<br />
そのような今のIT業界を、僕は信頼することができないのである。<br />
昔のITは、何が楽しかったかは分からないが、楽しかった。</p>

</div>
<div class="section">
    <h3 id="軟骨がおかしい">軟骨がおかしい</h3>
    <p>足は、軟骨がおかしくなっている。<br />
それは、関節を治しすぎたからである。<br />
軟骨を復活させれば、治した部分が元に戻って治る。<br />
気持ち悪かったのが復活して、元に戻っていく。<br />
すべて、治る。<br />
これこそ、恒星の一生である。</p>

</div>


<script type="text/javascript" src="script.js"></script>
</body>
</html>

