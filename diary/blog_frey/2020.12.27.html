<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet"  href="style.css">
<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">
<title>カーネルやコンパイラをどうしたら短く書けるか - schwarz1009</title>

</head>
<body>
<p><a href="index.html">トップページに戻る</a></p>
<iframe src="menu_menu.html" class="iframe_menu"></iframe>
<p>AUTHOR: schwarz1009<br>
TITLE: カーネルやコンパイラをどうしたら短く書けるか<br>
BASENAME: 2020/12/27/202543<br>
STATUS: Publish<br>
ALLOW COMMENTS: 1<br>
CONVERT BREAKS: 0<br>
DATE: 12/27/2020 20:25:43<br>
CATEGORY: CPU・メモリ・カーネル<br>
CATEGORY: プログラミング


</p>
<ul class="table-of-contents">
    <li><a href="#抽象ステートメント">抽象ステートメント</a></li>
    <li><a href="#Rubyの機能をカーネルに使えないか">Rubyの機能をカーネルに使えないか</a></li>
    <li><a href="#ウィンドウシステムもデスクトップ環境もブラウザもオフィスも全部短く書く">ウィンドウシステムもデスクトップ環境もブラウザもオフィスも全部短く書く</a></li>
    <li><a href="#データとステートメントは本来まったく違うもの">データとステートメントは本来まったく違うもの</a></li>
    <li><a href="#あるべきはイベントである">あるべきはイベントである</a></li>
    <li><a href="#データの中に手続きを書くのは気持ちが悪い">データの中に手続きを書くのは気持ちが悪い</a></li>
    <li><a href="#しかしながらこれは単に関数ライブラリ">しかしながら、これは単に関数ライブラリ</a></li>
    <li><a href="#オブジェクト指向全体主義">オブジェクト指向全体主義</a></li>
    <li><a href="#リクエストすればレスポンスが返ってくるというメッセージ性を使う">リクエストすればレスポンスが返ってくるというメッセージ性を使う</a></li>
    <li><a href="#イベント全てを並列化することでマルチタスクを実現する">イベント全てを並列化することでマルチタスクを実現する</a></li>
    <li><a href="#データを隠蔽するのではなく全て公開する">データを隠蔽するのではなく、全て公開する</a></li>
    <li><a href="#グラフィックス画面を共有する">グラフィックス画面を共有する</a></li>
    <li><a href="#プロセスとスレッドに区別は必要ない">プロセスとスレッドに区別は必要ない</a></li>
    <li><a href="#セイト先生ありがとう">セイト先生ありがとう</a></li>
</ul>
<div class="section">
    <h3 id="抽象ステートメント">抽象ステートメント</h3>
    <p>僕は、カーネルやコンパイラをどうやったら短く書けるかを考えている。<br />
最近のプログラミング言語は、<br />
「データと手続きをクラスに詰め込む」のように、<br />
多くが、データと手続きを同じものにして、<br />
データの中に手続きがあるかのような考え方をしているが、<br />
むしろ、「データと手続きをより分離する」ようにしたらどうだろうか。<br />
たとえば、プログラムにおけるデータは全てどこかに移してしまって、<br />
具体的なコードは全て部品化されたものを使い、<br />
主に書くのは「抽象ステートメント」というべき「単なる数行のコード」とする。<br />
リファクタリングが必要ないくらい、抽象化された小さなコードが可能となる。<br />
すなわち、フレームワークと同じように、枠組みだけを記述する。<br />
ひとつの枠組みのもとにコードを書くというよりは、<br />
たくさんの小さな部品があって、それの大まかな枠組みを書くことで、<br />
プログラミングを行うのである。</p>

</div>
<div class="section">
    <h3 id="Rubyの機能をカーネルに使えないか">Rubyの機能をカーネルに使えないか</h3>
    <p>僕が思ったのは、<br />
「Rubyの機能をカーネルに使えないか」ということである。<br />
Rubyのモジュールやオブジェクトを使うことで、<br />
なんとなく、良いものは作れそうである。<br />
しかしながら、Rubyは動的なインタープリタであるため、<br />
そのままではカーネルに使えない。<br />
最低限のRubyの機能を持った独自のコンパイル言語を作る必要がある。</p>

</div>
<div class="section">
    <h3 id="ウィンドウシステムもデスクトップ環境もブラウザもオフィスも全部短く書く">ウィンドウシステムもデスクトップ環境もブラウザもオフィスも全部短く書く</h3>
    <p>上手く設計すれば、<br />
ウィンドウシステムも、デスクトップ環境も、ブラウザも、オフィスイートも、<br />
全て、短く書けるはずである。<br />
もっとも短く、同時に実用的なOSと操作環境を作れないかと少し考えた。</p>

</div>
<div class="section">
    <h3 id="データとステートメントは本来まったく違うもの">データとステートメントは本来まったく違うもの</h3>
    <p>そう、データとステートメントは、<br />
本来まったく違うものではないかと僕は思う。<br />
データは開く、読む、書く、閉じるでデータをCRUD操作するものであり、<br />
ステートメントは上から下へと順序実行されるものである。<br />
歴史と記憶を同じものにするのはおかしい。<br />
データからステートメントを排除し、<br />
ステートメントからデータを排除する。<br />
その方向で、上手く全体をデザインすることができないかと思う。</p>

</div>
<div class="section">
    <h3 id="あるべきはイベントである">あるべきはイベントである</h3>
    <p>むしろ、統一すべきはデータとメソッドではなく、<br />
むしろイベントではないかと思う。<br />
イベントとはすなわち、<br />
「関数を呼び出したタイミングでコードが実行される」ということ全般である。<br />
さまざまなイベントがまずあり、<br />
その上でデータとステートメントがあるのである。<br />
中心に置くべきは「イベントの発火とその時起きる現象」であり、<br />
歴史や記憶はその後に現れるべきものである。</p>

</div>
<div class="section">
    <h3 id="データの中に手続きを書くのは気持ちが悪い">データの中に手続きを書くのは気持ちが悪い</h3>
    <p>僕は、データの中に手続きを書くのが、<br />
気持ちが悪いのである。<br />
むしろ、グローバル変数とオブジェクト指向は、程度が変わらない。<br />
グローバル変数を個別にインスタンス化し、<br />
グローバル変数にアクセスできるメソッドをfriendするのと同じである。<br />
より素晴らしいデザインとは、<br />
全ての全体像がまずあって、<br />
そこからイベントが発火され、<br />
イベントに応じてコードが実行され、<br />
そのイベントがデータであり、メモリやファイルであり、<br />
同時に実行されるコードであるかのようなシステムである。</p>

</div>
<div class="section">
    <h3 id="しかしながらこれは単に関数ライブラリ">しかしながら、これは単に関数ライブラリ</h3>
    <p>しかしながら、これはまだ賢いデザインとは言えない。<br />
なぜなら、関数をイベントと言っているだけにすぎない。</p>

</div>
<div class="section">
    <h3 id="オブジェクト指向全体主義">オブジェクト指向全体主義</h3>
    <p>しかしながら、データを共有されるものであるとするなら、<br />
「データ共有プール」がまずあって、<br />
そのデータにアクセスできるコードをあらかじめ書いておいて、<br />
そのコードを使ってさらにプログラムを書く、<br />
という、言ってしまえば<br />
「オブジェクト指向全体主義」のようなシステムにすることで、<br />
全体は綺麗になるだろう。<br />
しかしながら、こうした場合、自由度は無くなるだろう。<br />
ソ連の計画経済が自由度がなくなって破綻するのと同じで、<br />
このシステムはすぐに破綻するだろう。</p>

</div>
<div class="section">
    <h3 id="リクエストすればレスポンスが返ってくるというメッセージ性を使う">リクエストすればレスポンスが返ってくるというメッセージ性を使う</h3>
    <p>そして、僕が考えるのは、メッセージを使う方法であり、<br />
これは「リクエストすればレスポンスが返ってくる」という<br />
メッセージの性質を使うものである。<br />
すなわち、システムマネージャにイベントを発火するリクエストを要求し、<br />
それがデータ共有プールにアクセスし、<br />
いろいろとコードを実行した上で、レスポンスを返す、<br />
これら全てを「メッセージ」として実現する。</p>

</div>
<div class="section">
    <h3 id="イベント全てを並列化することでマルチタスクを実現する">イベント全てを並列化することでマルチタスクを実現する</h3>
    <p>ここで、僕はマルチタスクを導入する。<br />
すなわち、イベント全てが並列で動くようにし、<br />
メッセージすべてはパケットがデータ回線を伝わるように、<br />
キューとして実現する。<br />
全てのイベントは並列で動き、<br />
メッセージキューは常に生成・削除され、送受信される。<br />
こうすれば、ネットワーク化された分散環境を作ることもできる。</p>

</div>
<div class="section">
    <h3 id="データを隠蔽するのではなく全て公開する">データを隠蔽するのではなく、全て公開する</h3>
    <p>僕は、データを必ずしもインターフェースのユーザーから隠蔽する必要はない。<br />
なぜなら、たとえばOSI参照モデルでは、<br />
データを隠蔽するモデルではなく、<br />
ヘッダやテイルを付加・除去するモデルを取っている。<br />
たとえば、ウィンドウシステムのウィンドウを使うのに、<br />
クライアント側にサーバ側がシステムを隠蔽するのではなく、<br />
サーバ側が与えるリソース全てを隠蔽せず自由に公開することはできる。<br />
ここでOSIのようなリファレンス型の階層型アーキテクチャを取ることはできる。<br />
ウィンドウシステム層の上にツールキット層があり、<br />
ツールキット層の上にアプリケーション層があり、<br />
それらにヘッダやテイルを付加することで、各層でデータのやり取りを行えばいい。</p>

</div>
<div class="section">
    <h3 id="グラフィックス画面を共有する">グラフィックス画面を共有する</h3>
    <p>ただし、前述したモデルは上手くいかないだろう。<br />
より基本的なモデルは、<br />
まず、ウィンドウシステムサーバーがグラフィックス画面を描画領域として与え、<br />
同時にツールキットサーバーがツールキット部品を与え、<br />
アプリケーションがその使用方法と実行されるコード部品を与え、<br />
それらを統合してアプリケーションを動作させる<br />
「マネージャ」が中央管理をするモデルである。<br />
そのマネージャがOSとなる。<br />
ここでは、まるでアプリケーションがサーバーであり、OSはクライアントだが、<br />
実際、OSはむしろクライアントであるべきである。<br />
なぜなら、むしろGUIを表示するUI画面こそが、<br />
クライアントであるべきではないかと思う。<br />
むしろ、本当はGUIのUI画面すら、サーバーであるべきである。<br />
全て、サーバーであるべきであり、<br />
サーバーとは要するに「機能を提供するもの」であり、<br />
その機能について操作を行う<br />
「ユーザーが主体となる使い手」になるべきだからである。<br />
アプリケーションは明らかにサーバーであるべきである。<br />
なぜなら、それはおかしなことではない。<br />
ウィンドウシステムサーバーとツールキットサーバーを使う、<br />
クライアントであるアプリケーションは、<br />
ユーザーから見ればサーバーである。<br />
よって、アプリケーションサーバーに対する「画面端末」が<br />
最終的なクライアントとなる。</p>

</div>
<div class="section">
    <h3 id="プロセスとスレッドに区別は必要ない">プロセスとスレッドに区別は必要ない</h3>
    <p>また、プロセスとスレッドに区別は必要ない。<br />
全てのプロセスがスレッドを通じて実装されるべきである。<br />
なんだかマイクロカーネルのようになってきたが、<br />
まあ、Machがどうしても動かない理由がよく分かる。</p>

</div>
<div class="section">
    <h3 id="セイト先生ありがとう">セイト先生ありがとう</h3>
    <p>セイト先生に感謝を申し上げます。<br />
僕が見たのは以下の動画。<br />
<a href="https://www.youtube.com/watch?v=vMjSC4TQa6c">https://www.youtube.com/watch?v=vMjSC4TQa6c</a><br />
この動画を見て、いつまでも本ばかり読んでいても意味がない、<br />
ということが分かった。<br />
まさに、「作れ」ということです。<br />
何か、作ってみよう。<br />
考えても読んでも書いても意味がない。<br />
プログラミングをするためには「作る」ことが一番だと<br />
僕もようやく悟ることができました。<br />
ちなみに、以下の動画も見ました。<br />
<a href="https://www.youtube.com/watch?v=BOrx1GEZY4o">https://www.youtube.com/watch?v=BOrx1GEZY4o</a><br />
6割ぐらい理解できていることを、<br />
もっと詳しくやろうと思っていましたが、<br />
むしろ、6割のままで何かを作った方が良い、<br />
ということが分かってよかったです。</p>

</div>


<script type="text/javascript" src="script.js"></script>
</body>
</html>

